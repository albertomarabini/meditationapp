

# Architectural Plan:
| Component Name | Description |
| -------------- | ----------- |
| AppBootManager | Orchestrates initial app boot, hydration of state, registration of background jobs, and global error boundaries.<br>**System Boundaries & State Flow**- On app launch, hydrates Zustand stores from SQLite and persistent storage.<br>- Registers background jobs for backup and stats aggregation based on stored flags.<br>- Loads theme and last used form state.<br>**Responsibilities & Interactions**:<br>- Triggers hydration routines for all stores.<br>- Registers background jobs if enabled.<br>- Handles fallback to defaults if corrupt data detected.<br>**Event Flows**:<br>- Binds to Expo app mount event, AppState changes, and Zustand hydration events.<br>- Subscribes to OS-level boot and resume events.<br>**Data Ownership & Lifespan**:<br>Does not directly own domain data; manages app-level state initialization for all persistent entities.<br>**External Dependencies & Integration**:<br>expo-sqlite, AsyncStorage, expo-background-fetch, expo-task-manager, expo-secure-store. |
| NavigationLayer | Manages all screen transitions, navigation stacks, modals, and navigation event bindings.<br>**System Boundaries & State Flow**- Controls screen transitions and stack.<br>- Handles navigation parameters for session IDs, diary entries, etc.<br>- Resets and restores scroll positions for screens as necessary.<br>**Responsibilities & Interactions**:<br>- Exposes navigation functions to UI components (navigate, goBack, openDrawer).<br>- Preserves and restores scroll/UI state between screens.<br>- Integrates with navigation event listeners for focus and back actions.<br>**Event Flows**:<br>- Handles user UI navigation triggers (button presses, icon taps, Drawer actions).<br>- Binds to navigation events like focus, beforeRemove, onRequestClose.<br>**Data Ownership & Lifespan**:<br>Navigation state is ephemeral; navigation params are transient per session/screen.<br>**External Dependencies & Integration**:<br>React Navigation, React Native Paper (Drawer/Modal). |
| TimerStateStore | Implements all data operations and business logic for Session Timers. Responsible for storing, mutating, and retrieving all persisted Session Timer records. Exposes mutation/query APIs for CRUD operations. Owns validation rules such as enforcing unique names (checks SQLite for duplicates on save), ensuring session timer data matches all schema and business constraints. Executes atomic insert/update/delete mutations in SQLite via expo-sqlite with post-mutation consistency: after each mutation, reads the latest timers from SQLite and updates Zustand, ensuring all UI reflects persistent state. Owns draft state for form in-progress edits/creation, supporting hydration from persisted state (on app boot or form load). Integrates with SessionTimerForm for save, delete, and validation operations, and with NotificationManager for synchronizing reminders on timer mutation or deletion. Handles error propagation and validation failures (e.g., duplicate name) by updating Zustand error state, triggering automatic UI feedback. Responsible for not performing any cascading delete or pre-checks on timer deletion (other entities referencing the timer must manage their own cleanup). |
| SessionTimerForm | **Component Role**: Renders and orchestrates the complete Session Timer creation and editing flow‚Äîhandling all user interactions for field modification, validation, confirmation, notification setup, and persistence. Acts as the sole initiator of Session Timer CRUD, including reminder scheduling/cancellation, and manages all in-progress state, error, and feedback flows. <br> **Technological Capabilities Used**: React Native Paper (form fields, pickers, sliders, buttons, icon buttons, dialogs, snackbar), @react-native-picker/picker (dropdowns), validate.js/custom validators (validation), Zustand (form and error state, draft persistence), expo-sqlite (DB CRUD via TimerStateStore), expo-notifications (reminder scheduling/cancellation), expo-image-picker (for file selection if needed), React Navigation (screen stack, confirm dialogs), JS Date/Intl (validation), AsyncStorage (draft/save), Paper Dialogs (confirmation, error), and modal permission APIs. <br> **System Boundaries & State Flow**: Owns only in-progress form state (local/Zustand draft). Only persists on Save; resets all state on Cancel. Updates to notifications/reminders are performed only after successful DB commit. Handles validation/enablement state for all controls. <br> **Component Responsibilities & Interactions**: <ul> <li>Renders all Session Timer fields; updates local/Zustand draft state on any change, with immediate validation and error feedback (including reminder time checks).</li> <li>On Save, validates entire form, performs atomic SQLite insert/update via TimerStateStore, and schedules/cancels reminders via NotificationManager after commit.</li> <li>On Delete, confirms with user, cancels all reminders before deleting timer, and ensures atomicity of operation.</li> <li>On Cancel/back, resets state to last persisted values or clears draft if new; surfaces unsaved changes dialog as needed.</li> <li>Handles all picker/file actions with permission gating and fallback on cancellation.</li> <li>Surfaces all errors (mutation, notification, scheduling, permission) via Dialogs/Snackbars and disables relevant controls on error/permission denial.</li> <li>All notification and DB interactions are transactional and strictly ordered.</li> <li>Manages field enablement/disabling, error messages, and UI feedback based on validation/error state.</li> </ul> <br> **Domain-Specific/Custom Logic**: <ul> <li>Reminder scheduling/cancellation is only performed after DB commit; any notification error triggers rollback and user feedback.</li> <li>Validation of reminder time to ensure not in the past.</li> <li>Atomic delete: cancels all reminders and notification records before deleting the Session Timer from DB.</li> <li>Strict separation of in-progress/draft state and persisted data.</li> </ul> <br> **Non-Boilerplate Behaviors**: <ul> <li>Unsaved changes dialog gating navigation/back actions.</li> <li>Resilient error handling: all failures leave form open and user‚Äôs latest input intact.</li> <li>Transactional notification/DB operations to prevent race conditions and partial state.</li> </ul> <br> **Data Ownership & Lifespan**: Holds only in-progress/draft form state (local/Zustand), resets or persists on explicit user action. <br> **External Dependencies & Integration Points**: React Native Paper, Zustand, expo-sqlite (via TimerStateStore), expo-notifications (via NotificationManager), validate.js/custom validators, expo-image-picker, AsyncStorage, React Navigation, JS Date/Intl. |
| MainScreen | **Component Role:** Acts as the primary UI entry for users to browse, select, and initiate Session Timers, navigate to Calendar and Settings, and view/manage the ad banner. <br> **Technological Capabilities Used:** Leverages React Native Paper (UI controls, lists, icons, dialogs), FlatList for efficient rendering, Zustand for reactive state (Session Timers, Settings, Theme), React Navigation for routing, AdMob/Expo-Ads-Adapter for ads, Expo Image for backgrounds, and React Native accessibility APIs. <br> **System Boundaries & State Flow:** Does not own persistent data; subscribes to TimerStateStore and SettingsStore for Session Timers and ads removal flag. Tracks scroll position and layout locally/transiently. Receives navigation events and manages ephemeral UI state (dialogs, error status, loading). <br> **Component Responsibilities & Interactions (Operationalized):** <ul><li>On mount, loads Session Timers from SQLite via TimerStateStore, updates Zustand (presenting empty state if no timers).</li><li>Renders vertical, deduplicated list of Session Timers, ensuring unique IDs (filters duplicates, disables reorder/search/sort).</li><li>Provides visual feedback for loading/error states via Paper `<ActivityIndicator>`, `<Snackbar>`, and disables controls when background processes run.</li><li>Handles all UI events: Play (launches MeditationSessionWindow), Edit (navigates to SessionTimerForm), FAB "+" (opens SessionTimerForm create), Calendar (routes to CalendarView), Settings (opens Drawer), and ad banner events.</li><li>Renders persistent Ad banner unless `adsFreePurchased` is true (conditional layout, safe area).</li><li>Tracks and restores FlatList scroll position on navigation/backgrounding/resume.</li><li>Reacts to AppState changes by rehydrating Session Timers, Theme, and restoring scroll position.</li><li>Updates UI layout on orientation/layout change to prevent overlap of FAB, Calendar, and Ad banner.</li><li>Displays error dialogs/snackbars for SQLite errors or operations, with dismiss/retry logic.</li><li>Implements accessibility props and labels (touch, keyboard, screen reader).</li><li>Integrates with Theme for palette/background updates, using Expo Image or fallback.</li><li>Exits app on hardware back from MainScreen (Android).</li></ul> <br> **Domain-Specific/Custom Logic:** <ul><li>Enforces no duplicate rendering of Session Timers (ID deduplication post-load/refresh).</li><li>Does not persist draft state; creation/edit is isolated to SessionTimerForm.</li><li>No logging/analytics code is present per requirements.</li></ul> <br> **Non-Boilerplate Behaviors:** <ul><li>Resets scroll on list changes, preserves UI state on navigation resume.</li><li>Conditional rendering logic for ad banner (persistent/hide with layout reclaim).</li><li>Accessibility setup for all interactive elements.</li><li>Responsive layout calculation for bottom/side controls.</li></ul> <br> **Data Ownership & Lifespan:** Holds only transient, local UI state; subscribes to persisted stores for data. <br> **External Dependencies & Integration Points:** React Native Paper, React Navigation, Zustand, Expo-sqlite, AdMob/Expo-Ads-Adapter, Expo Image, AppState, FlatList, accessibility props. |
| MeditationSessionWindow | Component Role:  The MeditationSessionWindow provides the runtime environment for a single meditation session, orchestrating state transitions, timer management, segmented/overall timing logic, audio playback, DND/screen settings, session interruption/recovery, explicit teardown, and log persistence. <br><br>  Technological Capabilities Used:  Integrates React Native Paper for all UI controls (buttons, dialog, timer displays), Zustand for session state isolation and reactivity, expo-av for orchestrated playback of segmentation and meditation sounds (including volume, repeat logic, and error feedback), expo-keep-awake for session-specific screen wake locking, react-native-do-not-disturb for DND activation/deactivation, Lottie or Animated GIF for always-on center animation, React Navigation for screen routing, AppState for auto-pause/interruption handling, JavaScript timer APIs for precise tick logic, and Expo Image for themed session backgrounds. <br><br>  System Boundaries & State Flow:  <ul><li>On mount and focus, loads and deep-copies the precise session blueprint (capturing all segments, sounds, and settings) from Zustand, making all subsequent mutations to settings or the blueprint irrelevant until session termination.</li><li>Maintains all transient timer, audio, paused/active/terminated state, and control status in component-local state, with selected fields mirrored to Zustand for recovery.</li><li>On session termination, persists a performed-session log to LogStateStore, which then propagates to SQLite and all subscribed consumers.</li><li>Active/in-progress session state is persisted to SQLite/Zustand upon unmount for recovery after interruptions.</li></ul> <br><br>  Component Responsibilities & Interactions:  <ul><li>Receives session timer ID or blueprint as navigation param on entry; loads and locks session config, including segment breakdown, sound URIs, volume, repetition, and all global flags at start.</li><li>On Start, transitions session state to `in_session`, activates round and digital timers with appropriate count-up/down logic per global setting, orchestrates segmented timing and transitions (preparation, segment-by-segment), triggers segmentation sound(s) with programmed repetition via expo-av, and plays meditation sound (loop/count) with proper error handling and fallback.</li><li>Controls session state via explicit UI (Start, Pause, Continue, Back), direct system (AppState) events, and binding all timer/audio event callbacks to local handlers that update session state and UI responsively.</li><li>On Pause, halts timers, pauses sound playback, disables wake lock and DND if enabled, sets state to paused, and displays the correct visual cues.</li><li>On Continue, resumes timers and audio from precise paused positions, restores wake lock/DND, and returns UI to in-session state.</li><li>Handles all session termination logic via explicit user action: surfaces confirmation dialog, blocks further navigation, and on confirmation performs full teardown (clear timers, stop/unload audio, deactivate DND/wake, log session, navigate away).</li><li>Implements full AppState and navigation-based interruption handling: on component unmount or app background, persists all current session progress and audio state to SQLite/Zustand for later recovery; on app resume, surfaces the session in paused state for explicit user continuation.</li><li>Handles playback or timer errors, triggering explicit visual dialogs with user-driven recovery/termination options.</li><li>Enforces at all times that no blueprint/setting changes can affect a running session; only next sessions use updated configs.</li><li>Manages precise sequencing of sound playback, repetition, and error fallback (including disabling sound for session if user requests after error).</li><li>Triggers all relevant log persistence and Zustand/integration updates upon session end.</li></ul> <br><br>  Domain-Specific/Custom Logic:  <ul><li>All session configuration (segments, sounds, volumes, global flags) is deep-copied and frozen at session start; any external edits take effect only on next session.</li><li>Session is only terminated by explicit user action via Back/confirmation; never auto-ends on completion of segments.</li><li>When app is interrupted (background or process killed), local state is always persisted for exact recovery (timer, audio positions, etc.), and session resumes only in paused mode for user resumption.</li><li>Errors in sound playback or timers surface explicit dialogs with user choice to terminate or continue; timers/audio are always cleared on session teardown.</li></ul> <br><br>  Non-Boilerplate Behaviors:  <ul><li>Complex, stateful timer logic for both segmented and digital elapsed timing, with precise count-up/down handling per setting.</li><li>Explicit AppState-unmount persistence and precise navigation gating on Back/system events, with dialogs gating any teardown.</li><li>Persistent control over DND and wake lock by runtime session state, not global settings.</li></ul> <br><br>  Data Ownership & Lifespan:  Owns only ephemeral session state, timers, and audio refs; all persistent data (logs, settings, blueprints) resides in Zustand/SQLite. <br><br>  External Dependencies & Integration Points:  React Native Paper, Zustand, expo-av, expo-keep-awake, react-native-do-not-disturb, Lottie/GIF, React Navigation, AppState, setInterval/clearInterval, Expo Image. |
| LogStateStore | Centralized authoritative store for Meditation Logs (performed sessions), exposes mutation/query APIs.<br>**System Boundaries & State Flow**- Stores all meditation log entries.<br>- Persists to SQLite.<br>- Hydrates/updates on app boot, session end, edit, or restore.<br>**Responsibilities & Interactions**:<br>- CRUD for logs.<br>- Provides selectors by date, range, and for statistics aggregation.<br>- Exposes interfaces for CalendarView, StatisticsPage, and log editing.<br>- Handles log updates on session completion and duration edits.<br>- Coordinates with DiaryStore for timestamp uniqueness.<br>**Event Flows**:<br>- Handles log insertion on session end.<br>- Responds to UI edit/delete actions.<br>- Triggers state updates to subscribers (Calendar, Stats) on mutation.<br>**Data Ownership & Lifespan**:<br>Owns all meditation logs, persisted in SQLite and mirrored in Zustand.<br>**External Dependencies & Integration**:<br>expo-sqlite. |
| DiaryStore | Centralized store for Diary Entries, ensures timestamp uniqueness, exposes CRUD APIs.<br>**System Boundaries & State Flow**- Holds all diary entries.<br>- Persists to SQLite.<br>- Hydrates on boot and after backup/restore.<br>- Enforces one entry per timestamp.<br>**Responsibilities & Interactions**:<br>- CRUD for diary entries.<br>- Exposes interfaces to DiaryView, CalendarView, and DiaryEntryEditor.<br>- Checks for timestamp uniqueness, overwrites on same timestamp.<br>- Notifies subscribers on mutation.<br>- Exports entries for sharing.<br>**Event Flows**:<br>- Handles save/delete/edit from DiaryEntryEditor or CalendarView.<br>- Validates on save.<br>- Updates Calendar and DiaryView via Zustand subscriptions.<br>**Data Ownership & Lifespan**:<br>Owns all diary entries, persisted in SQLite and mirrored in Zustand.<br>**External Dependencies & Integration**:<br>expo-sqlite. |
| DiaryEntryEditor | Component Role:  DiaryEntryEditor provides a focused UI and logic environment for creating or editing a single diary entry, enforcing content and timestamp validation, supporting undo/redo workflows, surfacing error/cancel/delete dialogs, and persisting valid entries exactly as per the non-functional requirements. <br><br>  Technological Capabilities Used:  Extensively uses React Native Paper components for all UI controls (TextInput, Buttons, IconButtons, dialogs, helper/error text), Zustand for interfacing with diaryEntries state and triggering store actions (insert/update/delete), expo-sqlite for data persistence, React Navigation for routing, and local React useState for transient editor state and undo/redo stacks. <br><br>  System Boundaries & State Flow:  <ul><li>Receives entry timestamp as navigation param; on mount, loads existing entry from Zustand (and expo-sqlite as needed), or initializes blank state for creation mode.</li><li>Owns all ephemeral local state for content input, undo/redo stacks, error state, save/enablement flags, and dialog visibility.</li><li>Only persists data to Zustand/SQLite on explicit Save/Arrow action; all local state is discarded on Cancel, navigation away, or unmount.</li><li>On unmount, always wipes undo/redo stacks and ephemeral state to prevent memory leaks; never persists these beyond instance duration.</li></ul> <br><br>  Component Responsibilities & Interactions:  <ul><li>On mount, validates and initializes local state with current diary entry (edit) or blank (create), sets up undo/redo stacks, and disables Save/Arrow until valid.</li><li>On content input change, pushes previous content to undo stack, clears redo stack, updates local state, and runs validation (disabling Save/Arrow if invalid, surfacing error text via Paper component).</li><li>On Undo, pops previous content from undo stack (if available) and pushes current to redo stack; on Redo, pops from redo stack and pushes to undo stack; disables controls if stacks empty.</li><li>On Save/Arrow, validates fields, blocks if invalid, then persists via Zustand store action (which inserts/updates SQLite) and navigates away.</li><li>On Cancel, discards any unsaved entry for new notes, resets local state, and navigates away.</li><li>On Delete, surfaces confirmation dialog (Paper Dialog); on confirm, deletes entry via Zustand/SQLite, then navigates away; on cancel, closes dialog only.</li><li>On hardware/system back navigation, intercepts via navigation event, resets all local state, and navigates away.</li><li>On invalid/malformed/duplicate timestamp detection, blocks all persistence, surfaces error UI/dialog, and exits the editor.</li><li>On unmount, always discards all ephemeral state, including undo/redo stacks.</li></ul> <br><br>  Domain-Specific/Custom Logic:  <ul><li>Enforces per-edit-instance undo/redo only in local state, never shares or persists across editor sessions.</li><li>Disables Save/Arrow controls and surfaces error text if content is empty/invalid or timestamp is not unique/valid.</li><li>Only persisted diary entries (via SQLite) are exportable; in-memory-only drafts are ignored.</li><li>Uniqueness of timestamp is double-enforced: at validation on save and by DB PK rules.</li></ul> <br><br>  Non-Boilerplate Behaviors:  <ul><li>Undo/redo managed entirely in local state; state is cleaned up on navigation or unmount.</li><li>Identical, reusable UI and flow for all entry points (CalendarView, DiaryView, etc.), ensuring perfect behavioral parity.</li><li>Explicit gating of all persistence on valid state only; never allows partial or invalid saves.</li></ul> <br><br>  Data Ownership & Lifespan:  Local state for the duration of editor instance only; all persistence via Zustand/SQLite. <br><br>  External Dependencies & Integration Points:  React Native Paper, Zustand, expo-sqlite, React Navigation, useState/useEffect. |
| CalendarView | Component Role:  CalendarView presents a unified view of meditation logs and diary entries mapped onto a calendar grid and per-day vertical list, facilitating browsing, inspection, and contextual editing of entries anchored by date/timestamp. <br><br>  Technological Capabilities Used:  Utilizes react-native-calendars for date grid input/display, React Native Paper for all UI controls (cards, buttons, dialogs, modals, inputs), Zustand for reactive state slices (logs, diaries, theme), React Navigation for routing to detail/edit screens, expo-sqlite for persistent data operations, React hooks for responsive UI state, and accessibility APIs for accessible event labeling. <br><br>  System Boundaries & State Flow:  <ul><li>Does not own persistent data; subscribes to meditationLogs and diaryEntries slices in Zustand, which reflect SQLite.</li><li>Maintains local state for currently selected date, modal/dialog open status, edit modes, scroll position, and error states.</li><li>Updates to meditation logs or diary entries are always propagated reactively from Zustand after any store mutation (insert/update/delete).</li><li>Formats dates/times using device locale, applies current theme for all rendered UI.</li></ul> <br><br>  Component Responsibilities & Interactions:  <ul><li>On mount, renders calendar grid (react-native-calendars) and vertical per-day list (React Native Paper List), sourcing all data from Zustand.</li><li>On day cell tap, queries SQLite for all meditation logs and diary entries for that day, updates Zustand state, and triggers UI re-render to show selected day's items.</li><li>On meditation log entry tap, opens modal/dialog displaying details (start time, duration), with Edit Duration and Add/Edit Diary controls; only one modal open at a time, controlled by local state.</li><li>Handles Edit Duration flow: enables local edit mode in modal, renders editable field, validates input, and on save, updates both SQLite and Zustand; all error, cancel, and confirm flows handled locally.</li><li>Handles Add/Edit Diary flow: checks for existing diary entry with matching timestamp; enforces uniqueness in both UI and data; navigates to DiaryEntryEditor for existing/new entry; prevents/blocks duplicates at both layers.</li><li>On standalone diary entry tap, navigates to DiaryEntryEditor for edit, passing timestamp; all editing and persistence handled by downstream screen.</li><li>Handles Diary View button press by routing to DiaryView via React Navigation.</li><li>Handles Back button by navigating to MainScreen, preserving UI state (scroll/date).</li><li>Handles all SQLite transaction errors by surfacing Paper Dialog/Snackbar UI, rolling back Zustand data as needed, and ensuring UI consistency.</li><li>Applies accessibility props/labels per control; formats all dates/times via device locale using Intl.DateTimeFormat or equivalent.</li><li>Rerenders reactively on all store changes (logs or diaries), with no manual refresh logic.</li><li>Prevents any creation of multiple diary entries with same timestamp as a meditation; enforces via UI disabling and store/DB checks.</li><li>Displays empty state or "No activity" marker as styled Paper component for non-active days.</li></ul> <br><br>  Domain-Specific/Custom Logic:  <ul><li>Strict 1:1 mapping of diary entries to meditations by timestamp; UI and data layer enforce this invariant.</li><li>All date/time formatting is localized to device region, and only unique, valid PKs are accepted for logs and diaries.</li><li>All UI and modal state is managed locally per-instance, ensuring single-modal constraints and correct restoration on navigation.</li><li>Error/rollback logic always ensures data in Zustand reflects the last known good state from SQLite on transaction failures.</li></ul> <br><br>  Non-Boilerplate Behaviors:  <ul><li>Complex, multi-modal edit flows for meditation logs and diary entries, including uniqueness enforcement and UI gating.</li><li>Conditional/inline rendering of controls (edit/save/cancel) in modals/dialogs based on local edit state.</li><li>Persistent, localized empty state handling per day.</li></ul> <br><br>  Data Ownership & Lifespan:  Owns only ephemeral UI/modal state; all persistent data managed in Zustand/SQLite. <br><br>  External Dependencies & Integration Points:  react-native-calendars, React Native Paper, Zustand, expo-sqlite, React Navigation, accessibility APIs, Intl.DateTimeFormat. |
| DiaryView | Component Role:  The DiaryView screen provides a chronological, scrollable listing of all persisted diary entries, enabling users to browse, edit, and export their notes independently of calendar context. <br><br>  Technological Capabilities Used:  Renders all UI via React Native Paper (List, Buttons, IconButtons), subscribes to Zustand diaryEntries slice for reactive updates, integrates with React Navigation for transition to DiaryEntryEditor, uses JS-YAML for serialization, and react-native-share for sharing/export functionality. <br><br>  System Boundaries & State Flow:  <ul><li>Does not own persistent data; all diary entries are sourced directly from Zustand/SQLite.</li><li>Maintains only ephemeral local state for scroll position, loading/export status, and modals/dialogs.</li><li>All UI automatically updates in response to changes in diaryEntries state via Zustand subscription (React hooks).</li></ul> <br><br>  Component Responsibilities & Interactions:  <ul><li>On mount, renders vertical list of all diary entries chronologically, with content, timestamp, and an edit button per entry.</li><li>On edit button press, navigates to DiaryEntryEditor, passing timestamp; all edit logic is handled in the editor.</li><li>On add button press, creates a new draft entry using the current timestamp and navigates to DiaryEntryEditor (with Save/Arrow disabled until valid content).</li><li>On export button press, retrieves all persisted diary entries from Zustand/SQLite, serializes them to YAML with JS-YAML, and initiates sharing via react-native-share (system dialog).</li><li>Rerenders list immediately/reactively on any diary entry mutation (insert/update/delete) due to Zustand store subscription.</li><li>Ensures only persisted entries (those saved in SQLite) are exported/shared.</li></ul> <br><br>  Domain-Specific/Custom Logic:  <ul><li>Only entries with unique, valid ISO8601 timestamps are allowed (validation in editor and enforced by SQLite PK).</li><li>Never includes unsaved/in-memory-only drafts in exports.</li><li>Export shares data using exact YAML schema as required (timestamp/content fields).</li></ul> <br><br>  Non-Boilerplate Behaviors:  <ul><li>Immediate UI update on any diary entry state change via Zustand subscription.</li><li>Chronological ordering of entries by timestamp, enforced in both rendering logic and export.</li></ul> <br><br>  Data Ownership & Lifespan:  No local persistence; relies fully on Zustand/SQLite-backed data. <br><br>  External Dependencies & Integration Points:  React Native Paper, Zustand, expo-sqlite, React Navigation, JS-YAML, react-native-share. |
| StatisticsPage | **Component Role**: Presents and manages all user-facing visualization and export flows for meditation statistics. Aggregates and recalculates statistical summaries and time-series chart data on every relevant state change. Handles user export requests and time-period selection, providing immediate chart, summary, and sharing feedback. <br> **Technological Capabilities Used**: React Native Paper (UI controls, buttons, legend, summary), react-native-chart-kit (chart rendering and error handling), Zustand (meditation logs state, settings state, reactive selectors), js-yaml (serialization), react-native-share (system share dialog), JS Date/Intl (date formatting/grouping), useEffect/hooks for reactivity. <br> **System Boundaries & State Flow**: Receives meditation log data from LogStateStore (Zustand), local state for selected time period, calculated stats, chart data, isSharing, and chartError. No persistent state is owned; all chart/aggregation state is transient and recalculated on every change. <br> **Component Responsibilities & Interactions**: <ul> <li>Subscribes to meditation logs and settings via Zustand selectors; triggers full aggregation and UI update on every state change.</li> <li>Renders time period selector; on user change, updates selected period and recalculates all statistics (summary, chart data, legend, share enabled/disabled).</li> <li>Renders summary card (total sessions, time, avg duration) and chart (per selected aggregation unit and period).</li> <li>Handles Share button: on press, serializes current stats and chart data to YAML, sets isSharing, disables Share until operation completes, and invokes system share dialog via react-native-share.</li> <li>Handles chart rendering errors: sets chartError; displays HelperText or error placeholder below chart.</li> <li>All UI changes are immediately reactive to state updates; no manual refresh logic is needed.</li> </ul> <br> **Domain-Specific/Custom Logic**: <ul> <li>All aggregation, charting, and export logic strictly filters for valid, persisted meditation logs; excludes incomplete/corrupted entries.</li> <li>Ensures chart and summary units/labels always match period and locale as defined by settings.</li> <li>Exported YAML strictly follows required schema; no diary/export cross-integration.</li> </ul> <br> **Non-Boilerplate Behaviors**: <ul> <li>Disables Share button during export/sharing in progress.</li> <li>Displays chart errors without crashing or leaving incomplete data visible.</li> <li>Fully offline; no external data fetches for aggregation/export.</li> </ul> <br> **Data Ownership & Lifespan**: Owns only aggregation and transient UI state. All persistent data is in Zustand via LogStateStore. <br> **External Dependencies & Integration Points**: React Native Paper, Zustand, react-native-chart-kit, js-yaml, react-native-share, JS Date/Intl. |
| SettingsStore | Centralized store for all global user settings and flags, exposes mutation/query APIs.<br>**System Boundaries & State Flow**- Stores global settings: theme, adsFreePurchased, dndEnabled, keepScreenOn, CountUp, backupEnabled, backgrounds, etc.<br>- Persists to SQLite or SecureStore as appropriate.<br>- Hydrates on boot.<br>**Responsibilities & Interactions**:<br>- Provides settings selectors and mutation APIs.<br>- Updates persisted storage on change.<br>- Notifies subscribers for UI refresh.<br>- Coordinates with AdBanner, MainScreen, MeditationSessionWindow, etc.<br>- Controls background job registration on backupEnabled changes.<br>- Integrates with in-app purchase trigger/responses.<br>**Event Flows**:<br>- Binds to UI toggle/onChange events from SettingsMenu.<br>- Hydrates on app boot.<br>- Handles mutation/selector requests from consumers.<br>- Maintains single source of truth for settings flags.<br>**Data Ownership & Lifespan**:<br>Owns all global settings and flags, persisted as per setting type.<br>**External Dependencies & Integration**:<br>expo-sqlite, expo-secure-store, AsyncStorage. |
| SettingsMenu | **Component Role**: Renders and orchestrates all global configuration settings, in-app purchase/monetization controls, theme/background selection, backup/restore actions, and data sharing/export in a persistent Drawer or Settings screen. This component serves as the exclusive UI and flow point for user customization, backup management, ad removal/purchase actions, and system-level sharing/export.  <br> **Technological Capabilities Used**: React Native Paper (Drawer, Switch, Button, List, Dialog, Picker, Snackbar), Zustand (settings read/write/select, backup/meta access), expo-image-picker (image selection), expo-file-system (file picker/restore), react-native-do-not-disturb (DND toggling/permission), expo-keep-awake (flag management), react-native-share (system share dialog), js-yaml (serialization), AdMob/InAppPurchase API (monetization), expo-secure-store (backup metadata), React Navigation (screen transitions), AsyncStorage (persisting).  <br> **System Boundaries & State Flow**: Does not own persistent data; always reads/writes via SettingsStore. Maintains transient UI/dialog state (open/close, loading, error, confirmation, permission, disabled flags) only. All changes are immediately reflected in Zustand store and persisted. All reactivity is handled by Zustand and React. <br> **Behavioral Responsibilities & Interactions**: <ul> <li>Renders settings toggles and controls; updates Zustand/global settings on change (DND, keep awake, CountUp, ad removal, backupEnabled).</li> <li>Integrates image picking for session backgrounds with permission handling and persistence (built-in image selection, system image picker).</li> <li>Manages backup file listing (from SecureStore), real-time status feedback (backup enabled/disabled, last backup time), and restore flows (opens file picker, restores DB via BackupJobHandler, confirms with dialogs).</li> <li>Handles ad removal: triggers in-app purchase flow, updates adsFreePurchased flag, and hides/shows ad banners accordingly.</li> <li>Handles data export/sharing: retrieves diary/statistics from Zustand, serializes to YAML, opens system share dialog, sets loading/disabled state during sharing.</li> <li>Manages permission requests and result handling: disables UI controls and surfaces error dialogs/snackbars if permissions are denied/not granted (DND, storage).</li> <li>All failed/corrupt state hydration is handled by falling back to defaults and notifying user via Snackbar/Dialog.</li> <li>All control changes (toggles, pickers) provide immediate Paper feedback (loading, disabled, error).</li> <li>Closes Drawer on gesture, backdrop, or explicit close; navigates to Diary Sharing screen as needed.</li> </ul> <br> **Domain-Specific/Custom Logic**: <ul> <li>Manual backup is not allowed; only restore is available. Restore procedure is validated, and DB/file operations are atomic.</li> <li>Backup file operations and meta are strictly scoped to the SQLite DB file per requirements.</li> <li>Image background changes and persistence flows are strictly mediated via SettingsStore; Meditation Session Window is updated reactively.</li> <li>Monetization controls (Remove Ads/Buy Me a Coffee) are tied to dedicated buttons, no cross-trigger.</li> <li>Permission handling for DND and storage is delegated to corresponding libraries; any failure disables relevant controls in UI.</li> <li>All settings changes are atomic and transaction-safe (see DS-6-11).</li> </ul> <br> **Non-Boilerplate Behaviors**: <ul> <li>Conditional rendering of backup status/restore controls; real-time feedback for sharing/export state.</li> <li>Immediate and persistent state synchronization for every control.</li> <li>Fallback and notification for settings hydration errors.</li> <li>Strict separation of UI and data logic: no speculative or cross-component triggers.</li> </ul> <br> **Data Ownership & Lifespan**: Holds only ephemeral UI/dialog state. All persistent data is managed by SettingsStore/Zustand/SQLite/AsyncStorage/SecureStore. <br> **External Dependencies & Integration Points**: React Native Paper, Zustand, expo-image-picker, expo-file-system, react-native-do-not-disturb, expo-keep-awake, react-native-share, js-yaml, AdMob/InAppPurchase APIs, expo-secure-store, AsyncStorage, React Navigation. |
| NotificationManager | **Component Role**: Orchestrates all notification-related logic for the application, including scheduling, cancelling, updating, and restoring local Session Timer reminders, synchronizing expo-notifications state with SQLite, and handling notification interactions. Not directly user-facing, but called by UI and background components to ensure notification consistency. <br> **Technological Capabilities Used**: expo-notifications (local scheduling/cancellation, listener registration, notification response/event handling), expo-sqlite (persistent storage of notification records), Zustand (notification state, settings integration), React Navigation (navigation on notification tap), AppState (boot/resume sync), expo-secure-store (for backup/restore meta), JS Date/Intl for time validation. <br> **System Boundaries & State Flow**: Does not own domain data; all config and notification meta are in SQLite and reflected in Zustand. Notifications are only scheduled/cancelled in expo-notifications upon explicit triggers. Notifies Zustand on all mutations; all state is mirrored for reactivity. <br> **Component Responsibilities & Interactions**: <ul> <li>Schedules or updates local reminders using expo-notifications when reminders are enabled for a Session Timer (called by SessionTimerForm on save).</li> <li>Cancels/removes scheduled notifications when reminders are disabled or Session Timer is deleted.</li> <li>Ensures atomic update of reminder/notification records in SQLite after scheduling/cancelling; removes or marks records inactive as needed.</li> <li>On app boot or resume, loads all reminders from SQLite, checks scheduled notifications against DB, and re-schedules any missing reminders to ensure consistency.</li> <li>On database restore, re-reads notification config from SQLite and reschedules all enabled reminders (only for those not already scheduled).</li> <li>Handles notification response (user taps notification): parses payload, navigates to relevant Session Timer screen, loads data via TimerStateStore.</li> <li>On notification scheduling/cancellation failure, rolls back Zustand and UI to persisted last-good state, shows error dialog, and ensures DB integrity.</li> <li>All successful/failed notification scheduling/cancellation is followed by updating SQLite records and Zustand state for immediate UI reactivity.</li> </ul> <br> **Domain-Specific/Custom Logic**: <ul> <li>Schedules, updates, and cancels notifications only upon DB commit success (never before).</li> <li>Schedules one notification per Session Timer; no deduplication between timers.</li> <li>Notification tap always navigates to the precise Session Timer and loads its data.</li> <li>On restore/boot, re-synchronizes only those reminders that are enabled but missing in expo-notifications (avoiding double-scheduling).</li> <li>Rolls back all changes on notification/DB failure, including restoring state/UI and surfacing errors to the user.</li> </ul> <br> **Non-Boilerplate Behaviors**: <ul> <li>Ensures strict atomicity between notification scheduling/cancellation and SQLite DB mutation.</li> <li>Syncs notification state across app lifecycle and backup/restore.</li> <li>Handles notification-driven navigation, including cross-component data load sequencing.</li> <li>All notification logic is strictly separated from non-notification flows.</li> </ul> <br> **Data Ownership & Lifespan**: Manages ephemeral notification scheduling state; persistent config/meta in SQLite and mirrored in Zustand. <br> **External Dependencies & Integration Points**: expo-notifications, expo-sqlite, Zustand, React Navigation, JS Date/Intl, expo-secure-store. |
| BackupJobHandler | Implements scheduled backup of SQLite DB, manages backup retention and metadata, and handles restore workflows.<br>**System Boundaries & State Flow**- Copies DB file to backup folder daily if enabled.<br>- Maintains backup metadata (max 5, deletes oldest).<br>- Updates SecureStore with backup info.<br>- Handles concurrency for backup/restore.<br>- Coordinates full restore on user request.<br>**Responsibilities & Interactions**:<br>- Implements backup eligibility check.<br>- Executes atomic file copy/move on backup/restore.<br>- Updates backup metadata after backup or restore.<br>- Initiates restore confirmation dialog via UI.<br>- Handles errors and user feedback via dialogs.<br>- Reloads all stores from restored DB.<br>**Event Flows**:<br>- Triggered by background-fetch/task-manager schedule.<br>- On restore: triggered by SettingsMenu, then file picker and confirmation dialog.<br>- Handles concurrency flag in Zustand.<br>- Binds to file system events.<br>- Updates SecureStore post-operation.<br>**Data Ownership & Lifespan**:<br>Does not own app domain data; manages backup files and metadata, coordinates reload of all data stores after restore.<br>**External Dependencies & Integration**:<br>expo-file-system, expo-background-fetch, expo-task-manager, expo-secure-store, Zustand. |
| AdBanner | Conditionally renders persistent ad banner at bottom of app UI, hides when adsFreePurchased.<br>**System Boundaries & State Flow**- Reads adsFreePurchased status from SettingsStore.<br>- Renders/hides ad banner as per flag.<br>- Preserves layout with empty view if ad load fails.<br>- Subscribes to state for updates.<br>**Responsibilities & Interactions**:<br>- Integrates into App container or screen layouts.<br>- Handles ad load events/errors.<br>- Reactively updates on adsFreePurchased flag change.<br>- Maintains safe area layout.<br>**Event Flows**:<br>- Binds AdMob component events (onAdLoaded, onAdFailedToLoad).<br>- Subscribes to Zustand adsFreePurchased state.<br>- Renders/hides as per state.<br>**Data Ownership & Lifespan**:<br>Does not own persistent state; reads adsFreePurchased from SettingsStore.<br>**External Dependencies & Integration**:<br>AdMob/expo-ads-adapter, Zustand, React Native Paper. |
| SessionTimerValidator | - **[Offloading Class Names]**: TimerStateStore<br>- **[Originating Method Ids]**: TSS-1<br><br>**Delegate State Owned:**<br>- None (stateless, pure validation logic).<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulate all form and data validation logic for `SessionTimer` objects.<br>- Maintain up-to-date and isolated definitions of required validation rules, error keys, and error message strings.<br>- Generate a structured error map for use with UI helper components (e.g., `HelperText` in React Native Paper).<br><br>**Responsibilities Removed from Parent Class:**<br>- TimerStateStore no longer directly checks field-by-field validity or constructs error maps inline.<br>- TimerStateStore no longer needs to know the details of what constitutes a valid or invalid timer; it simply calls the validator and acts on the result.<br><br>**Delegate Public Interface:**<br>- `validate(timer: SessionTimer): { valid: boolean; errors: Record<string, string> }`<br><br>**Example Interaction:**<br>```typescript<br>// In TimerStateStore.saveSessionTimer:<br>const { valid, errors } = SessionTimerValidator.validate(timer);<br>if (!valid) {<br>  set({ validationError: errors });<br>  throw new TypeError('SessionTimer validation failed');<br>}<br>```<br><br>#### üîß Delegate Method: validate<br><br>Performs full validation of a `SessionTimer` object. Returns `{ valid, errors }` where `valid` is `false` if any errors are present, and `errors` is a map from field names to error messages. All business rules come from requirements (e.g., name required, unique, segment duration, etc).<br><br>```typescript<br>// SessionTimerValidator.ts<br>import { SessionTimer } from '../models/domain';<br><br>export class SessionTimerValidator {<br>  /**<br>   * Validates a SessionTimer object against all business rules.<br>   * Returns an object with a 'valid' boolean and an 'errors' map for consumption by the UI.<br>   * No internal state: this is a pure function.<br>   */<br>  static validate(timer: SessionTimer): { valid: boolean; errors: Record<string, string> } {<br>    const errors: Record<string, string> = {};<br><br>    // Name must be present and non-empty<br>    if (!timer.name or timer.name.trim().length === 0) {<br>      errors.name = 'Name is required.';<br>    }<br><br>    // Preparation time: integer >= 0<br>    if (<br>      typeof timer.preparationTime !== 'number' or<br>      timer.preparationTime < 0 or<br>      !Number.isInteger(timer.preparationTime)<br>    ) {<br>      errors.preparationTime = 'Preparation time must be an integer ‚â• 0.';<br>    }<br><br>    // Segmentation sound: must be present and have valid fields<br>    if (!timer.segmentationSound or typeof timer.segmentationSound !== 'object') {<br>      errors.segmentationSound = 'Segmentation sound config required.';<br>    } else {<br>      const seg = timer.segmentationSound;<br>      if (!seg.uri or seg.uri.trim().length === 0) {<br>        errors.segmentationSound_uri = 'Segmentation sound URI required.';<br>      }<br>      if (<br>        typeof seg.repetition !== 'number' or<br>        seg.repetition < 1 or<br>        seg.repetition > 3 or<br>        !Number.isInteger(seg.repetition)<br>      ) {<br>        errors.segmentationSound_repetition = 'Repetition: integer 1-3 required.';<br>      }<br>      if (<br>        typeof seg.volume !== 'number' or<br>        seg.volume < 0 or<br>        seg.volume > 5 or<br>        !Number.isInteger(seg.volume)<br>      ) {<br>        errors.segmentationSound_volume = 'Volume: integer 0-5 required.';<br>      }<br>    }<br><br>    // Meditation sound: must be present and have valid fields<br>    if (!timer.meditationSound or typeof timer.meditationSound !== 'object') {<br>      errors.meditationSound = 'Meditation sound config required.';<br>    } else {<br>      const med = timer.meditationSound;<br>      if (!med.uri or med.uri.trim().length === 0) {<br>        errors.meditationSound_uri = 'Meditation sound URI required.';<br>      }<br>      if (!['system', 'user_file'].includes(med.origin)) {<br>        errors.meditationSound_origin = 'Sound origin invalid.';<br>      }<br>      if (!['forever', 'count'].includes(med.repetitionType)) {<br>        errors.meditationSound_repetitionType = 'Repetition type invalid.';<br>      }<br>      if (<br>        med.repetitionType === 'count' &&<br>        (<br>          typeof med.repetitionCount !== 'number' or<br>          med.repetitionCount === undefined or<br>          med.repetitionCount < 1 or<br>          !Number.isInteger(med.repetitionCount)<br>        )<br>      ) {<br>        errors.meditationSound_repetitionCount = 'Repetition count required (>=1) for count type.';<br>      }<br>      if (<br>        typeof med.volume !== 'number' or<br>        med.volume < 0 or<br>        med.volume > 5 or<br>        !Number.isInteger(med.volume)<br>      ) {<br>        errors.meditationSound_volume = 'Volume: integer 0-5 required.';<br>      }<br>    }<br><br>    // Segments: 1-4, each with valid index/duration<br>    if (!Array.isArray(timer.segments)) {<br>      errors.segments = 'Segments array required.';<br>    } else {<br>      if (timer.segments.length < 1 or timer.segments.length > 4) {<br>        errors.segments_count = '1-4 segments required.';<br>      }<br>      timer.segments.forEach((seg, i) => {<br>        if (<br>          typeof seg.index !== 'number' or<br>          seg.index < 0 or<br>          !Number.isInteger(seg.index)<br>        ) {<br>          errors[`segment_${i}_index`] = `Segment #${i + 1}: Index must be integer ‚â• 0.`;<br>        }<br>        if (<br>          typeof seg.duration !== 'number' or<br>          seg.duration < 1 or<br>          !Number.isInteger(seg.duration)<br>        ) {<br>          errors[`segment_${i}_duration`] = `Segment #${i + 1}: Duration must be integer ‚â• 1.`;<br>        }<br>      });<br>    }<br><br>    // Daily reminder enabled: must have valid time string "HH:mm"<br>    if (typeof timer.dailyReminderEnabled !== 'boolean') {<br>      errors.dailyReminderEnabled = 'Daily reminder flag required.';<br>    }<br>    if (timer.dailyReminderEnabled) {<br>      if (!timer.reminderTime or !timer.reminderTime.match(/^([01][0-9]or2[0-3]):([0-5][0-9])$/)) {<br>        errors.reminderTime = 'Reminder time required ("HH:mm" 24h format) when reminder is enabled.';<br>      }<br>    }<br><br>    // Enable Diary Note flag<br>    if (typeof timer.enableDiaryNote !== 'boolean') {<br>      errors.enableDiaryNote = 'Enable Diary Note flag required.';<br>    }<br><br>    return {<br>      valid: Object.keys(errors).length === 0,<br>      errors,<br>    };<br>  }<br>}<br>```<br><br>#### üîÅ Refactored Method: TimerStateStore.saveSessionTimer<br><br>**Breakdown of responsibilities after refactoring:**<br>- TimerStateStore no longer implements validation logic directly.<br>- It now calls the delegate's `validate()` method and acts only on its result.<br>- All reasons for invalid input are now managed and updated exclusively by the delegate.<br><br>**How the delegate is called:**<br>```typescript<br>import { SessionTimerValidator } from '../validation/SessionTimerValidator';<br><br>// ...<br><br>saveSessionTimer: async (timer: SessionTimer): Promise<void> => {<br>  // Use delegate for validation<br>  const { valid, errors } = SessionTimerValidator.validate(timer);<br>  set({ validationError: valid ? null : errors });<br>  if (!valid) {<br>    throw new TypeError('SessionTimer validation failed');<br>  }<br><br>  // ...proceed with name uniqueness check, DB upsert, etc...<br>}<br>```<br><br>--- |
| SessionTimerRepoAdapter | - **[Offloading Class Names]**: TimerStateStore<br>- **[Originating Method Ids]**: TSS-1, TSS-2, TSS-4<br><br>**Delegate State Owned:**<br>- Internal reference to expo-sqlite database connection.<br>- No persistent in-memory state; all state is transient per request.<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulate all SQLite access and CRUD logic for the `SessionTimer` entity.<br>- Provide atomic, transaction-safe methods for insert, update, delete, and get operations.<br>- Handle all serialization/deserialization between `SessionTimer` domain objects and SQLite row format.<br><br>**Responsibilities Removed from Parent Class:**<br>- TimerStateStore no longer performs any direct SQL queries or raw data conversion.<br>- All SQL code, field parsing, and error mapping is handled by the delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>interface ISessionTimerRepository {<br>  save(timer: SessionTimer): Promise<void>;<br>  delete(timerId: string): Promise<void>;<br>  getById(timerId: string): Promise<SessionTimer or null>;<br>  getAll(): Promise<SessionTimer[]>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In TimerStateStore:<br>const repo = get().sessionTimerRepo;<br>await repo.save(timer); // Insert or update<br>const loaded = await repo.getById(timerId);<br>```<br><br>#### üîß Delegate Method: save<br><br>Responsible for inserting or updating a `SessionTimer` in SQLite, including serializing the segments and sound configs. Handles DB errors by throwing; leaves error handling to caller.<br><br>```typescript<br>export class SessionTimerRepoAdapter implements ISessionTimerRepository {<br>  private db: SQLite.WebSQLDatabase;<br><br>  constructor(db: SQLite.WebSQLDatabase) {<br>    this.db = db;<br>  }<br><br>  async save(timer: SessionTimer): Promise<void> {<br>    return new Promise<void>((resolve, reject) => {<br>      const sql = `<br>        INSERT OR REPLACE INTO SessionTimers (<br>          id,<br>          name,<br>          preparationTime,<br>          segmentationSound,<br>          meditationSound,<br>          segments,<br>          dailyReminderEnabled,<br>          reminderTime,<br>          enableDiaryNote<br>        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)<br>      `;<br>      const params = [<br>        timer.id,<br>        timer.name,<br>        timer.preparationTime,<br>        JSON.stringify(timer.segmentationSound),<br>        JSON.stringify(timer.meditationSound),<br>        JSON.stringify(timer.segments),<br>        timer.dailyReminderEnabled ? 1 : 0,<br>        timer.reminderTime or null,<br>        timer.enableDiaryNote ? 1 : 0<br>      ];<br>      this.db.transaction(tx => {<br>        tx.executeSql(<br>          sql,<br>          params,<br>          () => resolve(),<br>          (_, err) => {<br>            reject(err);<br>            return false;<br>          }<br>        );<br>      });<br>    });<br>  }<br><br>  // ...other CRUD methods...<br>}<br>```<br><br>#### üîÅ Refactored Method: TimerStateStore.saveSessionTimer<br><br>**Breakdown of responsibilities after refactoring:**<br>- TimerStateStore now delegates all DB persistence to the repository delegate.<br>- It calls only a high-level `save()` API, passing the fully validated domain object.<br><br>**How the delegate is called:**<br>```typescript<br>const repo = get().sessionTimerRepo;<br>await repo.save(timer);<br>// All errors are propagated to the caller, to be handled as mutationError state or thrown.<br>```<br><br>#### üîß Delegate Method: getById<br><br>Responsible for loading and deserializing a SessionTimer from SQLite by ID.<br><br>```typescript<br>async getById(timerId: string): Promise<SessionTimer or null> {<br>  return new Promise((resolve, reject) => {<br>    const sql = 'SELECT * FROM SessionTimers WHERE id = ?';<br>    this.db.readTransaction(tx => {<br>      tx.executeSql(<br>        sql,<br>        [timerId],<br>        (_, result) => {<br>          if (result.rows.length > 0) {<br>            const row = result.rows.item(0);<br>            resolve({<br>              id: row.id,<br>              name: row.name,<br>              preparationTime: row.preparationTime,<br>              segmentationSound: JSON.parse(row.segmentationSound),<br>              meditationSound: JSON.parse(row.meditationSound),<br>              segments: JSON.parse(row.segments),<br>              dailyReminderEnabled: !!row.dailyReminderEnabled,<br>              reminderTime: row.reminderTime,<br>              enableDiaryNote: !!row.enableDiaryNote<br>            });<br>          } else {<br>            resolve(null);<br>          }<br>        },<br>        (_, err) => {<br>          reject(err);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br>}<br>```<br><br>#### üîß Delegate Method: getAll<br><br>Loads all SessionTimers, parsing all fields.<br><br>```typescript<br>async getAll(): Promise<SessionTimer[]> {<br>  return new Promise((resolve, reject) => {<br>    const sql = 'SELECT * FROM SessionTimers';<br>    this.db.readTransaction(tx => {<br>      tx.executeSql(<br>        sql,<br>        [],<br>        (_, result) => {<br>          const timers: SessionTimer[] = [];<br>          for (let i = 0; i < result.rows.length; i++) {<br>            const row = result.rows.item(i);<br>            timers.push({<br>              id: row.id,<br>              name: row.name,<br>              preparationTime: row.preparationTime,<br>              segmentationSound: JSON.parse(row.segmentationSound),<br>              meditationSound: JSON.parse(row.meditationSound),<br>              segments: JSON.parse(row.segments),<br>              dailyReminderEnabled: !!row.dailyReminderEnabled,<br>              reminderTime: row.reminderTime,<br>              enableDiaryNote: !!row.enableDiaryNote<br>            });<br>          }<br>          resolve(timers);<br>        },<br>        (_, err) => {<br>          reject(err);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br>}<br>```<br><br>#### üîß Delegate Method: delete<br><br>Deletes a SessionTimer by ID atomically.<br><br>```typescript<br>async delete(timerId: string): Promise<void> {<br>  return new Promise((resolve, reject) => {<br>    const sql = 'DELETE FROM SessionTimers WHERE id = ?';<br>    this.db.transaction(tx => {<br>      tx.executeSql(<br>        sql,<br>        [timerId],<br>        () => resolve(),<br>        (_, err) => {<br>          reject(err);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Methods:<br><br>**TimerStateStore.deleteSessionTimer**<br>- Now calls only `repo.delete(timerId)` and relies on the delegate for error propagation and consistency.<br><br>**TimerStateStore.loadSessionTimer**<br>- Calls `repo.getById(timerId)` and expects a fully parsed domain object or null.<br><br>**TimerStateStore.hydrateTimersFromDB**<br>- Calls `repo.getAll()` and updates Zustand with the resulting array.<br><br>--- |
| SessionTimerReminderCoordinator | - **[Offloading Class Names]**: TimerStateStore<br>- **[Originating Method Ids]**: TSS-1, TSS-2<br><br>**Delegate State Owned:**<br>- Holds no persistent state; stateless coordinator for notification/reminder integration, but may depend on an INotificationManager instance.<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulates all logic for scheduling, updating, or cancelling reminders/notifications associated with a SessionTimer.<br>- Maps SessionTimer domain data to the notification/reminder API shape.<br>- Ensures required side effects (e.g., cancellation of reminders on delete) are always performed in the correct order.<br><br>**Responsibilities Removed from Parent Class:**<br>- TimerStateStore no longer directly invokes notification manager methods or knows how to map SessionTimer data into notification/reminder shapes.<br>- Parent class no longer knows detail of which notification API to call for a given SessionTimer operation.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SessionTimerReminderCoordinator {<br>  constructor(notificationManager: INotificationManager);<br>  syncRemindersForSave(timer: SessionTimer): Promise<void>;<br>  clearRemindersForDelete(timerId: string): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// After saving timer:<br>await reminderCoordinator.syncRemindersForSave(timer);<br><br>// Before deleting timer:<br>await reminderCoordinator.clearRemindersForDelete(timerId);<br>```<br><br>#### üîß Delegate Method: syncRemindersForSave<br><br>Schedules or cancels reminders as appropriate, depending on the timer data.<br><br>```typescript<br>class SessionTimerReminderCoordinator {<br>  private notificationManager: INotificationManager;<br><br>  constructor(notificationManager: INotificationManager) {<br>    this.notificationManager = notificationManager;<br>  }<br><br>  /**<br>   * Schedules or updates a reminder after a timer is saved.<br>   * If dailyReminderEnabled is true, schedules or updates; else cancels any existing.<br>   */<br>  async syncRemindersForSave(timer: SessionTimer): Promise<void> {<br>    if (timer.dailyReminderEnabled && timer.reminderTime) {<br>      await this.notificationManager.scheduleOrUpdateReminder(timer.id, {<br>        id: timer.id,<br>        frequency: 'daily',<br>        time: timer.reminderTime,<br>        sessionTimerId: timer.id,<br>        enabled: true,<br>      });<br>    } else {<br>      await this.notificationManager.cancelReminder(timer.id);<br>    }<br>  }<br>}<br>```<br><br>#### üîß Delegate Method: clearRemindersForDelete<br><br>Ensures all reminders for a timer are cancelled before deletion.<br><br>```typescript<br>  /**<br>   * Cancels all reminders for a timer prior to deletion.<br>   */<br>  async clearRemindersForDelete(timerId: string): Promise<void> {<br>    await this.notificationManager.cancelAllRemindersForTimer(timerId);<br>  }<br>}<br>```<br><br>#### üîÅ Refactored Methods:<br><br>**TimerStateStore.saveSessionTimer**<br>- After successful DB save:<br>  ```typescript<br>  await reminderCoordinator.syncRemindersForSave(timer);<br>  ```<br><br>**TimerStateStore.deleteSessionTimer**<br>- Before deleting from DB:<br>  ```typescript<br>  await reminderCoordinator.clearRemindersForDelete(timerId);<br>  ```<br><br>--- |
| SessionTimerDraftManager | - **[Offloading Class Names]**: TimerStateStore<br>- **[Originating Method Ids]**: TSS-3<br><br>**Delegate State Owned:**<br>- None (stateless, operates on provided state and returns updated draft state).<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulates logic for resetting the in-progress draft SessionTimer state, either to initial blank or to last-persisted values.<br>- Knows contract for what fields must be cleared or restored for a form discard/cancel event.<br><br>**Responsibilities Removed from Parent Class:**<br>- TimerStateStore no longer directly manages how to clear or restore the draft; just calls the delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SessionTimerDraftManager {<br>  static resetDraft(existingTimer?: SessionTimer): SessionTimer or null;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const draft = SessionTimerDraftManager.resetDraft(lastPersisted);<br>// set({ draftSessionTimer: draft, validationError: null });<br>```<br><br>#### üîß Delegate Method: resetDraft<br><br>Returns a cleared or restored draft timer value.<br><br>```typescript<br>class SessionTimerDraftManager {<br>  /**<br>   * Returns a clean draft (null or clone of last-persisted timer) for use after cancel/discard.<br>   * If existingTimer is provided, returns a shallow clone; otherwise, returns null.<br>   */<br>  static resetDraft(existingTimer?: SessionTimer): SessionTimer or null {<br>    if (existingTimer) {<br>      // Shallow clone to break references<br>      return { ...existingTimer };<br>    }<br>    return null;<br>  }<br>}<br>```<br><br>#### üîÅ Refactored Method: TimerStateStore.resetDraftSessionTimer<br><br>**Breakdown of responsibilities after refactoring:**<br>- No longer contains logic for deciding how to reset the draft.<br>- Calls delegate and updates state only.<br><br>**How the delegate is called:**<br>```typescript<br>const state = get();<br>const lastPersisted = state.sessionTimers.find(t => t.id === state.draftSessionTimer?.id);<br>// If found, restore; else clear<br>const draft = SessionTimerDraftManager.resetDraft(lastPersisted);<br>set({ draftSessionTimer: draft, validationError: null });<br>```<br><br>--- |
| TimerStateStoreFormErrorHelper | - **[Offloading Class Names]**: TimerStateStore<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless utility).<br><br>**Delegate Responsibilities Owned:**<br>- Generates localized, formatted error messages for UI display (e.g., Paper `<HelperText>`).<br>- Maps error keys from validation/errors to friendly message strings, possibly with i18n support.<br><br>**Responsibilities Removed from Parent Class:**<br>- TimerStateStore no longer hard-codes error string mapping or formatting logic.<br><br>**Delegate Public Interface:**<br>```typescript<br>class TimerStateStoreFormErrorHelper {<br>  static getErrorMessage(errorKey: string, errors: Record<string, string>, i18n: (k: string) => string): string;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br><HelperText type="error" visible={!!validationError?.name}><br>  {TimerStateStoreFormErrorHelper.getErrorMessage('name', validationError, t)}<br></HelperText><br>```<br><br>---<br><br>End of report. |
| SessionTimerFormLayout | - **[Offloading Class Names]**: SessionTimerForm<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless functional component, receives all necessary state and handlers via props).<br><br>**Delegate Responsibilities Owned:**<br>- Renders the complete UI layout for the Session Timer form, including:<br>  - Title bar, all fields, pickers, sliders, buttons, and feedback elements.<br>  - Maps errors and disabled state to proper Paper UI elements.<br>  - Presents helper texts and error messages.<br>  - Triggers all passed event handlers upon user interaction.<br>  - Handles conditional visibility of fields (e.g., segments, reminders).<br><br>**Responsibilities Removed from Parent Class:**<br>- All JSX/UI rendering logic and composition of the form fields, dialog elements, and control layout.<br>- Rendering of inline error helpers, disabling of form elements, and display of dynamic field sets.<br><br>**Delegate Public Interface:**<br>```typescript<br>type SessionTimerFormLayoutProps = {<br>  localForm: SessionTimer;<br>  localValidation: Record<string, string>;<br>  isEditMode: boolean;<br>  isLoading: boolean;<br>  title: string;<br>  deleteDialogVisible: boolean;<br>  unsavedDialogVisible: boolean;<br>  errorDialog: string or null;<br>  reminderTimePickerVisible: boolean;<br>  snackbar: string or null;<br>  // All event handlers below:<br>  onNameChange(value: string): void;<br>  onPreparationTimeChange(value: string): void;<br>  onSegmentationSoundPress(): void;<br>  onSegmentationRepeatChange(value: string or number): void;<br>  onSegmentationVolumeChange(value: number): void;<br>  onMeditationSoundSourceChange(value: SoundOrigin): void;<br>  onMeditationSoundSelectorPress(): void;<br>  onMeditationRepeatTypeChange(value: 'forever' or 'count'): void;<br>  onMeditationRepeatCountChange(value: string or number): void;<br>  onMeditationVolumeChange(value: number): void;<br>  onAddSegmentPress(): void;<br>  onSegmentDurationChange(idx: number, value: string): void;<br>  onRemoveSegmentPress(idx: number): void;<br>  onDailyReminderToggle(value: boolean): void;<br>  onReminderTimeChange(_event: any, selectedTime: Date or undefined): void;<br>  onEnableDiaryToggle(value: boolean): void;<br>  onBackPress(): void;<br>  onCancelPress(): void;<br>  onDeletePress(): void;<br>  onDeleteCancel(): void;<br>  onDeleteConfirm(): void;<br>  onUnsavedChangesSave(): void;<br>  onUnsavedChangesDiscard(): void;<br>  onSavePress(): void;<br>  onSnackbarDismiss(): void;<br>  onErrorDialogDismiss(): void;<br>  setReminderTimePickerVisible(value: boolean): void;<br>};<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In SessionTimerForm render:<br>return (<br>  <SessionTimerFormLayout<br>    localForm={localForm}<br>    localValidation={localValidation}<br>    isEditMode={isEditMode}<br>    isLoading={isLoading}<br>    title={title}<br>    deleteDialogVisible={deleteDialogVisible}<br>    unsavedDialogVisible={unsavedDialogVisible}<br>    errorDialog={errorDialog}<br>    reminderTimePickerVisible={reminderTimePickerVisible}<br>    snackbar={snackbar}<br>    // ...all bound event handlers<br>    onNameChange={handleNameChange}<br>    // ...etc<br>  /><br>);<br>```<br><br>#### üîß Delegate Method: `SessionTimerFormLayout` (Stateless Functional Component)<br>**Responsibilities:**<br>- Receives all UI state, event handlers, and data as props.<br>- Renders all form fields, error helpers, dialogs, snackbars, and field groups according to props.<br>- All field state, validation, and UI enablement/disablement logic is mapped from props, making this component pure and focused on layout.<br><br>```typescript<br>export const SessionTimerFormLayout: React.FC<SessionTimerFormLayoutProps> = (props) => {<br>  const {<br>    localForm,<br>    localValidation,<br>    isEditMode,<br>    isLoading,<br>    title,<br>    deleteDialogVisible,<br>    unsavedDialogVisible,<br>    errorDialog,<br>    reminderTimePickerVisible,<br>    snackbar,<br>    // ...all event handlers as named above<br>    onNameChange,<br>    onPreparationTimeChange,<br>    onSegmentationSoundPress,<br>    onSegmentationRepeatChange,<br>    onSegmentationVolumeChange,<br>    onMeditationSoundSourceChange,<br>    onMeditationSoundSelectorPress,<br>    onMeditationRepeatTypeChange,<br>    onMeditationRepeatCountChange,<br>    onMeditationVolumeChange,<br>    onAddSegmentPress,<br>    onSegmentDurationChange,<br>    onRemoveSegmentPress,<br>    onDailyReminderToggle,<br>    onReminderTimeChange,<br>    onEnableDiaryToggle,<br>    onBackPress,<br>    onCancelPress,<br>    onDeletePress,<br>    onDeleteCancel,<br>    onDeleteConfirm,<br>    onUnsavedChangesSave,<br>    onUnsavedChangesDiscard,<br>    onSavePress,<br>    onSnackbarDismiss,<br>    onErrorDialogDismiss,<br>    setReminderTimePickerVisible,<br>  } = props;<br><br>  // UI field enablement: Save enabled only if valid, not loading, no errors<br>  const saveDisabled =<br>    isLoading or<br>    (localForm<br>      ? Object.keys(localValidation).length > 0 or<br>        !localForm.name or<br>        localForm.segments.length === 0<br>      : true);<br><br>  // ...UI rendering (move all JSX from parent here, as in the original file draft)...<br>  // [See original file draft for full JSX body.]<br>  // All props are mapped directly to fields and controls; all onChange/presses call the passed handler.<br><br>  return (<br>    <KeyboardAvoidingView style={{ flex: 1 }} behavior={Platform.select({ ios: 'padding', android: undefined })}><br>      <Portal><br>        {/* Delete Confirmation Dialog */}<br>        <Dialog visible={deleteDialogVisible} onDismiss={onDeleteCancel}><br>          <Dialog.Title>Delete Session Timer</Dialog.Title><br>          <Dialog.Content><br>            <Paragraph><br>              Are you sure you want to delete this Session Timer? This action cannot be undone.<br>            </Paragraph><br>          </Dialog.Content><br>          <Dialog.Actions><br>            <Button onPress={onDeleteCancel}>Cancel</Button><br>            <Button onPress={onDeleteConfirm} loading={isLoading} disabled={isLoading} color="red"><br>              Delete<br>            </Button><br>          </Dialog.Actions><br>        </Dialog><br>        {/* Unsaved Changes Dialog */}<br>        <Dialog visible={unsavedDialogVisible} onDismiss={onUnsavedChangesDiscard}><br>          <Dialog.Title>Unsaved Changes</Dialog.Title><br>          <Dialog.Content><br>            <Paragraph>Do you want to save your changes before leaving?</Paragraph><br>          </Dialog.Content><br>          <Dialog.Actions><br>            <Button onPress={onUnsavedChangesDiscard}>Discard</Button><br>            <Button onPress={onUnsavedChangesSave}>Save</Button><br>          </Dialog.Actions><br>        </Dialog><br>        {/* Error Dialog */}<br>        <Dialog visible={!!errorDialog} onDismiss={onErrorDialogDismiss}><br>          <Dialog.Title>Error</Dialog.Title><br>          <Dialog.Content><br>            <Paragraph>{errorDialog}</Paragraph><br>          </Dialog.Content><br>          <Dialog.Actions><br>            <Button onPress={onErrorDialogDismiss}>OK</Button><br>          </Dialog.Actions><br>        </Dialog><br>      </Portal><br>      <ScrollView keyboardShouldPersistTaps="handled" contentContainerStyle={styles.container}><br>        {/* Title Bar */}<br>        <View style={styles.headerRow}><br>          <IconButton icon="arrow-left" onPress={onBackPress} accessibilityLabel="Back" /><br>          <Title style={{ flex: 1, textAlign: 'center' }}>{title}</Title><br>          {isEditMode && (<br>            <IconButton<br>              icon="delete"<br>              onPress={onDeletePress}<br>              accessibilityLabel="Delete"<br>              color="red"<br>            /><br>          )}<br>        </View><br>        <Divider style={{ marginBottom: 8 }} /><br>        {/* Name */}<br>        <TextInput<br>          label="Name"<br>          value={localForm.name}<br>          onChangeText={onNameChange}<br>          error={!!localValidation.name}<br>          mode="outlined"<br>          style={styles.input}<br>          accessibilityLabel="Session Timer Name"<br>          disabled={isLoading}<br>        /><br>        <HelperText type="error" visible={!!localValidation.name}><br>          {localValidation.name}<br>        </HelperText><br>        {/* Preparation Time */}<br>        <TextInput<br>          label="Preparation Time (seconds)"<br>          value={localForm.preparationTime.toString()}<br>          onChangeText={onPreparationTimeChange}<br>          keyboardType="numeric"<br>          error={!!localValidation.preparationTime}<br>          mode="outlined"<br>          style={styles.input}<br>          accessibilityLabel="Preparation Time"<br>          disabled={isLoading}<br>        /><br>        <HelperText type="error" visible={!!localValidation.preparationTime}><br>          {localValidation.preparationTime}<br>        </HelperText><br>        {/* Segmentation Sound */}<br>        <Subheading>Segmentation Sound</Subheading><br>        <View style={styles.inlineRow}><br>          <Button mode="outlined" onPress={onSegmentationSoundPress} disabled={isLoading}><br>            {localForm.segmentationSound.uri ? 'Change Sound' : 'Pick Sound'}<br>          </Button><br>          <TextInput<br>            label="Repetition (1-3)"<br>            value={localForm.segmentationSound.repetition.toString()}<br>            onChangeText={v => onSegmentationRepeatChange(v)}<br>            keyboardType="numeric"<br>            style={[styles.input, { flex: 1, marginLeft: 8 }]}<br>            error={!!localValidation.segmentationSound_repetition}<br>            disabled={isLoading}<br>          /><br>          <TextInput<br>            label="Volume (0-5)"<br>            value={localForm.segmentationSound.volume.toString()}<br>            onChangeText={v => onSegmentationVolumeChange(parseInt(v or '0', 10))}<br>            keyboardType="numeric"<br>            style={[styles.input, { flex: 1, marginLeft: 8 }]}<br>            error={!!localValidation.segmentationSound_volume}<br>            disabled={isLoading}<br>          /><br>        </View><br>        <HelperText type="error" visible={!!localValidation.segmentationSound_uri}><br>          {localValidation.segmentationSound_uri}<br>        </HelperText><br>        <HelperText type="error" visible={!!localValidation.segmentationSound_repetition}><br>          {localValidation.segmentationSound_repetition}<br>        </HelperText><br>        <HelperText type="error" visible={!!localValidation.segmentationSound_volume}><br>          {localValidation.segmentationSound_volume}<br>        </HelperText><br>        {/* Meditation Sound */}<br>        <Subheading>Meditation Sound</Subheading><br>        <View style={styles.inlineRow}><br>          <RadioButton.Group<br>            onValueChange={onMeditationSoundSourceChange}<br>            value={localForm.meditationSound.origin}<br>          ><br>            <View style={{ flexDirection: 'row', alignItems: 'center' }}><br>              <RadioButton value="system" /><br>              <Paragraph>System Sound</Paragraph><br>              <RadioButton value="user_file" /><br>              <Paragraph>User File</Paragraph><br>            </View><br>          </RadioButton.Group><br>        </View><br>        <Button<br>          mode="outlined"<br>          onPress={onMeditationSoundSelectorPress}<br>          disabled={isLoading}<br>          style={{ marginBottom: 8 }}<br>        ><br>          {localForm.meditationSound.uri ? 'Change Sound' : 'Pick Sound'}<br>        </Button><br>        <View style={styles.inlineRow}><br>          <RadioButton.Group<br>            onValueChange={onMeditationRepeatTypeChange}<br>            value={localForm.meditationSound.repetitionType}<br>          ><br>            <View style={{ flexDirection: 'row', alignItems: 'center' }}><br>              <RadioButton value="forever" /><br>              <Paragraph>Forever</Paragraph><br>              <RadioButton value="count" /><br>              <Paragraph>Count</Paragraph><br>            </View><br>          </RadioButton.Group><br>        </View><br>        {localForm.meditationSound.repetitionType === 'count' && (<br>          <TextInput<br>            label="Repeat Count"<br>            value={localForm.meditationSound.repetitionCount?.toString() or ''}<br>            onChangeText={v => onMeditationRepeatCountChange(v)}<br>            keyboardType="numeric"<br>            style={styles.input}<br>            error={!!localValidation.meditationSound_repetitionCount}<br>            disabled={isLoading}<br>          /><br>        )}<br>        <TextInput<br>          label="Volume (0-5)"<br>          value={localForm.meditationSound.volume.toString()}<br>          onChangeText={v => onMeditationVolumeChange(parseInt(v or '0', 10))}<br>          keyboardType="numeric"<br>          style={styles.input}<br>          error={!!localValidation.meditationSound_volume}<br>          disabled={isLoading}<br>        /><br>        <HelperText type="error" visible={!!localValidation.meditationSound_uri}><br>          {localValidation.meditationSound_uri}<br>        </HelperText><br>        <HelperText type="error" visible={!!localValidation.meditationSound_origin}><br>          {localValidation.meditationSound_origin}<br>        </HelperText><br>        <HelperText type="error" visible={!!localValidation.meditationSound_repetitionType}><br>          {localValidation.meditationSound_repetitionType}<br>        </HelperText><br>        <HelperText type="error" visible={!!localValidation.meditationSound_repetitionCount}><br>          {localValidation.meditationSound_repetitionCount}<br>        </HelperText><br>        <HelperText type="error" visible={!!localValidation.meditationSound_volume}><br>          {localValidation.meditationSound_volume}<br>        </HelperText><br>        {/* Segments */}<br>        <Subheading>Session Segments</Subheading><br>        {localForm.segments.map((seg, i) => (<br>          <Card key={i} style={styles.segmentCard}><br>            <Card.Content style={{ flexDirection: 'row', alignItems: 'center' }}><br>              <TextInput<br>                label={`Segment ${i + 1} Duration (s)`}<br>                value={seg.duration.toString()}<br>                onChangeText={v => onSegmentDurationChange(i, v)}<br>                keyboardType="numeric"<br>                style={[styles.input, { flex: 1 }]}<br>                error={!!localValidation[`segment_${i}_duration`]}<br>                disabled={isLoading}<br>              /><br>              {localForm.segments.length > 1 && (<br>                <IconButton<br>                  icon="close"<br>                  color="red"<br>                  onPress={() => onRemoveSegmentPress(i)}<br>                  accessibilityLabel={`Remove Segment ${i + 1}`}<br>                  disabled={isLoading}<br>                /><br>              )}<br>            </Card.Content><br>            <HelperText type="error" visible={!!localValidation[`segment_${i}_duration`]}><br>              {localValidation[`segment_${i}_duration`]}<br>            </HelperText><br>          </Card><br>        ))}<br>        <Button<br>          mode="outlined"<br>          onPress={onAddSegmentPress}<br>          disabled={localForm.segments.length >= 4 or isLoading}<br>          icon="plus"<br>          style={{ marginBottom: 12 }}<br>        ><br>          Add Segment<br>        </Button><br>        <HelperText type="error" visible={!!localValidation.segments_count}><br>          {localValidation.segments_count}<br>        </HelperText><br>        {/* Daily Reminder */}<br>        <View style={styles.inlineRow}><br>          <Paragraph>Enable Daily Reminder</Paragraph><br>          <Switch<br>            value={!!localForm.dailyReminderEnabled}<br>            onValueChange={onDailyReminderToggle}<br>            disabled={isLoading}<br>          /><br>        </View><br>        {localForm.dailyReminderEnabled && (<br>          <View><br>            <Button<br>              mode="outlined"<br>              onPress={() => setReminderTimePickerVisible(true)}<br>              style={{ marginBottom: 8 }}<br>              disabled={isLoading}<br>            ><br>              {localForm.reminderTime ? `Reminder Time: ${localForm.reminderTime}` : 'Set Reminder Time'}<br>            </Button><br>            {reminderTimePickerVisible && (<br>              <DateTimePicker<br>                mode="time"<br>                value={<br>                  localForm.reminderTime<br>                    ? (() => {<br>                        const [h, m] = localForm.reminderTime!.split(':');<br>                        const date = new Date();<br>                        date.setHours(parseInt(h, 10), parseInt(m, 10));<br>                        return date;<br>                      })()<br>                    : new Date()<br>                }<br>                onChange={onReminderTimeChange}<br>                is24Hour={true}<br>              /><br>            )}<br>          </View><br>        )}<br>        <HelperText type="error" visible={!!localValidation.reminderTime}><br>          {localValidation.reminderTime}<br>        </HelperText><br>        {/* Enable Diary Note */}<br>        <View style={styles.inlineRow}><br>          <Paragraph>Enable Diary Note</Paragraph><br>          <Switch<br>            value={!!localForm.enableDiaryNote}<br>            onValueChange={onEnableDiaryToggle}<br>            disabled={isLoading}<br>          /><br>        </View><br>        {/* Save/Cancel */}<br>        <View style={styles.buttonRow}><br>          <Button<br>            mode="contained"<br>            onPress={onSavePress}<br>            disabled={saveDisabled}<br>            loading={isLoading}<br>            style={styles.button}<br>          ><br>            Save<br>          </Button><br>          <Button<br>            mode="outlined"<br>            onPress={onCancelPress}<br>            disabled={isLoading}<br>            style={styles.button}<br>          ><br>            Cancel<br>          </Button><br>        </View><br>        <Snackbar<br>          visible={!!snackbar}<br>          onDismiss={onSnackbarDismiss}<br>          duration={3000}<br>        ><br>          {snackbar}<br>        </Snackbar><br>      </ScrollView><br>    </KeyboardAvoidingView><br>  );<br>};<br>```<br>--- |
| SessionTimerFormPersistenceHelper | - **[Offloading Class Names]**: SessionTimerForm<br>- **[Originating Method Ids]**: STF-24, STF-20<br><br>**Delegate State Owned:**<br>- None (stateless utility delegate; persistence handled via passed store and manager references).<br><br>**Delegate Responsibilities Owned:**<br>- Orchestrates persistence and transactional flows for saving and deleting session timers, including:<br>  - Full coordination of DB insert/update/delete via store API.<br>  - Triggering of notification scheduling and cancellation after DB commits.<br>  - Validation of payloads before persistence.<br>  - Error isolation: ensures no partial state is committed on failure and surfaces errors for parent handling.<br><br>**Responsibilities Removed from Parent Class:**<br>- Handling of transactional persistence and notification coordination for save and delete flows.<br>- Ensuring all data is transformed, validated, and persisted atomically.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SessionTimerFormPersistenceHelper {<br>  saveAndSchedule(<br>    form: SessionTimer,<br>    saveSessionTimer: (t: SessionTimer) => Promise<void>,<br>    notificationManager: INotificationManager<br>  ): Promise<void>;<br><br>  deleteAndCancelReminders(<br>    timerId: string,<br>    deleteSessionTimer: (id: string) => Promise<void>,<br>    notificationManager: INotificationManager<br>  ): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In SessionTimerForm.handleSavePress<br>await persistenceHelper.saveAndSchedule(<br>  localForm,<br>  saveSessionTimer,<br>  notificationManager<br>);<br><br>// In SessionTimerForm.handleDeleteConfirm<br>await persistenceHelper.deleteAndCancelReminders(<br>  localForm.id,<br>  deleteSessionTimer,<br>  notificationManager<br>);<br>```<br><br>#### üîÅ Refactored Method: SessionTimerForm.handleSavePress<br>**Breakdown of responsibilities after refactoring:**<br>- The parent method is now responsible for:<br>  - Gathering the current form state.<br>  - Calling the delegate's `saveAndSchedule` method with form data and necessary dependencies.<br>  - Handling UI loading state and errors (delegate surfaces errors via rejected promise).<br>- The delegate is responsible for:<br>  - Validating all fields before persistence.<br>  - Saving the timer in the DB via the store.<br>  - Scheduling/updating/cancelling notifications after a successful DB commit.<br>  - Ensuring both persistence and notification are succeeded; on any error, no partial state is left.<br>  - Throwing errors for parent to handle.<br><br>**Usage Example:**<br>```typescript<br>// In SessionTimerForm.handleSavePress:<br>setIsLoading(true);<br>try {<br>  await persistenceHelper.saveAndSchedule(<br>    localForm,<br>    saveSessionTimer,<br>    notificationManager<br>  );<br>  navigation.goBack();<br>} catch (err: any) {<br>  setErrorDialog(err.message or 'Failed to save Session Timer.');<br>} finally {<br>  setIsLoading(false);<br>}<br>```<br><br>#### üîß Delegate Method: saveAndSchedule<br>**Responsibilities:**<br>- Validates `form` using production validation logic (as in file draft).<br>- Calls `saveSessionTimer(form)` to persist to SQLite and update Zustand.<br>- If daily reminder is enabled, schedules or updates the reminder using the notification manager; otherwise, cancels any existing reminder for this timer.<br>- All notification actions are performed only after a successful DB commit.<br>- Any error (in validation, persistence, or notification) throws for parent to handle.<br>- Rollback is not needed as DB and notification scheduling are ordered; if notification fails after DB, parent is alerted.<br><br>```typescript<br>async saveAndSchedule(<br>  form: SessionTimer,<br>  saveSessionTimer: (t: SessionTimer) => Promise<void>,<br>  notificationManager: INotificationManager<br>): Promise<void> {<br>  // Validate form (reuse validation logic as in file draft)<br>  const { valid, errors } = validateSessionForm(form);<br>  if (!valid) {<br>    throw new Error('Validation failed: ' + Object.values(errors).join(' '));<br>  }<br>  // Save to DB<br>  await saveSessionTimer(form);<br>  // Schedule/cancel notifications after DB commit<br>  if (form.dailyReminderEnabled && form.reminderTime) {<br>    await notificationManager.scheduleOrUpdateReminder(form.id, {<br>      time: form.reminderTime,<br>      timerName: form.name,<br>    });<br>  } else {<br>    await notificationManager.cancelReminder(form.id);<br>  }<br>}<br>```<br><br>#### üîÅ Refactored Method: SessionTimerForm.handleDeleteConfirm<br>**Breakdown of responsibilities after refactoring:**<br>- Parent method sets loading state, calls delegate's `deleteAndCancelReminders` with the timer ID and action dependencies, then closes dialogs or handles errors.<br>- The delegate is responsible for:<br>  - Canceling all reminders associated with the timer.<br>  - Deleting the timer in the DB (store).<br>  - Ensuring the operations are performed in sequence and errors are surfaced.<br><br>**Usage Example:**<br>```typescript<br>setIsLoading(true);<br>try {<br>  await persistenceHelper.deleteAndCancelReminders(<br>    localForm.id,<br>    deleteSessionTimer,<br>    notificationManager<br>  );<br>  setDeleteDialogVisible(false);<br>  navigation.goBack();<br>} catch (err: any) {<br>  setErrorDialog(err.message or 'Failed to delete Session Timer.');<br>} finally {<br>  setIsLoading(false);<br>}<br>```<br><br>#### üîß Delegate Method: deleteAndCancelReminders<br>**Responsibilities:**<br>- Calls the notification manager to cancel all reminders for the given timer ID and deletes notifications records if required.<br>- Calls the store's `deleteSessionTimer` to remove the timer from both DB and Zustand.<br>- Operations are performed in order and any error is thrown for parent handling.<br><br>```typescript<br>async deleteAndCancelReminders(<br>  timerId: string,<br>  deleteSessionTimer: (id: string) => Promise<void>,<br>  notificationManager: INotificationManager<br>): Promise<void> {<br>  await notificationManager.cancelAllRemindersForTimer(timerId);<br>  await deleteSessionTimer(timerId);<br>}<br>```<br>--- |
| SessionTimerFormFilePickerHelper | - **[Offloading Class Names]**: SessionTimerForm<br>- **[Originating Method Ids]**: STF-3, STF-7, STF-25, STF-26, STF-27, STF-28<br><br>**Delegate State Owned:**<br>- None (utility class; only invokes Expo pickers and normalizes results).<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulates all logic for interacting with Expo's file and document pickers for sound/file selection.<br>- Handles result normalization and error/cancel flows.<br>- Calls back to parent-provided handlers with selected URIs or as cancellations.<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct usage of Expo pickers and result handling logic.<br>- File type configuration, result normalization, and branch selection for different file origins.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SessionTimerFormFilePickerHelper {<br>  pickSegmentationSound(onPicked: (selection: { uri: string }) => void, onCancel: () => void): Promise<void>;<br>  pickMeditationSound(origin: SoundOrigin, onPicked: (selection: { uri: string }) => void, onCancel: () => void): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In handleSegmentationSoundPress:<br>await filePickerHelper.pickSegmentationSound(handleSoundPicked, handleSoundPickerCancel);<br><br>// In handleMeditationSoundSelectorPress:<br>await filePickerHelper.pickMeditationSound(localForm.meditationSound.origin, handleSoundPicked, handleFilePickerCancel);<br>```<br><br>#### üîÅ Refactored Method: SessionTimerForm.handleSegmentationSoundPress and .handleMeditationSoundSelectorPress<br>**Breakdown of responsibilities after refactoring:**<br>- Parent method now only calls the delegate, passing handler methods for result/cancel.<br>- All picker result logic, type configuration, and callback branching is handled by delegate.<br>- Parent stays cleaner and focused on state management.<br><br>**Usage Example:**<br>```typescript<br>const filePickerHelper = new SessionTimerFormFilePickerHelper();<br>const handleSegmentationSoundPress = async () => {<br>  await filePickerHelper.pickSegmentationSound(handleSoundPicked, handleSoundPickerCancel);<br>};<br>const handleMeditationSoundSelectorPress = async () => {<br>  await filePickerHelper.pickMeditationSound(localForm.meditationSound.origin, handleSoundPicked, handleFilePickerCancel);<br>};<br>```<br><br>#### üîß Delegate Method: pickSegmentationSound<br>**Responsibilities:**<br>- Invokes Expo DocumentPicker for audio files.<br>- Calls onPicked with `{ uri }` if successful, onCancel otherwise.<br><br>```typescript<br>async pickSegmentationSound(<br>  onPicked: (selection: { uri: string }) => void,<br>  onCancel: () => void<br>): Promise<void> {<br>  const result = await DocumentPicker.getDocumentAsync({<br>    type: 'audio/*',<br>    copyToCacheDirectory: false,<br>    multiple: false,<br>  });<br>  if (result.type === 'success') {<br>    onPicked({ uri: result.uri });<br>  } else {<br>    onCancel();<br>  }<br>}<br>```<br><br>#### üîß Delegate Method: pickMeditationSound<br>**Responsibilities:**<br>- Invokes DocumentPicker for 'system' or 'user_file' origin.<br>- Calls onPicked with `{ uri }` on success, onCancel otherwise.<br><br>```typescript<br>async pickMeditationSound(<br>  origin: SoundOrigin,<br>  onPicked: (selection: { uri: string }) => void,<br>  onCancel: () => void<br>): Promise<void> {<br>  // For Expo Go, always use DocumentPicker for audio<br>  const result = await DocumentPicker.getDocumentAsync({<br>    type: 'audio/*',<br>    copyToCacheDirectory: false,<br>    multiple: false,<br>  });<br>  if (result.type === 'success') {<br>    onPicked({ uri: result.uri });<br>  } else {<br>    onCancel();<br>  }<br>}<br>```<br><br>---<br><br>End of report. |
| MainScreenAccessibilityHelper | - **[Offloading Class Names]**: MainScreen<br>- **[Originating Method Ids]**: MS-16<br><br>**Delegate State Owned:**<br>- None (stateless helper; no internal state)<br><br>**Delegate Responsibilities Owned:**<br>- Ensures that all interactive UI elements on the MainScreen are properly configured for accessibility.<br>- Provides descriptive, localizable accessibility labels for all controls.<br>- Applies accessibility props to supplied elements.<br>- Optionally, centralizes localization/formatting of labels if provided with an i18n instance.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer needs to manage accessibility logic inline or worry about label assignment or accessibility prop configuration.<br>- All a11y prop construction and assignment are handled by the delegate for consistency and DRYness.<br><br>**Delegate Public Interface:**<br>```typescript<br>class MainScreenAccessibilityHelper {<br>  static getAccessibilityProps(label: string): { accessible: true; accessibilityLabel: string };<br>  static applyAccessibilityToElement<P extends object>(<br>    element: React.ReactElement<P>,<br>    label: string<br>  ): React.ReactElement<P>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In MainScreen render:<br>import { MainScreenAccessibilityHelper } from '../delegates/MainScreenAccessibilityHelper';<br><br>// Apply to a Paper Button:<br><IconButton<br>  icon="calendar"<br>  onPress={handleCalendar}<br>  {...MainScreenAccessibilityHelper.getAccessibilityProps('Open Calendar')}<br>/><br>```<br><br>#### üîÅ Refactored Method: MainScreen.ensureAccessibilityProps<br><br>**Breakdown after refactoring:**<br>- The MainScreen no longer inlines an a11y function or applies accessibility props ad hoc.<br>- Instead, it relies on `MainScreenAccessibilityHelper` to provide accessibility label props.<br>- This keeps the MainScreen's render method clean and ensures a single point of truth for accessibility configuration.<br><br>**How the delegate is called:**<br>- In the MainScreen‚Äôs render JSX, wherever an accessible control is rendered, it calls `MainScreenAccessibilityHelper.getAccessibilityProps('label text')` and spreads the result into the JSX element‚Äôs props.<br><br>```typescript<br>// Before:<br><IconButton<br>  icon="calendar"<br>  onPress={handleCalendar}<br>  accessibilityLabel="Open Calendar"<br>  accessible={true}<br>/><br><br>// After:<br><IconButton<br>  icon="calendar"<br>  onPress={handleCalendar}<br>  {...MainScreenAccessibilityHelper.getAccessibilityProps('Open Calendar')}<br>/><br>```<br><br>#### üîß Delegate Method: getAccessibilityProps<br><br>**Responsibility:**  <br>Returns a standardized set of accessibility props for a given descriptive label. Ensures that all interactive Paper and RN components get the correct accessibility attributes, using the supplied label. If localization is needed, it can be injected here.<br><br>**Signature:**<br>```typescript<br>static getAccessibilityProps(label: string): { accessible: true; accessibilityLabel: string }<br>```<br><br>**Production Code Example:**<br>```typescript<br>export class MainScreenAccessibilityHelper {<br>  /**<br>   * Returns standardized accessibility props for an interactive element.<br>   * @param label - Descriptive, localizable label for screen readers.<br>   */<br>  static getAccessibilityProps(label: string): { accessible: true; accessibilityLabel: string } {<br>    // Optionally, inject i18n here for localization<br>    return {<br>      accessible: true,<br>      accessibilityLabel: label,<br>    };<br>  }<br><br>  /**<br>   * Optionally wraps an element with the proper accessibility props.<br>   * @param element - JSX element to enhance<br>   * @param label - Descriptive, localizable label<br>   */<br>  static applyAccessibilityToElement<P extends object>(<br>    element: React.ReactElement<P>,<br>    label: string<br>  ): React.ReactElement<P> {<br>    return React.cloneElement(element, MainScreenAccessibilityHelper.getAccessibilityProps(label));<br>  }<br>}<br>```<br><br>--- |
| MainScreenAdBannerRenderer | - **[Offloading Class Names]**: MainScreen<br>- **[Originating Method Ids]**: MS-2<br><br>**Delegate State Owned:**<br>- None (stateless; only conditional UI rendering)<br><br>**Delegate Responsibilities Owned:**<br>- Handles all logic for rendering or hiding the persistent Ad banner.<br>- Reads the `adsFreePurchased` flag from Zustand‚Äôs SettingsStore (or receives it via prop).<br>- Handles any ad events (onLoad, onError), passes up UI feedback if needed.<br>- Ensures ad banner never conflicts with layout, and exposes a single render function.<br><br>**Responsibilities Removed from Parent Class:**<br>- MainScreen no longer contains inline logic for AdBanner visibility, event binding, or layout adjustments for banner presence.<br><br>**Delegate Public Interface:**<br>```typescript<br>type MainScreenAdBannerRendererProps = {<br>  adsFreePurchased: boolean;<br>  onAdLoad?: () => void;<br>  onAdError?: (error: Error) => void;<br>};<br>function MainScreenAdBannerRenderer(props: MainScreenAdBannerRendererProps): React.ReactElement or null;<br>```<br><br>**Example Interaction:**<br>```typescript<br>import { MainScreenAdBannerRenderer } from '../delegates/MainScreenAdBannerRenderer';<br><br>{ MainScreenAdBannerRenderer({ adsFreePurchased: settings.adsFreePurchased }) }<br>```<br><br>#### üîÅ Refactored Method: MainScreen.renderAdBanner<br><br>**Breakdown after refactoring:**<br>- The MainScreen no longer contains inline logic for showing/hiding or event binding for the AdBanner.<br>- It simply calls `MainScreenAdBannerRenderer` with `adsFreePurchased` and optional event callbacks.<br>- The layout responsibilities (e.g., reclaiming space) are handled consistently by the delegate.<br><br>**How the delegate is called:**<br>- In MainScreen render, replace `{renderAdBanner()}` with:<br>```typescript<br>{ MainScreenAdBannerRenderer({ adsFreePurchased: settings.adsFreePurchased }) }<br>```<br><br>#### üîß Delegate Method: MainScreenAdBannerRenderer<br><br>**Responsibility:**  <br>Receives `adsFreePurchased` and renders the AdMobBanner/Expo-Ads-Adapter only if the user has NOT purchased the ad-free option. Handles ad load and error events. Returns `null` if ads are not to be shown.<br><br>**Signature:**<br>```typescript<br>type MainScreenAdBannerRendererProps = {<br>  adsFreePurchased: boolean;<br>  onAdLoad?: () => void;<br>  onAdError?: (error: Error) => void;<br>};<br>function MainScreenAdBannerRenderer(props: MainScreenAdBannerRendererProps): React.ReactElement or null;<br>```<br><br>**Production Code Example:**<br>```typescript<br>import React from 'react';<br>import { View, StyleSheet } from 'react-native';<br>import { AdMobBanner } from 'expo-ads-adapter'; // or whatever actual ad component is required<br><br>export type MainScreenAdBannerRendererProps = {<br>  adsFreePurchased: boolean;<br>  onAdLoad?: () => void;<br>  onAdError?: (error: Error) => void;<br>};<br><br>export function MainScreenAdBannerRenderer({<br>  adsFreePurchased,<br>  onAdLoad,<br>  onAdError,<br>}: MainScreenAdBannerRendererProps): React.ReactElement or null {<br>  if (adsFreePurchased) return null;<br>  return (<br>    <View style={styles.bannerContainer} pointerEvents="box-none"><br>      <AdMobBanner<br>        adUnitID="ca-app-pub-xxxxxxxxxxxxxxxx/xxxxxxxxxx" // real Ad Unit ID goes here<br>        servePersonalizedAds<br>        onAdLoaded={onAdLoad}<br>        onAdFailedToLoad={onAdError}<br>        style={styles.banner}<br>      /><br>    </View><br>  );<br>}<br><br>const styles = StyleSheet.create({<br>  bannerContainer: {<br>    position: 'absolute',<br>    bottom: 0,<br>    width: '100%',<br>    backgroundColor: '#fff',<br>    zIndex: 100,<br>  },<br>  banner: {<br>    width: '100%',<br>    alignSelf: 'center',<br>  },<br>});<br>```<br><br>--- |
| MainScreenTimerListRenderer | - **[Offloading Class Names]**: MainScreen<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless visual delegate; receives all data via props)<br><br>**Delegate Responsibilities Owned:**<br>- Handles rendering of the Session Timer list UI, including deduplication, mapping, theming, and accessibility.<br>- Handles rendering a single timer card, including play/edit buttons and their accessibility props.<br>- Handles empty state rendering.<br>- Receives all necessary handler functions as props.<br><br>**Responsibilities Removed from Parent Class:**<br>- The MainScreen no longer manages mapping or rendering of individual list items or empty state.<br>- All FlatList item renderers and presentation logic are encapsulated in the delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>type MainScreenTimerListRendererProps = {<br>  sessionTimers: SessionTimer[];<br>  onPlay: (id: string) => void;<br>  onEdit: (id: string) => void;<br>  onCreate: () => void;<br>  theme: ReactNativePaper.Theme;<br>};<br>function MainScreenTimerListRenderer(props: MainScreenTimerListRendererProps): React.ReactElement;<br>```<br><br>**Example Interaction:**<br>```typescript<br>import { MainScreenTimerListRenderer } from '../delegates/MainScreenTimerListRenderer';<br><br><MainScreenTimerListRenderer<br>  sessionTimers={uniqueSessionTimers}<br>  onPlay={handlePlay}<br>  onEdit={handleEditSessionTimer}<br>  onCreate={handleCreateSessionTimer}<br>  theme={theme}<br>/><br>```<br><br>#### üîß Delegate Method: MainScreenTimerListRenderer<br><br>**Responsibility:**  <br>Renders a deduplicated list of session timers, each inside a Paper Card, with play and edit buttons. Handles empty state, accessibility, and applies the provided theme. All actions are delegated to the provided handler functions.<br><br>**Signature:**<br>```typescript<br>function MainScreenTimerListRenderer(props: MainScreenTimerListRendererProps): React.ReactElement;<br>```<br><br>**Production Code Example:**<br>```typescript<br>import React from 'react';<br>import { FlatList, View, StyleSheet } from 'react-native';<br>import { Card, IconButton, Surface, Text } from 'react-native-paper';<br>import { SessionTimer } from '../models/domain';<br>import { MainScreenAccessibilityHelper } from './MainScreenAccessibilityHelper';<br><br>const EMPTY_STATE_TEXT = "No Session Timers. Tap + to create.";<br><br>export type MainScreenTimerListRendererProps = {<br>  sessionTimers: SessionTimer[];<br>  onPlay: (id: string) => void;<br>  onEdit: (id: string) => void;<br>  onCreate: () => void;<br>  theme: ReactNativePaper.Theme;<br>};<br><br>export function MainScreenTimerListRenderer({<br>  sessionTimers,<br>  onPlay,<br>  onEdit,<br>  onCreate,<br>  theme,<br>}: MainScreenTimerListRendererProps): React.ReactElement {<br>  // Deduplicate by id (if not already done on parent)<br>  const uniqueTimers = React.useMemo(() => {<br>    const seen = new Set();<br>    return sessionTimers.filter(timer => {<br>      if (seen.has(timer.id)) return false;<br>      seen.add(timer.id);<br>      return true;<br>    });<br>  }, [sessionTimers]);<br><br>  const renderTimerItem = ({ item }: { item: SessionTimer }) => (<br>    <Card style={styles.card} key={item.id} {...MainScreenAccessibilityHelper.getAccessibilityProps(`Session Timer: ${item.name}`)}><br>      <Card.Title<br>        title={item.name}<br>        subtitle={`Segments: ${item.segments.length}`}<br>        left={props => <IconButton {...props} icon="meditation" />}<br>        right={props => (<br>          <View style={styles.cardActions}><br>            <IconButton<br>              {...props}<br>              icon="play-circle"<br>              onPress={() => onPlay(item.id)}<br>              {...MainScreenAccessibilityHelper.getAccessibilityProps(`Start session: ${item.name}`)}<br>            /><br>            <IconButton<br>              {...props}<br>              icon="pencil"<br>              onPress={() => onEdit(item.id)}<br>              {...MainScreenAccessibilityHelper.getAccessibilityProps(`Edit session: ${item.name}`)}<br>            /><br>          </View><br>        )}<br>      /><br>    </Card><br>  );<br><br>  const renderEmptyState = () => (<br>    <Surface style={styles.emptyState} {...MainScreenAccessibilityHelper.getAccessibilityProps("No Session Timers")}><br>      <Text style={{ color: theme.colors.onSurface, fontSize: 16, marginBottom: 8 }}><br>        {EMPTY_STATE_TEXT}<br>      </Text><br>      <IconButton icon="plus" size={32} onPress={onCreate} /><br>    </Surface><br>  );<br><br>  return (<br>    <FlatList<br>      data={uniqueTimers}<br>      renderItem={renderTimerItem}<br>      keyExtractor={item => item.id}<br>      contentContainerStyle={[<br>        styles.listContent,<br>        !uniqueTimers.length ? { flexGrow: 1, justifyContent: 'center' } : {},<br>      ]}<br>      ListEmptyComponent={renderEmptyState}<br>      accessibilityLabel="Session Timers List"<br>    /><br>  );<br>}<br><br>const styles = StyleSheet.create({<br>  listContent: {<br>    paddingHorizontal: 12,<br>    paddingBottom: 80,<br>  },<br>  card: {<br>    marginBottom: 10,<br>    elevation: 1,<br>  },<br>  cardActions: {<br>    flexDirection: 'row',<br>    alignItems: 'center',<br>  },<br>  emptyState: {<br>    alignItems: 'center',<br>    justifyContent: 'center',<br>    elevation: 0,<br>    padding: 24,<br>    marginTop: 48,<br>    backgroundColor: 'transparent',<br>  },<br>});<br>```<br><br>--- |
| MainScreenBackgroundImageManager | - **[Offloading Class Names]**: MainScreen<br>- **[Originating Method Ids]**: MS-14, MS-15<br><br>**Delegate State Owned:**<br>- `imageReady: boolean`<br>- `backgroundSource: any`<br><br>**Delegate Responsibilities Owned:**<br>- Manages the loading state and source of the background image (Expo Image component).<br>- Handles load and error events, including fallback image assignment.<br>- Exposes a method for the parent to retrieve the current background source and image ready state.<br>- Optionally, manages fade-in transitions or other visual effects.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent class no longer manages `imageReady` or `backgroundSource` state, nor does it handle image load or error events inline.<br><br>**Delegate Public Interface:**<br>```typescript<br>class MainScreenBackgroundImageManager {<br>  constructor(initialSource: any);<br>  getBackgroundSource(): any;<br>  isImageReady(): boolean;<br>  handleImageLoaded(): void;<br>  handleImageError(event: NativeSyntheticEvent<ImageErrorEventData>): void;<br>  setBackgroundSource(source: any): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// Inside MainScreen<br>const bgImageManager = useRef(new MainScreenBackgroundImageManager(settings.sessionBackgroundImage ? { uri: settings.sessionBackgroundImage } : DEFAULT_BG));<br><br>// To get current image state and pass to ExpoImage<br><ExpoImage<br>  source={bgImageManager.current.getBackgroundSource()}<br>  onLoad={bgImageManager.current.handleImageLoaded}<br>  onError={bgImageManager.current.handleImageError}<br>  style={...}<br>  ...<br>/><br>```<br><br>#### üîÅ Refactored Method: MainScreen.handleImageLoaded / handleImageError<br><br>**Breakdown after refactoring:**<br>- The MainScreen no longer directly tracks `imageReady` or updates `backgroundSource` in its local state.<br>- Instead, it delegates these state updates and event handling to `MainScreenBackgroundImageManager`.<br>- The parent queries the delegate for the current image state and passes event handlers to the ExpoImage component.<br><br>**How the delegate is called:**<br>- On ExpoImage `onLoad`, call `bgImageManager.current.handleImageLoaded()`<br>- On ExpoImage `onError`, call `bgImageManager.current.handleImageError(event)`<br><br>**Code Example:**<br>```typescript<br><ExpoImage<br>  source={bgImageManager.current.getBackgroundSource()}<br>  onLoad={() => bgImageManager.current.handleImageLoaded()}<br>  onError={e => bgImageManager.current.handleImageError(e)}<br>  ...<br>/><br>```<br><br>#### üîß Delegate Method: handleImageLoaded<br><br>**Responsibility:**  <br>Sets the internal `imageReady` flag to true when the background image successfully loads.<br><br>**Signature:**<br>```typescript<br>handleImageLoaded(): void<br>```<br><br>**Production Code Example:**<br>```typescript<br>import { NativeSyntheticEvent, ImageErrorEventData } from 'react-native';<br><br>export class MainScreenBackgroundImageManager {<br>  private imageReady: boolean;<br>  private backgroundSource: any;<br>  private readonly DEFAULT_BG: any;<br><br>  constructor(initialSource: any, defaultBg = require('../../assets/default-bg.jpg')) {<br>    this.DEFAULT_BG = defaultBg;<br>    this.backgroundSource = initialSource or defaultBg;<br>    this.imageReady = false;<br>  }<br><br>  getBackgroundSource(): any {<br>    return this.backgroundSource;<br>  }<br><br>  isImageReady(): boolean {<br>    return this.imageReady;<br>  }<br><br>  setBackgroundSource(source: any): void {<br>    this.backgroundSource = source or this.DEFAULT_BG;<br>    this.imageReady = false;<br>  }<br><br>  handleImageLoaded(): void {<br>    this.imageReady = true;<br>    // Optionally trigger fade-in animation if needed<br>  }<br><br>  handleImageError(_event: NativeSyntheticEvent<ImageErrorEventData>): void {<br>    this.backgroundSource = this.DEFAULT_BG;<br>    this.imageReady = true;<br>  }<br>}<br>```<br><br>---<br><br>End of report. |
| SessionAudioOrchestrator | - **[Offloading Class Names]**: MeditationSessionWindow<br>- **[Originating Method Ids]**: MSW-3, MSW-4, MSW-5, MSW-9, MSW-10, MSW-11, MSW-16<br><br>**Delegate State Owned:**<br>- `meditationSoundRef`: holds the current meditation background sound (`Audio.Sound or null`)<br>- `segmentationSoundRef`: holds the current segmentation sound (`Audio.Sound or null`)<br>- `meditationSoundRepetitionCount`: counts remaining/played repetitions for meditation sound<br>- `segmentationSoundPlayCount`: counts repeated plays of segmentation sound<br>- `isSoundEnabled`: local flag to mute all sound playback after error or user choice<br>- `playbackError`: holds the latest error message for playback error dialogs (if needed)<br><br>**Delegate Responsibilities Owned:**<br>- Loading, playing, pausing, resuming, stopping, unloading of both meditation and segmentation sounds<br>- Managing sound repetition (count-based or infinite/looping)<br>- Handling sound playback error detection and error dialog trigger logic<br>- Maintaining separation of sound playback logic from session control/state logic<br>- Exposing explicit methods to operate on both sound types, respecting run-time session config<br>- Enabling or disabling all sound playback per-session (user may choose to proceed without sound if an error occurs)<br>- Providing status and error callbacks to parent for UI dialog control<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct state and logic for sound object instantiation, playback, stopping, unloading, and repetition for both segmentation and meditation sounds<br>- All sound error handling and error-specific state management<br>- All logic for counting and deciding on repetition for each sound, including indefinite loop/stop logic<br>- All helper functions related to sound pausing/resuming/stopping<br><br>**Delegate Public Interface:**<br>```typescript<br>constructor(config: SessionTimer, onError: (msg: string) => void)<br>playMeditationSound(): Promise<void><br>pauseMeditationSound(): Promise<void><br>resumeMeditationSound(): Promise<void><br>stopAndUnloadMeditationSound(): Promise<void><br>playSegmentationSound(): Promise<void><br>pauseSegmentationSound(): Promise<void><br>resumeSegmentationSound(): Promise<void><br>stopAndUnloadSegmentationSound(): Promise<void><br>setSoundEnabled(enabled: boolean): void<br>isSoundActive(): boolean<br>handlePlaybackStatusUpdate(status: AVPlaybackStatus, type: 'meditation' or 'segmentation'): Promise<void><br>```<br><br>**Example Interaction:**<br>```typescript<br>// In MeditationSessionWindow<br>const audioOrchestrator = useRef<SessionAudioOrchestrator or null>(null);<br>// On lock/blueprint configuration:<br>audioOrchestrator.current = new SessionAudioOrchestrator(sessionConfig, (msg) => setPlaybackErrorDialog({ message: msg }));<br><br>// When starting session:<br>await audioOrchestrator.current?.playMeditationSound();<br><br>// When pausing session:<br>await audioOrchestrator.current?.pauseMeditationSound();<br>await audioOrchestrator.current?.pauseSegmentationSound();<br><br>// When resuming:<br>await audioOrchestrator.current?.resumeMeditationSound();<br>await audioOrchestrator.current?.resumeSegmentationSound();<br><br>// On segment boundaries:<br>await audioOrchestrator.current?.playSegmentationSound();<br><br>// On cleanup:<br>await audioOrchestrator.current?.stopAndUnloadMeditationSound();<br>await audioOrchestrator.current?.stopAndUnloadSegmentationSound();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleStartSession<br><br>After refactoring, this method no longer manages any direct sound instantiation, error handling, or repetition counting. It simply delegates to the audio orchestrator, which is initialized with the locked session config and an error callback.<br><br>**Responsibilities After Refactoring:**<br>- Session phase transitions, timer setup, UI and OS integrations remain in the parent.<br>- Meditation and segmentation sound playback are delegated entirely.<br><br>**Delegate Interaction:**<br>```typescript<br>// In handleStartSession<br>audioOrchestrator.current = new SessionAudioOrchestrator(sessionConfig, (msg) => setPlaybackErrorDialog({ message: msg }));<br>await audioOrchestrator.current.playMeditationSound();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handlePauseSession<br><br>After refactoring, directly calls the orchestrator's pause methods.<br><br>```typescript<br>await audioOrchestrator.current?.pauseMeditationSound();<br>await audioOrchestrator.current?.pauseSegmentationSound();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleContinueSession<br><br>After refactoring, directly calls the orchestrator's resume methods.<br><br>```typescript<br>await audioOrchestrator.current?.resumeMeditationSound();<br>await audioOrchestrator.current?.resumeSegmentationSound();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleSegmentEnd<br><br>After refactoring, plays segmentation sound via orchestrator.<br><br>```typescript<br>await audioOrchestrator.current?.playSegmentationSound();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handlePlaybackStatusUpdate<br><br>No longer handles status updates directly. Instead, parent calls:<br><br>```typescript<br>audioOrchestrator.current?.handlePlaybackStatusUpdate(status, type);<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handlePlaybackError<br><br>Playback errors are surfaced via the orchestrator's error callback, which triggers the parent to show the playback error dialog and possibly disables sound for the session if the user chooses to continue.<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleSessionWindowCleanup<br><br>Calls orchestrator methods to stop/unload all sounds during session cleanup:<br><br>```typescript<br>await audioOrchestrator.current?.stopAndUnloadMeditationSound();<br>await audioOrchestrator.current?.stopAndUnloadSegmentationSound();<br>```<br><br>---<br><br>#### üîß Delegate Method: constructor<br><br>**Responsibility:**  <br>Initializes the orchestrator with the locked session configuration and an error callback to the parent. Sets up internal sound references to null and state variables.<br><br>```typescript<br>constructor(config: SessionTimer, onError: (msg: string) => void) {<br>  this.config = config;<br>  this.onError = onError;<br>  this.meditationSoundRef = null;<br>  this.segmentationSoundRef = null;<br>  this.meditationSoundRepetitionCount = 0;<br>  this.segmentationSoundPlayCount = 0;<br>  this.isSoundEnabled = true;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: playMeditationSound<br><br>**Responsibility:**  <br>- Loads and plays the meditation background sound if present and enabled.<br>- Sets reference and repetition count.<br>- Handles count-based or infinite repetition (using isLooping for 'forever').<br>- Sets up the playback status update callback.<br><br>```typescript<br>async playMeditationSound(): Promise<void> {<br>  if (!this.isSoundEnabled) return;<br>  const medSound = this.config.meditationSound;<br>  if (!medSound?.uri) return;<br>  try {<br>    const { sound } = await Audio.Sound.createAsync(<br>      { uri: medSound.uri },<br>      {<br>        volume: medSound.volume / 5,<br>        isLooping: medSound.repetitionType === 'forever',<br>        shouldPlay: true,<br>      }<br>    );<br>    this.meditationSoundRef = sound;<br>    this.meditationSoundRepetitionCount = 0;<br>    sound.setOnPlaybackStatusUpdate((status) => {<br>      this.handlePlaybackStatusUpdate(status, 'meditation');<br>    });<br>    await sound.playAsync();<br>  } catch (e: any) {<br>    this.onError(`Meditation sound playback error: ${e.message}`);<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: pauseMeditationSound<br><br>**Responsibility:**  <br>Pauses the meditation sound if loaded.<br><br>```typescript<br>async pauseMeditationSound(): Promise<void> {<br>  if (this.meditationSoundRef) {<br>    try { await this.meditationSoundRef.pauseAsync(); } catch {}<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: resumeMeditationSound<br><br>**Responsibility:**  <br>Resumes playback of the meditation sound if paused.<br><br>```typescript<br>async resumeMeditationSound(): Promise<void> {<br>  if (this.meditationSoundRef) {<br>    try { await this.meditationSoundRef.playAsync(); } catch {}<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: stopAndUnloadMeditationSound<br><br>**Responsibility:**  <br>Stops and unloads the meditation sound, clearing references.<br><br>```typescript<br>async stopAndUnloadMeditationSound(): Promise<void> {<br>  if (this.meditationSoundRef) {<br>    try {<br>      await this.meditationSoundRef.stopAsync();<br>      await this.meditationSoundRef.unloadAsync();<br>    } catch {}<br>    this.meditationSoundRef = null;<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: playSegmentationSound<br><br>**Responsibility:**  <br>- Loads and plays the segmentation sound as per config.<br>- Handles repetition by tracking play count and replaying as needed.<br>- Sets up playback status update callback.<br><br>```typescript<br>async playSegmentationSound(): Promise<void> {<br>  if (!this.isSoundEnabled) return;<br>  const segSound = this.config.segmentationSound;<br>  if (!segSound?.uri) return;<br>  try {<br>    const { sound } = await Audio.Sound.createAsync(<br>      { uri: segSound.uri },<br>      { volume: segSound.volume / 5, shouldPlay: true }<br>    );<br>    this.segmentationSoundRef = sound;<br>    this.segmentationSoundPlayCount = 1;<br>    sound.setOnPlaybackStatusUpdate((status) => {<br>      this.handlePlaybackStatusUpdate(status, 'segmentation');<br>    });<br>    await sound.playAsync();<br>  } catch (e: any) {<br>    this.onError(`Segmentation sound playback error: ${e.message}`);<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: pauseSegmentationSound<br><br>```typescript<br>async pauseSegmentationSound(): Promise<void> {<br>  if (this.segmentationSoundRef) {<br>    try { await this.segmentationSoundRef.pauseAsync(); } catch {}<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: resumeSegmentationSound<br><br>```typescript<br>async resumeSegmentationSound(): Promise<void> {<br>  if (this.segmentationSoundRef) {<br>    try { await this.segmentationSoundRef.playAsync(); } catch {}<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: stopAndUnloadSegmentationSound<br><br>```typescript<br>async stopAndUnloadSegmentationSound(): Promise<void> {<br>  if (this.segmentationSoundRef) {<br>    try {<br>      await this.segmentationSoundRef.stopAsync();<br>      await this.segmentationSoundRef.unloadAsync();<br>    } catch {}<br>    this.segmentationSoundRef = null;<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: setSoundEnabled<br><br>**Responsibility:**  <br>Enables or disables all future sound playback. If disabling and a sound is playing, stops and unloads all sounds immediately.<br><br>```typescript<br>setSoundEnabled(enabled: boolean): void {<br>  this.isSoundEnabled = enabled;<br>  if (!enabled) {<br>    this.stopAndUnloadMeditationSound();<br>    this.stopAndUnloadSegmentationSound();<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: isSoundActive<br><br>**Responsibility:**  <br>Returns whether sound is currently enabled (used for parent to check state).<br><br>```typescript<br>isSoundActive(): boolean {<br>  return this.isSoundEnabled;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: handlePlaybackStatusUpdate<br><br>**Responsibility:**  <br>Handles playback status update for both sound types, tracking and replaying as necessary, surfacing errors to parent.<br><br>```typescript<br>async handlePlaybackStatusUpdate(status: AVPlaybackStatus, type: 'meditation' or 'segmentation'): Promise<void> {<br>  // @ts-ignore<br>  if (!status.isLoaded or status.error) {<br>    this.onError(status.error or 'Unknown audio error');<br>    return;<br>  }<br>  if (status.didJustFinish) {<br>    if (type === 'segmentation') {<br>      const segSound = this.config.segmentationSound;<br>      if (<br>        segSound &&<br>        this.segmentationSoundPlayCount < segSound.repetition<br>      ) {<br>        this.segmentationSoundPlayCount += 1;<br>        try {<br>          await this.segmentationSoundRef?.replayAsync();<br>        } catch (e: any) {<br>          this.onError(`Segmentation sound replay error: ${e.message}`);<br>        }<br>      } else {<br>        try {<br>          await this.segmentationSoundRef?.unloadAsync();<br>        } catch {}<br>        this.segmentationSoundRef = null;<br>      }<br>    } else if (type === 'meditation') {<br>      const medSound = this.config.meditationSound;<br>      if (<br>        medSound &&<br>        medSound.repetitionType === 'count' &&<br>        this.meditationSoundRepetitionCount + 1 < (medSound.repetitionCount or 0)<br>      ) {<br>        this.meditationSoundRepetitionCount += 1;<br>        try {<br>          await this.meditationSoundRef?.replayAsync();<br>        } catch (e: any) {<br>          this.onError(`Meditation sound replay error: ${e.message}`);<br>        }<br>      } else {<br>        try {<br>          await this.meditationSoundRef?.unloadAsync();<br>        } catch {}<br>        this.meditationSoundRef = null;<br>      }<br>    }<br>  }<br>}<br>```<br><br>--- |
| MeditationSessionTimerManager | - **[Offloading Class Names]**: MeditationSessionWindow<br>- **[Originating Method Ids]**: MSW-3, MSW-4, MSW-5, MSW-7, MSW-8, MSW-9, MSW-16<br><br>**Delegate State Owned:**<br>- `roundTimerRef`: internal interval ref for the current round timer phase<br>- `digitalTimerRef`: internal interval ref for the digital elapsed timer<br>- `currentSegmentIndex`: the current segment index (-1 for preparation)<br>- `phase`: `'not_started' or 'preparation' or 'in_session' or 'paused' or 'terminated'`<br>- `roundTimerValue`: current value in seconds for the round timer<br>- `digitalElapsed`: current value in seconds for the digital timer<br><br>**Delegate Responsibilities Owned:**<br>- All logic related to starting, progressing, pausing, resuming, and stopping both the round timer and digital elapsed timer.<br>- Advancing phase and segments, updating state accordingly.<br>- Exposes clear methods to parent for phase/segment change, timer management, and progress reporting.<br>- Handles timer cleanup and state reset on demand.<br>- Provides explicit methods for retrieving timer/phase state for UI rendering or persistence.<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct timer interval set/clear logic, including reference and closure management.<br>- All state management for timer/phase/segment transitions.<br>- All logic for deciding when to advance a segment or switch phase.<br>- Timer tick handler logic, including count-up/count-down direction.<br><br>**Delegate Public Interface:**<br>```typescript<br>constructor(sessionConfig: SessionTimer, lockedSettings: Settings, onSegmentEnd: () => void)<br>startTimers(): void<br>pauseTimers(): void<br>resumeTimers(): void<br>resetTimers(): void<br>cleanup(): void<br>getCurrentPhase(): SessionPhase<br>getCurrentSegmentIndex(): number<br>getRoundTimerValue(): number<br>getDigitalElapsed(): number<br>setPhase(phase: SessionPhase): void<br>setCurrentSegmentIndex(idx: number): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>// On session start:<br>timerManager.current = new MeditationSessionTimerManager(sessionConfig, lockedSettings, handleSegmentEnd);<br>timerManager.current.startTimers();<br><br>// On pause:<br>timerManager.current.pauseTimers();<br><br>// On resume:<br>timerManager.current.resumeTimers();<br><br>// For UI:<br>const phase = timerManager.current.getCurrentPhase();<br>const segIdx = timerManager.current.getCurrentSegmentIndex();<br>const roundVal = timerManager.current.getRoundTimerValue();<br>const digitalElapsed = timerManager.current.getDigitalElapsed();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleStartSession<br><br>After refactoring, timer setup and advancement are delegated.<br><br>```typescript<br>timerManager.current = new MeditationSessionTimerManager(sessionConfig, lockedSettings, handleSegmentEnd);<br>timerManager.current.startTimers();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handlePauseSession<br><br>```typescript<br>timerManager.current?.pauseTimers();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleContinueSession<br><br>```typescript<br>timerManager.current?.resumeTimers();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleRoundTimerTick<br><br>Now this logic is contained within the timer manager's round timer loop. The parent no longer implements its own tick handler.<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleDigitalElapsedTick<br><br>Now this logic is contained within the timer manager's digital timer loop.<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleSegmentEnd<br><br>Parent simply calls `timerManager.current?.onSegmentEnd()` which is managed by the delegate.<br><br>---<br><br>#### üîÅ Refactored Method: MeditationSessionWindow.handleSessionWindowCleanup<br><br>Calls:<br><br>```typescript<br>timerManager.current?.cleanup();<br>```<br><br>---<br><br>#### üîß Delegate Method: constructor<br><br>```typescript<br>constructor(<br>  sessionConfig: SessionTimer,<br>  lockedSettings: Settings,<br>  onSegmentEnd: () => void<br>) {<br>  this.sessionConfig = sessionConfig;<br>  this.lockedSettings = lockedSettings;<br>  this.roundTimerRef = null;<br>  this.digitalTimerRef = null;<br>  this.currentSegmentIndex = sessionConfig.preparationTime > 0 ? -1 : 0;<br>  this.phase = sessionConfig.preparationTime > 0 ? 'preparation' : 'in_session';<br>  this.roundTimerValue = sessionConfig.preparationTime > 0<br>    ? sessionConfig.preparationTime<br>    : sessionConfig.segments[0].duration;<br>  this.digitalElapsed = 0;<br>  this.onSegmentEnd = onSegmentEnd;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: startTimers<br><br>**Responsibility:**  <br>Begins the interval timers for both round and digital timers based on the current phase/segment index and locked settings.<br><br>```typescript<br>startTimers(): void {<br>  // Digital elapsed timer<br>  this.digitalTimerRef = setInterval(() => {<br>    this.digitalElapsed += 1;<br>  }, 1000);<br><br>  // Round timer (preparation or first segment)<br>  const roundDuration = (this.currentSegmentIndex === -1)<br>    ? this.sessionConfig.preparationTime<br>    : this.sessionConfig.segments[this.currentSegmentIndex].duration;<br><br>  this.roundTimerRef = setInterval(() => {<br>    if (this.lockedSettings.countUp) {<br>      if (this.roundTimerValue >= roundDuration) {<br>        this.clearRoundTimer();<br>        this.onSegmentEnd();<br>      } else {<br>        this.roundTimerValue += 1;<br>      }<br>    } else {<br>      if (this.roundTimerValue <= 0) {<br>        this.clearRoundTimer();<br>        this.onSegmentEnd();<br>      } else {<br>        this.roundTimerValue -= 1;<br>      }<br>    }<br>  }, 1000);<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: pauseTimers<br><br>**Responsibility:**  <br>Clears all running timers.<br><br>```typescript<br>pauseTimers(): void {<br>  if (this.roundTimerRef) {<br>    clearInterval(this.roundTimerRef);<br>    this.roundTimerRef = null;<br>  }<br>  if (this.digitalTimerRef) {<br>    clearInterval(this.digitalTimerRef);<br>    this.digitalTimerRef = null;<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: resumeTimers<br><br>**Responsibility:**  <br>Resumes both timers from current values and segment index.<br><br>```typescript<br>resumeTimers(): void {<br>  this.startTimers();<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: resetTimers<br><br>**Responsibility:**  <br>Resets all timer state to initial values (for new session or after cleanup).<br><br>```typescript<br>resetTimers(): void {<br>  this.pauseTimers();<br>  this.currentSegmentIndex = this.sessionConfig.preparationTime > 0 ? -1 : 0;<br>  this.phase = this.sessionConfig.preparationTime > 0 ? 'preparation' : 'in_session';<br>  this.roundTimerValue = this.sessionConfig.preparationTime > 0<br>    ? this.sessionConfig.preparationTime<br>    : this.sessionConfig.segments[0].duration;<br>  this.digitalElapsed = 0;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: cleanup<br><br>**Responsibility:**  <br>Stops and clears all timers.<br><br>```typescript<br>cleanup(): void {<br>  this.pauseTimers();<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: getCurrentPhase<br><br>```typescript<br>getCurrentPhase(): SessionPhase {<br>  return this.phase;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: getCurrentSegmentIndex<br><br>```typescript<br>getCurrentSegmentIndex(): number {<br>  return this.currentSegmentIndex;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: getRoundTimerValue<br><br>```typescript<br>getRoundTimerValue(): number {<br>  return this.roundTimerValue;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: getDigitalElapsed<br><br>```typescript<br>getDigitalElapsed(): number {<br>  return this.digitalElapsed;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: setPhase<br><br>```typescript<br>setPhase(phase: SessionPhase): void {<br>  this.phase = phase;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: setCurrentSegmentIndex<br><br>```typescript<br>setCurrentSegmentIndex(idx: number): void {<br>  this.currentSegmentIndex = idx;<br>}<br>```<br><br>--- |
| SessionOSIntegrationManager | - **[Offloading Class Names]**: MeditationSessionWindow<br>- **[Originating Method Ids]**: MSW-3, MSW-4, MSW-5, MSW-16<br><br>**Delegate State Owned:**<br>- None (stateless; manages only OS-level side effects at call time)<br><br>**Delegate Responsibilities Owned:**<br>- Activating and deactivating keep screen awake using expo-keep-awake<br>- Activating and deactivating Do Not Disturb mode via react-native-do-not-disturb<br>- No internal state retained; all effects are transient and contextual<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct integration code for DND and screen awake management<br>- All side effect error handling for OS integration points<br><br>**Delegate Public Interface:**<br>```typescript<br>activateKeepAwakeIfNeeded(keepScreenOn: boolean): void<br>deactivateKeepAwakeIfNeeded(keepScreenOn: boolean): void<br>activateDndIfNeeded(dndEnabled: boolean): Promise<void><br>deactivateDndIfNeeded(dndEnabled: boolean): Promise<void><br>```<br><br>**Example Interaction:**<br>```typescript<br>osIntegrationManager.activateKeepAwakeIfNeeded(lockedSettings.keepScreenOn);<br>await osIntegrationManager.activateDndIfNeeded(lockedSettings.dndEnabled);<br>// On pause/teardown:<br>osIntegrationManager.deactivateKeepAwakeIfNeeded(lockedSettings.keepScreenOn);<br>await osIntegrationManager.deactivateDndIfNeeded(lockedSettings.dndEnabled);<br>```<br><br>---<br><br>#### üîß Delegate Method: activateKeepAwakeIfNeeded<br><br>```typescript<br>activateKeepAwakeIfNeeded(keepScreenOn: boolean): void {<br>  if (keepScreenOn) activateKeepAwake();<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: deactivateKeepAwakeIfNeeded<br><br>```typescript<br>deactivateKeepAwakeIfNeeded(keepScreenOn: boolean): void {<br>  if (keepScreenOn) deactivateKeepAwake();<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: activateDndIfNeeded<br><br>```typescript<br>async activateDndIfNeeded(dndEnabled: boolean): Promise<void> {<br>  if (dndEnabled) {<br>    try { await DoNotDisturb.turnOn(); } catch {}<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: deactivateDndIfNeeded<br><br>```typescript<br>async deactivateDndIfNeeded(dndEnabled: boolean): Promise<void> {<br>  if (dndEnabled) {<br>    try { await DoNotDisturb.turnOff(); } catch {}<br>  }<br>}<br>```<br><br>--- |
| SessionWindowTopBar | - **[Offloading Class Names]**: MeditationSessionWindow<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless, pure UI component)<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the top bar with back button and session title<br><br>**Responsibilities Removed from Parent Class:**<br>- All inline JSX for top bar layout and styling<br><br>**Delegate Public Interface:**<br>```typescript<br>type SessionWindowTopBarProps = {<br>  title: string;<br>  onBack: () => void;<br>};<br>export const SessionWindowTopBar: React.FC<SessionWindowTopBarProps><br>```<br><br>**Example Interaction:**<br>```tsx<br><SessionWindowTopBar<br>  title={sessionConfig.name}<br>  onBack={handleBackPress}<br>/><br>```<br><br>---<br><br>```typescript<br>export type SessionWindowTopBarProps = {<br>  title: string;<br>  onBack: () => void;<br>};<br><br>export const SessionWindowTopBar: React.FC<SessionWindowTopBarProps> = ({<br>  title,<br>  onBack,<br>}) => (<br>  <View style={{<br>    flexDirection: 'row',<br>    alignItems: 'center',<br>    paddingHorizontal: 12,<br>    paddingTop: 24,<br>    paddingBottom: 8,<br>    backgroundColor: '#F5F5F5',<br>  }}><br>    <IconButton icon="arrow-left" onPress={onBack} accessibilityLabel="Back" /><br>    <Text style={{<br>      flex: 1,<br>      fontSize: 20,<br>      fontWeight: 'bold',<br>      marginLeft: 8,<br>    }}>{title}</Text><br>  </View><br>);<br>```<br><br>--- |
| SessionCentralAnimation | - **[Offloading Class Names]**: MeditationSessionWindow<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless, pure UI component)<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the always-on central animated GIF or Lottie, with looping/pause control<br><br>**Responsibilities Removed from Parent Class:**<br>- All inline JSX for animation/gif/Lottie<br><br>**Delegate Public Interface:**<br>```typescript<br>type SessionCentralAnimationProps = {<br>  isPaused: boolean;<br>  isEnded: boolean;<br>};<br>export const SessionCentralAnimation: React.FC<SessionCentralAnimationProps><br>```<br><br>**Example Interaction:**<br>```tsx<br><SessionCentralAnimation isPaused={isSessionPaused} isEnded={isSessionEnded} /><br>```<br><br>---<br><br>```typescript<br>export type SessionCentralAnimationProps = {<br>  isPaused: boolean;<br>  isEnded: boolean;<br>};<br><br>export const SessionCentralAnimation: React.FC<SessionCentralAnimationProps> = ({<br>  isPaused,<br>  isEnded,<br>}) => (<br>  <View style={{<br>    alignItems: 'center',<br>    justifyContent: 'center',<br>    marginVertical: 16,<br>    height: 220,<br>  }}><br>    <LottieView<br>      source={require('../assets/meditate-animation.json')}<br>      autoPlay<br>      loop={!isPaused && !isEnded}<br>      style={{<br>        width: 180,<br>        height: 180,<br>      }}<br>    /><br>  </View><br>);<br>```<br><br>---<br><br>End of report. |
| DiaryEntryValidationManager | - **[Offloading Class Names]**: DiaryEntryEditor<br>- **[Originating Method Ids]**: DEE-2, DEE-3, DEE-6, DEE-7<br><br>**Delegate State Owned:**<br>- None. All methods are static and stateless; validation is pure and side-effect free.<br><br>**Delegate Responsibilities Owned:**<br>- Validate diary entry content for requiredness and minimum length.<br>- Validate ISO8601 timestamp format.<br>- Enforce timestamp uniqueness against existing diary entries and meditation logs, per business rules.<br>- Aggregate validation for all fields, returning specific error messages for UI feedback.<br><br>**Responsibilities Removed from Parent Class:**<br>- All inline validation logic for content, timestamp format, and uniqueness.<br>- Determination of edit mode based on timestamp and entry lookup.<br><br>**Delegate Public Interface:**<br><br>```typescript<br>class DiaryEntryValidationManager {<br>  static validateContent(content: string, minLength: number): string or null;<br>  static isValidISO8601(ts: string): boolean;<br>  static isUniqueTimestamp(<br>    ts: string,<br>    diaryEntries: Array<{ timestamp: string }>,<br>    meditationLogs: Array<{ timestamp: string }>,<br>    isEditMode: boolean<br>  ): boolean;<br>  static validateAll(<br>    content: string,<br>    timestamp: string,<br>    diaryEntries: Array<{ timestamp: string }>,<br>    meditationLogs: Array<{ timestamp: string }>,<br>    isEditMode: boolean,<br>    minContentLength: number<br>  ): string or null;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// Inside DiaryEntryEditor, instead of inline validation:<br>const error = DiaryEntryValidationManager.validateAll(<br>  content,<br>  timestamp,<br>  diaryEntries,<br>  meditationLogs,<br>  isEditMode,<br>  diaryEntryValidation.content.minLength<br>);<br>setErrorMsg(error);<br>setSaveDisabled(!!error);<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleChangeContent<br>**Breakdown of Responsibilities After Refactoring:**<br>- No longer contains inline content validation or error assignment.<br>- After local state update (undo stack, redo stack, content), calls `DiaryEntryValidationManager.validateAll` to get error message.<br>- Disables Save/Arrow if validation fails and sets errorMsg as returned.<br><br>**Delegate Usage:**<br>```typescript<br>const contentError = DiaryEntryValidationManager.validateContent(<br>  val,<br>  diaryEntryValidation.content.minLength<br>);<br>const error = DiaryEntryValidationManager.validateAll(<br>  val,<br>  timestamp,<br>  diaryEntries,<br>  meditationLogs,<br>  isEditMode,<br>  diaryEntryValidation.content.minLength<br>);<br>setErrorMsg(error);<br>setSaveDisabled(!!error);<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleDiaryEntryEditorMount<br>**Breakdown of Responsibilities After Refactoring:**<br>- Uses `DiaryEntryValidationManager.isValidISO8601` to verify timestamp.<br>- Determines edit mode and checks initial validity using delegate.<br>- Sets error message and disables Save if validation fails.<br><br>**Delegate Usage:**<br>```typescript<br>if (!DiaryEntryValidationManager.isValidISO8601(timestamp)) {<br>  setErrorMsg('Invalid or missing timestamp.');<br>  setSaveDisabled(true);<br>  setTimeout(() => navigation.goBack(), 500);<br>  return;<br>}<br>const error = DiaryEntryValidationManager.validateAll(<br>  found ? found.content : '',<br>  timestamp,<br>  diaryEntries,<br>  meditationLogs,<br>  !!found,<br>  diaryEntryValidation.content.minLength<br>);<br>setErrorMsg(error);<br>setSaveDisabled(!!error);<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleInvalidTimestamp<br>**Breakdown of Responsibilities After Refactoring:**<br>- Purely sets error message based on delegate validation result.<br><br>**Delegate Usage:**<br>```typescript<br>const error = DiaryEntryValidationManager.validateAll(<br>  content,<br>  timestamp,<br>  diaryEntries,<br>  meditationLogs,<br>  isEditMode,<br>  diaryEntryValidation.content.minLength<br>);<br>setErrorMsg(error);<br>setSaveDisabled(!!error);<br>navigation.goBack();<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleSave<br>**Breakdown of Responsibilities After Refactoring:**<br>- Delegates full field validation to the manager before Save.<br>- Save is only triggered if `validateAll` returns null.<br><br>**Delegate Usage:**<br>```typescript<br>const err = DiaryEntryValidationManager.validateAll(<br>  content,<br>  timestamp,<br>  diaryEntries,<br>  meditationLogs,<br>  isEditMode,<br>  diaryEntryValidation.content.minLength<br>);<br>if (err) {<br>  setErrorMsg(err);<br>  setSaveDisabled(true);<br>  return;<br>}<br>await saveDiaryEntry({ timestamp, content: content.trim() });<br>navigation.goBack();<br>```<br><br>#### üîß Delegate Method: validateContent<br><br>**What the Method Does:**  <br>Checks if the diary entry content is non-empty and meets minimum length. Returns an error message suitable for UI if invalid, or null if valid.<br><br>**Signature:**<br>```typescript<br>static validateContent(content: string, minLength: number): string or null<br>```<br><br>**Production Code:**<br>```typescript<br>static validateContent(content: string, minLength: number): string or null {<br>  if (!content or content.trim().length < minLength) {<br>    return 'Entry content is required.';<br>  }<br>  return null;<br>}<br>```<br><br>#### üîß Delegate Method: isValidISO8601<br><br>**What the Method Does:**  <br>Checks if a string is a valid ISO8601 timestamp using regex for diary entry requirements.<br><br>**Signature:**<br>```typescript<br>static isValidISO8601(ts: string): boolean<br>```<br><br>**Production Code:**<br>```typescript<br>static isValidISO8601(ts: string): boolean {<br>  return (<br>    typeof ts === 'string' &&<br>    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(?::\d{2}(?:\.\d+)?(?:Zor[\+\-]\d{2}:\d{2})?)?$/.test(ts)<br>  );<br>}<br>```<br><br>#### üîß Delegate Method: isUniqueTimestamp<br><br>**What the Method Does:**  <br>Determines if the given timestamp is unique among both diary entries and meditation logs, enforcing 1:1 mapping. Allows overwrite only in edit mode.<br><br>**Signature:**<br>```typescript<br>static isUniqueTimestamp(<br>  ts: string,<br>  diaryEntries: Array<{ timestamp: string }>,<br>  meditationLogs: Array<{ timestamp: string }>,<br>  isEditMode: boolean<br>): boolean<br>```<br><br>**Production Code:**<br>```typescript<br>static isUniqueTimestamp(<br>  ts: string,<br>  diaryEntries: Array<{ timestamp: string }>,<br>  meditationLogs: Array<{ timestamp: string }>,<br>  isEditMode: boolean<br>): boolean {<br>  const logClash = meditationLogs.filter(l => l.timestamp === ts);<br>  return logClash.length === 0 or isEditMode;<br>}<br>```<br><br>#### üîß Delegate Method: validateAll<br><br>**What the Method Does:**  <br>Aggregates validation for all fields (timestamp format, uniqueness, content length). Returns error message string or null.<br><br>**Signature:**<br>```typescript<br>static validateAll(<br>  content: string,<br>  timestamp: string,<br>  diaryEntries: Array<{ timestamp: string }>,<br>  meditationLogs: Array<{ timestamp: string }>,<br>  isEditMode: boolean,<br>  minContentLength: number<br>): string or null<br>```<br><br>**Production Code:**<br>```typescript<br>static validateAll(<br>  content: string,<br>  timestamp: string,<br>  diaryEntries: Array<{ timestamp: string }>,<br>  meditationLogs: Array<{ timestamp: string }>,<br>  isEditMode: boolean,<br>  minContentLength: number<br>): string or null {<br>  if (!timestamp or !this.isValidISO8601(timestamp)) {<br>    return 'Timestamp missing or invalid.';<br>  }<br>  if (!this.isUniqueTimestamp(timestamp, diaryEntries, meditationLogs, isEditMode)) {<br>    return 'Diary entry for this time already exists.';<br>  }<br>  const contentError = this.validateContent(content, minContentLength);<br>  if (contentError) {<br>    return contentError;<br>  }<br>  return null;<br>}<br>```<br><br>--- |
| UndoRedoStackManager | - **[Offloading Class Names]**: DiaryEntryEditor<br>- **[Originating Method Ids]**: DEE-2, DEE-9, DEE-10<br><br>**Delegate State Owned:**<br>- Internal stacks (`undoStack`, `redoStack`) managed as local arrays.<br>- No external or persistent state; all state is intended for single editor session use.<br><br>**Delegate Responsibilities Owned:**<br>- Efficiently manage undo and redo history for the content field, maintaining stack integrity.<br>- Provide methods to push, pop, and clear undo/redo history.<br>- Enforce "single editor instance only" lifecycle and never persist stacks externally.<br><br>**Responsibilities Removed from Parent Class:**<br>- Direct manipulation of undo/redo arrays within the component.<br>- Stack management logic and push/pop sequencing.<br><br>**Delegate Public Interface:**<br>```typescript<br>class UndoRedoStackManager {<br>  constructor(initialContent: string);<br>  get undoStack(): string[];<br>  get redoStack(): string[];<br>  get canUndo(): boolean;<br>  get canRedo(): boolean;<br>  get currentContent(): string;<br>  pushChange(newContent: string): void;<br>  undo(): string or null;<br>  redo(): string or null;<br>  clear(): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In DiaryEntryEditor<br>const undoRedo = useRef(new UndoRedoStackManager(content)).current;<br><br>const handleChangeContent = (val: string) => {<br>  undoRedo.pushChange(val);<br>  setContent(undoRedo.currentContent);<br>};<br><br>const handleUndo = () => {<br>  const prev = undoRedo.undo();<br>  if (prev !== null) setContent(prev);<br>};<br><br>const handleRedo = () => {<br>  const next = undoRedo.redo();<br>  if (next !== null) setContent(next);<br>};<br><br>// On unmount<br>undoRedo.clear();<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleChangeContent<br>**Breakdown of Responsibilities After Refactoring:**<br>- Instead of managing arrays in local state, calls `undoRedo.pushChange(val)`, updates content from manager.<br>- Redo stack is cleared by manager automatically with each new change.<br><br>**Delegate Usage:**<br>```typescript<br>undoRedo.pushChange(val);<br>setContent(undoRedo.currentContent);<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleUndo<br>**Breakdown of Responsibilities After Refactoring:**<br>- Calls `undoRedo.undo()`, which returns previous content or null; updates content accordingly.<br>- Stack integrity and validation is guaranteed by delegate.<br><br>**Delegate Usage:**<br>```typescript<br>const prev = undoRedo.undo();<br>if (prev !== null) setContent(prev);<br>```<br><br>#### üîÅ Refactored Method: DiaryEntryEditor.handleRedo<br>**Breakdown of Responsibilities After Refactoring:**<br>- Calls `undoRedo.redo()`, which returns next content or null; updates content accordingly.<br><br>**Delegate Usage:**<br>```typescript<br>const next = undoRedo.redo();<br>if (next !== null) setContent(next);<br>```<br><br>#### üîß Delegate Method: pushChange<br><br>**What the Method Does:**  <br>Pushes the previous content onto the undo stack, clears the redo stack, and updates the current content.<br><br>**Signature:**<br>```typescript<br>pushChange(newContent: string): void<br>```<br><br>**Production Code:**<br>```typescript<br>pushChange(newContent: string): void {<br>  if (newContent !== this._currentContent) {<br>    this._undoStack.push(this._currentContent);<br>    this._redoStack = [];<br>    this._currentContent = newContent;<br>  }<br>}<br>```<br><br>#### üîß Delegate Method: undo<br><br>**What the Method Does:**  <br>If undo stack has values, pops the top value, pushes the current content onto redo stack, updates current content, and returns new content. Returns null if undo is not possible.<br><br>**Signature:**<br>```typescript<br>undo(): string or null<br>```<br><br>**Production Code:**<br>```typescript<br>undo(): string or null {<br>  if (this._undoStack.length === 0) return null;<br>  this._redoStack.unshift(this._currentContent);<br>  const prev = this._undoStack.pop()!;<br>  this._currentContent = prev;<br>  return prev;<br>}<br>```<br><br>#### üîß Delegate Method: redo<br><br>**What the Method Does:**  <br>If redo stack has values, pops the first value, pushes current content onto undo stack, updates current content, and returns new content. Returns null if redo is not possible.<br><br>**Signature:**<br>```typescript<br>redo(): string or null<br>```<br><br>**Production Code:**<br>```typescript<br>redo(): string or null {<br>  if (this._redoStack.length === 0) return null;<br>  this._undoStack.push(this._currentContent);<br>  const next = this._redoStack.shift()!;<br>  this._currentContent = next;<br>  return next;<br>}<br>```<br><br>#### üîß Delegate Method: clear<br><br>**What the Method Does:**  <br>Clears both undo and redo stacks and resets content.<br><br>**Signature:**<br>```typescript<br>clear(): void<br>```<br><br>**Production Code:**<br>```typescript<br>clear(): void {<br>  this._undoStack = [];<br>  this._redoStack = [];<br>  this._currentContent = '';<br>}<br>```<br><br>#### üîß Delegate Constructor and Properties<br><br>**What They Do:**  <br>Initializes stacks and tracks current content.<br><br>**Production Code:**<br>```typescript<br>class UndoRedoStackManager {<br>  private _undoStack: string[];<br>  private _redoStack: string[];<br>  private _currentContent: string;<br><br>  constructor(initialContent: string) {<br>    this._undoStack = [];<br>    this._redoStack = [];<br>    this._currentContent = initialContent;<br>  }<br>  get undoStack() { return this._undoStack; }<br>  get redoStack() { return this._redoStack; }<br>  get canUndo() { return this._undoStack.length > 0; }<br>  get canRedo() { return this._redoStack.length > 0; }<br>  get currentContent() { return this._currentContent; }<br>  // (pushChange, undo, redo, clear as above)<br>}<br>```<br><br>--- |
| DiaryEntryEditorButtonRow | - **[Offloading Class Names]**: DiaryEntryEditor<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None; stateless visual component.<br><br>**Delegate Responsibilities Owned:**<br>- Render the row of action buttons (Undo, Redo, Cancel) in a clean layout with all accessibility and style props.<br>- Coordinate enable/disable state, icons, and handlers as passed from parent.<br><br>**Responsibilities Removed from Parent Class:**<br>- All JSX and layout code for the button row in the render block.<br>- Spacing, accessibility, and style configuration for action buttons.<br><br>**Delegate Public Interface:**<br>```typescript<br>type DiaryEntryEditorButtonRowProps = {<br>  onUndo: () => void;<br>  onRedo: () => void;<br>  onCancel: () => void;<br>  canUndo: boolean;<br>  canRedo: boolean;<br>};<br><br>function DiaryEntryEditorButtonRow(props: DiaryEntryEditorButtonRowProps): JSX.Element;<br>```<br><br>**Example Interaction:**<br>```typescript<br><DiaryEntryEditorButtonRow<br>  onUndo={handleUndo}<br>  onRedo={handleRedo}<br>  onCancel={handleCancel}<br>  canUndo={undoRedo.canUndo}<br>  canRedo={undoRedo.canRedo}<br>/><br>```<br><br>#### üîß Delegate Component: DiaryEntryEditorButtonRow<br><br>**What the Component Does:**  <br>Renders three styled Paper buttons ("Undo", "Redo", "Cancel") in a horizontal row, using enable/disable state and handlers as provided in props.<br><br>**Production Code:**<br>```typescript<br>import { Button } from 'react-native-paper';<br>import { View, StyleSheet } from 'react-native';<br>import React from 'react';<br><br>type DiaryEntryEditorButtonRowProps = {<br>  onUndo: () => void;<br>  onRedo: () => void;<br>  onCancel: () => void;<br>  canUndo: boolean;<br>  canRedo: boolean;<br>};<br><br>export function DiaryEntryEditorButtonRow(props: DiaryEntryEditorButtonRowProps) {<br>  const { onUndo, onRedo, onCancel, canUndo, canRedo } = props;<br>  return (<br>    <View style={styles.buttonRow}><br>      <Button<br>        icon="undo"<br>        onPress={onUndo}<br>        disabled={!canUndo}<br>        accessibilityLabel="Undo"<br>        style={styles.actionButton}<br>      ><br>        Undo<br>      </Button><br>      <Button<br>        icon="redo"<br>        onPress={onRedo}<br>        disabled={!canRedo}<br>        accessibilityLabel="Redo"<br>        style={styles.actionButton}<br>      ><br>        Redo<br>      </Button><br>      <Button<br>        mode="outlined"<br>        onPress={onCancel}<br>        accessibilityLabel="Cancel"<br>        style={styles.actionButton}<br>      ><br>        Cancel<br>      </Button><br>    </View><br>  );<br>}<br><br>const styles = StyleSheet.create({<br>  buttonRow: {<br>    flexDirection: 'row',<br>    justifyContent: 'space-between',<br>    marginTop: 16,<br>    gap: 8,<br>  },<br>  actionButton: {<br>    flex: 1,<br>    marginHorizontal: 4,<br>  },<br>});<br>```<br><br>--- |
| DiaryEntryDeleteDialogManager | - **[Offloading Class Names]**: DiaryEntryEditor<br>- **[Originating Method Ids]**: DEE-11, DEE-12, DEE-13<br><br>**Delegate State Owned:**<br>- `deleteDialogVisible: boolean` (modal open/close state).<br><br>**Delegate Responsibilities Owned:**<br>- Manage the open/close state for the delete confirmation dialog.<br>- Render the Paper Dialog modal, passing confirm/cancel handlers and any error text to the parent as needed.<br><br>**Responsibilities Removed from Parent Class:**<br>- The dialog open/close state variable.<br>- The JSX/modal code for the delete confirmation dialog.<br>- Responsibility for connecting dialog button handlers to parent methods.<br><br>**Delegate Public Interface:**<br>```typescript<br>type DiaryEntryDeleteDialogManagerProps = {<br>  visible: boolean;<br>  onConfirm: () => void or Promise<void>;<br>  onCancel: () => void;<br>  errorMessage?: string or null;<br>};<br><br>function DiaryEntryDeleteDialogManager(props: DiaryEntryDeleteDialogManagerProps): JSX.Element;<br>```<br><br>**Example Interaction:**<br>```typescript<br><DiaryEntryDeleteDialogManager<br>  visible={deleteDialogVisible}<br>  onConfirm={handleConfirmDelete}<br>  onCancel={handleCancelDelete}<br>  errorMessage={errorMsg}<br>/><br>```<br><br>#### üîÅ Refactored Methods: DiaryEntryEditor.handleDelete, handleConfirmDelete, handleCancelDelete<br>**Breakdown of Responsibilities After Refactoring:**<br>- Only set dialog visibility state or call parent handlers.<br>- All dialog rendering, button wiring, and error display handled by the delegate.<br><br>**Delegate Usage:**<br>```typescript<br>// Open dialog<br>setDeleteDialogVisible(true);<br>// Render dialog<br><DiaryEntryDeleteDialogManager<br>  visible={deleteDialogVisible}<br>  onConfirm={handleConfirmDelete}<br>  onCancel={handleCancelDelete}<br>  errorMessage={errorMsg}<br>/><br>```<br><br>#### üîß Delegate Component: DiaryEntryDeleteDialogManager<br><br>**What the Component Does:**  <br>Displays a Paper Dialog for delete confirmation, with two actions (Cancel, Delete), visible per prop. Calls `onConfirm` or `onCancel` as appropriate. Optionally displays error message.<br><br>**Production Code:**<br>```typescript<br>import { Portal, Dialog, Button, Paragraph } from 'react-native-paper';<br>import React from 'react';<br><br>type DiaryEntryDeleteDialogManagerProps = {<br>  visible: boolean;<br>  onConfirm: () => void or Promise<void>;<br>  onCancel: () => void;<br>  errorMessage?: string or null;<br>};<br><br>export function DiaryEntryDeleteDialogManager(props: DiaryEntryDeleteDialogManagerProps) {<br>  const { visible, onConfirm, onCancel, errorMessage } = props;<br>  return (<br>    <Portal><br>      <Dialog visible={visible} onDismiss={onCancel}><br>        <Dialog.Title>Delete Entry?</Dialog.Title><br>        <Dialog.Content><br>          <Paragraph><br>            Are you sure you want to delete this diary entry? This action cannot be undone.<br>          </Paragraph><br>          {errorMessage && (<br>            <Paragraph style={{ color: 'red', marginTop: 8 }}>{errorMessage}</Paragraph><br>          )}<br>        </Dialog.Content><br>        <Dialog.Actions><br>          <Button onPress={onCancel} accessibilityLabel="Cancel Delete"><br>            Cancel<br>          </Button><br>          <Button onPress={onConfirm} accessibilityLabel="Confirm Delete"><br>            Delete<br>          </Button><br>        </Dialog.Actions><br>      </Dialog><br>    </Portal><br>  );<br>}<br>```<br><br>---<br><br>End of report. |
| CalendarDayEntryListRenderer | - **[Offloading Class Names]**: CalendarView<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- Stateless; all data required for rendering is passed as props from the parent.<br><br>**Delegate Responsibilities Owned:**<br>- Render all meditation log and standalone diary entry cards for a selected day.<br>- Apply correct accessibility labels and localized formatting to each entry.<br>- Handle conditional display of "No activity" marker when no entries exist.<br>- Apply visual cues (e.g., "Diary attached" helper text) based on diary attachment status.<br>- Forward onPress actions to parent via provided callbacks.<br><br>**Responsibilities Removed from Parent Class:**<br>- CalendarView no longer needs to inline the logic and JSX for building out the daily entry list; all rendering, accessibility, and presentation logic is handled by the delegate.<br>- CalendarView passes only the data and callbacks required, reducing cognitive load in the main render.<br><br>**Delegate Public Interface:**<br>```typescript<br>type CalendarDayEntryListRendererProps = {<br>  meditations: MeditationLog[];<br>  diaryEntries: DiaryEntry[];<br>  findDiaryForMeditation: (timestamp: string) => DiaryEntry or undefined;<br>  onMeditationPress: (timestamp: string) => void;<br>  onDiaryPress: (timestamp: string) => void;<br>  onDiaryIconPress: (timestamp: string) => void;<br>  formatDateTime: (timestamp: string) => string;<br>  theme: ReactNativePaper.Theme;<br>};<br><br>export const CalendarDayEntryListRenderer: React.FC<CalendarDayEntryListRendererProps><br>```<br><br>**Example Interaction:**<br>```typescript<br><CalendarDayEntryListRenderer<br>  meditations={meditationsForSelectedDay}<br>  diaryEntries={diaryEntriesForSelectedDay}<br>  findDiaryForMeditation={findDiaryForMeditation}<br>  onMeditationPress={handleMeditationEntryPress}<br>  onDiaryPress={handleDiaryEntryPress}<br>  onDiaryIconPress={handleOpenDiary}<br>  formatDateTime={formatDateTime}<br>  theme={theme}<br>/><br>```<br><br>#### üîß Delegate Method: CalendarDayEntryListRenderer (Component)<br>**Responsibilities:**<br>- Iterate through all meditation logs for the day, rendering a Card for each.  <br>  - Show duration, localized date/time, and attached diary status.<br>  - Show diary icon if diary is attached, which calls onDiaryIconPress.<br>- Iterate through all standalone diary entries for the day, rendering a Card for each.<br>  - Show content and localized timestamp.<br>  - Card press triggers onDiaryPress.<br>- If both meditations and diaries are empty, show a "No activity" marker styled according to the current theme.<br>- All accessibility labels are applied correctly.<br>- All inputs and outputs are props; no internal state is managed.<br><br>```typescript<br>import React from 'react';<br>import { View, StyleSheet } from 'react-native';<br>import { Card, Text, List, IconButton, HelperText } from 'react-native-paper';<br>import type { MeditationLog, DiaryEntry } from '../models/domain';<br><br>type CalendarDayEntryListRendererProps = {<br>  meditations: MeditationLog[];<br>  diaryEntries: DiaryEntry[];<br>  findDiaryForMeditation: (timestamp: string) => DiaryEntry or undefined;<br>  onMeditationPress: (timestamp: string) => void;<br>  onDiaryPress: (timestamp: string) => void;<br>  onDiaryIconPress: (timestamp: string) => void;<br>  formatDateTime: (timestamp: string) => string;<br>  theme: ReactNativePaper.Theme;<br>};<br><br>export const CalendarDayEntryListRenderer: React.FC<CalendarDayEntryListRendererProps> = ({<br>  meditations,<br>  diaryEntries,<br>  findDiaryForMeditation,<br>  onMeditationPress,<br>  onDiaryPress,<br>  onDiaryIconPress,<br>  formatDateTime,<br>  theme<br>}) => {<br>  if (meditations.length === 0 && diaryEntries.length === 0) {<br>    return (<br>      <List.Item<br>        title="No activity"<br>        left={(props) => <List.Icon {...props} icon="calendar-remove" />}<br>        style={styles.emptyState}<br>        titleStyle={{ color: theme.colors.onSurfaceDisabled }}<br>        accessibilityLabel="No activity for this date"<br>      /><br>    );<br>  }<br><br>  return (<br>    <View><br>      {/* Meditation Log Cards */}<br>      {meditations.map((meditation) => {<br>        const diaryExists = !!findDiaryForMeditation(meditation.timestamp);<br>        return (<br>          <Card<br>            key={meditation.timestamp}<br>            style={styles.card}<br>            onPress={() => onMeditationPress(meditation.timestamp)}<br>            accessibilityLabel={`Meditation session at ${formatDateTime(meditation.timestamp)}. Duration: ${meditation.duration} seconds.`}<br>          ><br>            <Card.Title<br>              title="Meditation"<br>              subtitle={formatDateTime(meditation.timestamp)}<br>              left={(props) => (<br>                <List.Icon {...props} icon="meditation" color={theme.colors.primary} /><br>              )}<br>              right={(props) =><br>                diaryExists ? (<br>                  <IconButton<br>                    {...props}<br>                    icon="notebook"<br>                    onPress={() => onDiaryIconPress(meditation.timestamp)}<br>                    accessibilityLabel="Open Diary Entry"<br>                  /><br>                ) : null<br>              }<br>            /><br>            <Card.Content><br>              <Text><br>                Duration:{' '}<br>                <Text style={{ fontWeight: 'bold' }}><br>                  {meditation.duration} sec<br>                </Text><br>              </Text><br>              {diaryExists ? (<br>                <HelperText<br>                  type="info"<br>                  visible<br>                  style={{ color: theme.colors.primary }}<br>                ><br>                  Diary attached<br>                </HelperText><br>              ) : null}<br>            </Card.Content><br>          </Card><br>        );<br>      })}<br>      {/* Standalone Diary Entry Cards */}<br>      {diaryEntries.map((entry) => (<br>        <Card<br>          key={entry.timestamp}<br>          style={styles.card}<br>          onPress={() => onDiaryPress(entry.timestamp)}<br>          accessibilityLabel={`Diary entry created at ${formatDateTime(entry.timestamp)}.`}<br>        ><br>          <Card.Title<br>            title="Diary Entry"<br>            subtitle={formatDateTime(entry.timestamp)}<br>            left={(props) => (<br>              <List.Icon {...props} icon="notebook" color={theme.colors.secondary} /><br>            )}<br>          /><br>          <Card.Content><br>            <Text numberOfLines={2} ellipsizeMode="tail"><br>              {entry.content}<br>            </Text><br>          </Card.Content><br>        </Card><br>      ))}<br>    </View><br>  );<br>};<br><br>const styles = StyleSheet.create({<br>  card: {<br>    marginBottom: 12,<br>    elevation: 1,<br>  },<br>  emptyState: {<br>    marginVertical: 32,<br>    alignSelf: 'center',<br>    opacity: 0.65,<br>  },<br>});<br>```<br><br>--- |
| CalendarDateTimeFormatter | - **[Offloading Class Names]**: CalendarView<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- Stateless; all formatting is performed per-call.<br><br>**Delegate Responsibilities Owned:**<br>- Provide device-locale-correct formatting for both date+time and time-only outputs using Intl.DateTimeFormat or equivalent.<br>- Guarantee robust fallback for invalid timestamps.<br><br>**Responsibilities Removed from Parent Class:**<br>- CalendarView no longer needs to define or inline date/time formatting helper functions; all formatting is performed through this delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>class CalendarDateTimeFormatter {<br>  static formatDateTime(timestamp: string): string;<br>  static formatTimeOnly(timestamp: string): string;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const formatted = CalendarDateTimeFormatter.formatDateTime(entry.timestamp);<br>// or<br>const formattedTime = CalendarDateTimeFormatter.formatTimeOnly(entry.timestamp);<br>```<br><br>#### üîß Delegate Method: CalendarDateTimeFormatter.formatDateTime<br>**Responsibility:**<br>- Given a timestamp string, returns a localized string showing both date and time, using the device locale and medium/short styles. If parsing fails, returns the original timestamp.<br><br>```typescript<br>class CalendarDateTimeFormatter {<br>  static formatDateTime(timestamp: string): string {<br>    try {<br>      const d = new Date(timestamp);<br>      return Intl.DateTimeFormat(undefined, {<br>        dateStyle: 'medium',<br>        timeStyle: 'short',<br>      }).format(d);<br>    } catch {<br>      return timestamp;<br>    }<br>  }<br><br>  static formatTimeOnly(timestamp: string): string {<br>    try {<br>      const d = new Date(timestamp);<br>      return Intl.DateTimeFormat(undefined, {<br>        hour: '2-digit',<br>        minute: '2-digit',<br>      }).format(d);<br>    } catch {<br>      return timestamp;<br>    }<br>  }<br>}<br>```<br><br>--- |
| DiaryExportYAMLSerializer | - **[Offloading Class Names]**: DiaryView<br>- **[Originating Method Ids]**: DV-3<br><br>**Delegate State Owned:**<br>- Stateless; pure serialization logic.<br><br>**Delegate Responsibilities Owned:**<br>- Accept an array of DiaryEntry objects (already validated/in SQLite), and serialize them into YAML matching the app's export schema.<br>- Ensure correct YAML field names, chronological ordering, and schema (array of {timestamp, content} under "diary_entries").<br>- Handle only the mapping/serialization‚Äînot file management or sharing.<br><br>**Responsibilities Removed from Parent Class:**<br>- DiaryView no longer handles mapping and serializing to YAML inline‚Äîthis is now a single delegate call. All schema field control, ordering, and YAML logic is fully contained.<br><br>**Delegate Public Interface:**<br>```typescript<br>class DiaryExportYAMLSerializer {<br>  static serialize(entries: DiaryEntry[]): string;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const yamlStr = DiaryExportYAMLSerializer.serialize(diaryEntries);<br>```<br><br>#### üîÅ Refactored Method: DiaryView.handleExportDiary<br>**Breakdown of Responsibilities after Refactoring:**<br>- DiaryView retrieves and sorts diary entries, but calls `DiaryExportYAMLSerializer.serialize` to get the YAML string, then passes it to the sharing API.<br>- All YAML schema, mapping, and formatting logic is encapsulated in the delegate.<br><br>**Delegate Call Example:**<br>```typescript<br>const sortedEntries = [...diaryEntries].sort((a, b) => a.timestamp.localeCompare(b.timestamp));<br>const yamlStr = DiaryExportYAMLSerializer.serialize(sortedEntries);<br>// share yamlStr using react-native-share<br>```<br><br>#### üîß Delegate Method: DiaryExportYAMLSerializer.serialize<br>**Responsibility:**  <br>- Given an array of DiaryEntry objects, map them to the required export structure:<br>  - `{ diary_entries: Array<{ timestamp: string, content: string }> }`<br>- Order entries by timestamp ascending.<br>- Use `js-yaml` to produce YAML (no refs, plain mapping, no extra formatting).<br>- Return the YAML string.<br><br>```typescript<br>import * as yaml from 'js-yaml';<br>import type { DiaryEntry } from '../models/domain';<br><br>class DiaryExportYAMLSerializer {<br>  static serialize(entries: DiaryEntry[]): string {<br>    // Defensive copy and sort<br>    const sorted = [...entries].sort((a, b) => a.timestamp.localeCompare(b.timestamp));<br>    const yamlExport = {<br>      diary_entries: sorted.map(entry => ({<br>        timestamp: entry.timestamp,<br>        content: entry.content,<br>      })),<br>    };<br>    return yaml.dump(yamlExport, { noRefs: true });<br>  }<br>}<br>```<br><br>---<br><br>End of report. |
| StatisticsAggregator | - **[Offloading Class Names]**: StatisticsPage<br>- **[Originating Method Ids]**: SP-4<br><br>**Delegate State Owned:**<br>- None; pure functional/stateless (all calculations are performed in method scope and returned).<br><br>**Delegate Responsibilities Owned:**<br>- Aggregating meditation log data into summary statistics, period-bucketed data, and chart data.<br>- Filtering out invalid/corrupt entries (no timestamp, duration < 1).<br>- Handling all date parsing, period filtering, bucket mapping, and summary math.<br>- Formatting period keys and chart labels using locale.<br><br>**Responsibilities Removed from Parent Class:**<br>- All logic related to summary, chart, and "by period" aggregation is now encapsulated away from local state and effect hooks in `StatisticsPage`.<br>- The parent only manages state updates and delegates the entire calculation to this class.<br><br>**Delegate Public Interface:**<br>```typescript<br>aggregateStatistics(<br>  logs: { timestamp: string; duration: number }[],<br>  periodKey: string,<br>  locale: string<br>): {<br>  summary: StatsSummary;<br>  byPeriod: StatsByPeriod[];<br>  chartData: { labels: string[]; data: number[] };<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In StatisticsPage, inside useEffect or handler:<br>const { summary, byPeriod, chartData } = StatisticsAggregator.aggregateStatistics(<br>  meditationLogs,<br>  selectedPeriod,<br>  locale<br>);<br>setSummary(summary);<br>setByPeriod(byPeriod);<br>setChartData(chartData);<br>```<br><br>#### üîÅ Refactored Method: StatisticsPage.handleMeditationsLogUpdate<br>**Breakdown of responsibilities after refactoring:**<br>- The method (effect or handler) now delegates all aggregation logic to `StatisticsAggregator`.<br>- It passes `meditationLogs`, `selectedPeriod`, and `locale` as inputs.<br>- It receives the calculated `summary`, `byPeriod`, and `chartData`.<br>- It updates local state accordingly.<br>- It no longer contains any logic relating to filtering, grouping, reducing, or formatting data.<br><br>**How the delegate is called:**<br>```typescript<br>useEffect(() => {<br>  try {<br>    setChartError(null);<br>    const { summary, byPeriod, chartData } = StatisticsAggregator.aggregateStatistics(<br>      meditationLogs,<br>      selectedPeriod,<br>      locale<br>    );<br>    setSummary(summary);<br>    setByPeriod(byPeriod);<br>    setChartData(chartData);<br>  } catch (error: any) {<br>    setChartError('Statistics calculation error.');<br>  }<br>}, [meditationLogs, selectedPeriod, locale]);<br>```<br><br>#### üîß Delegate Method: aggregateStatistics<br>**Responsibility:**  <br>Takes a list of meditation logs, a period key (e.g., '3M', 'ALL'), and a locale string.  <br>- Filters logs for validity.<br>- Determines the aggregation range based on the period key.<br>- Groups valid logs into period buckets.<br>- Sums sessions and time per period.<br>- Generates chart labels (locale-formatted) and chart data.<br>- Returns summary statistics (total sessions, minutes, avg duration), by-period breakdown, and chart data.<br><br>**Signature:**<br>```typescript<br>static aggregateStatistics(<br>  logs: { timestamp: string; duration: number }[],<br>  periodKey: string,<br>  locale: string<br>): {<br>  summary: StatsSummary;<br>  byPeriod: StatsByPeriod[];<br>  chartData: { labels: string[]; data: number[] };<br>}<br>```<br><br>**Full Implementation:**<br>```typescript<br>export class StatisticsAggregator {<br>  static parseISO8601(dateStr: string): Date {<br>    return new Date(dateStr);<br>  }<br>  static monthKey(d: Date): string {<br>    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;<br>  }<br>  static getLastNMonths(n: number): string[] {<br>    const now = new Date();<br>    const keys: string[] = [];<br>    for (let i = n - 1; i >= 0; i--) {<br>      const d = new Date(now.getFullYear(), now.getMonth() - i, 1);<br>      keys.push(StatisticsAggregator.monthKey(d));<br>    }<br>    return keys;<br>  }<br><br>  /**<br>   * Aggregates meditation logs into summary stats, period bucket breakdown, and chart data.<br>   * Filters out logs with missing/invalid timestamps or duration < 1.<br>   * Buckets by month for 'XM' period keys, by all unique months for 'ALL'.<br>   * Localizes chart labels using provided locale.<br>   */<br>  static aggregateStatistics(<br>    logs: { timestamp: string; duration: number }[],<br>    periodKey: string,<br>    locale: string<br>  ): {<br>    summary: StatsSummary;<br>    byPeriod: StatsByPeriod[];<br>    chartData: { labels: string[]; data: number[] };<br>  } {<br>    // 1. Filter valid logs (timestamp present, duration > 0)<br>    const validLogs = logs.filter(<br>      (l) =><br>        !!l.timestamp &&<br>        typeof l.duration === 'number' &&<br>        Number.isFinite(l.duration) &&<br>        l.duration > 0<br>    );<br>    // 2. Determine range for aggregation<br>    let filteredLogs = validLogs;<br>    let periodLabels: string[] = [];<br>    if (periodKey === 'ALL') {<br>      // Use all unique months present in validLogs<br>      periodLabels = Array.from(<br>        new Set(validLogs.map((l) => StatisticsAggregator.monthKey(StatisticsAggregator.parseISO8601(l.timestamp))))<br>      ).sort();<br>    } else {<br>      // e.g., '1M', '3M', '6M', '12M'<br>      const monthsCount = parseInt(periodKey);<br>      periodLabels = StatisticsAggregator.getLastNMonths(monthsCount);<br>      const allowedMonths = new Set(periodLabels);<br>      filteredLogs = validLogs.filter((l) =><br>        allowedMonths.has(StatisticsAggregator.monthKey(StatisticsAggregator.parseISO8601(l.timestamp)))<br>      );<br>    }<br>    // 3. Aggregate logs per period key (month)<br>    const periodMap: Record<string, { total_sessions: number; total_minutes: number }> = {};<br>    for (let key of periodLabels) {<br>      periodMap[key] = { total_sessions: 0, total_minutes: 0 };<br>    }<br>    for (let l of filteredLogs) {<br>      const key = StatisticsAggregator.monthKey(StatisticsAggregator.parseISO8601(l.timestamp));<br>      if (periodMap[key]) {<br>        periodMap[key].total_sessions += 1;<br>        periodMap[key].total_minutes += Math.round(l.duration / 60);<br>      }<br>    }<br>    // 4. Chart labels (localized)<br>    const chartLabels: string[] = periodLabels.map((key) => {<br>      const [year, month] = key.split('-');<br>      const dateObj = new Date(parseInt(year), parseInt(month) - 1, 1);<br>      return dateObj.toLocaleDateString(locale, { month: 'short', year: '2-digit' });<br>    });<br>    const chartDataArr: number[] = periodLabels.map(<br>      (key) => periodMap[key]?.total_minutes or 0<br>    );<br>    // 5. Prepare summary (total, avg)<br>    const total_sessions = filteredLogs.length;<br>    const total_time_minutes = filteredLogs.reduce(<br>      (acc, l) => acc + Math.round(l.duration / 60),<br>      0<br>    );<br>    const average_session_duration_minutes =<br>      total_sessions === 0<br>        ? 0<br>        : Number(<br>            (<br>              filteredLogs.reduce((acc, l) => acc + l.duration, 0) /<br>              total_sessions /<br>              60<br>            ).toFixed(1)<br>          );<br>    // 6. Prepare byPeriod breakdown<br>    const byPeriod: StatsByPeriod[] = periodLabels.map((key) => ({<br>      period: key,<br>      total_sessions: periodMap[key]?.total_sessions or 0,<br>      total_minutes: periodMap[key]?.total_minutes or 0,<br>    }));<br>    return {<br>      summary: {<br>        total_sessions,<br>        total_time_minutes,<br>        average_session_duration_minutes,<br>      },<br>      byPeriod,<br>      chartData: { labels: chartLabels, data: chartDataArr },<br>    };<br>  }<br>}<br>```<br><br>--- |
| StatisticsYAMLExportHelper | - **[Offloading Class Names]**: StatisticsPage<br>- **[Originating Method Ids]**: SP-2<br><br>**Delegate State Owned:**<br>- None; stateless, pure formatting helper.<br><br>**Delegate Responsibilities Owned:**<br>- Serialization of statistics data (summary and by-month breakdown) into a YAML string matching the export schema.<br>- Validation and formatting of schema fields (ensuring by_month array is structured correctly).<br><br>**Responsibilities Removed from Parent Class:**<br>- All YAML export formatting and schema mapping logic for statistics sharing.<br><br>**Delegate Public Interface:**<br>```typescript<br>serializeToYAML(<br>  summary: StatsSummary,<br>  byPeriod: StatsByPeriod[]<br>): string<br>```<br><br>**Example Interaction:**<br>```typescript<br>const yamlStr = StatisticsYAMLExportHelper.serializeToYAML(summary, byPeriod);<br>await openShareDialog(yamlStr);<br>```<br><br>#### üîÅ Refactored Method: StatisticsPage.handleSharePress<br>**Breakdown of responsibilities after refactoring:**<br>- The method now delegates YAML generation to `StatisticsYAMLExportHelper`.<br>- It passes the current `summary` and `byPeriod`.<br>- Receives a formatted YAML string ready for sharing.<br>- No longer formats YAML or builds schema within the method.<br><br>**How the delegate is called:**<br>```typescript<br>const yamlStr = StatisticsYAMLExportHelper.serializeToYAML(summary, byPeriod);<br>await openShareDialog(yamlStr);<br>```<br><br>#### üîß Delegate Method: serializeToYAML<br>**Responsibility:**  <br>Takes summary statistics and by-period breakdown, formats them as a strict `StatisticsYAMLExport` object, and serializes to YAML (using js-yaml or similar, as appropriate). Ensures schema field names match the required export contract.<br><br>**Signature:**<br>```typescript<br>static serializeToYAML(<br>  summary: StatsSummary,<br>  byPeriod: StatsByPeriod[]<br>): string<br>```<br><br>**Full Implementation:**<br>```typescript<br>import yaml from 'js-yaml'; // Ensure dependency<br><br>export class StatisticsYAMLExportHelper {<br>  /**<br>   * Serializes summary and by-month stats to the required YAML schema.<br>   * Ensures fields are correctly named and include all required export fields.<br>   */<br>  static serializeToYAML(<br>    summary: StatsSummary,<br>    byPeriod: StatsByPeriod[]<br>  ): string {<br>    const yamlObj: StatisticsYAMLExport = {<br>      summary,<br>      by_month: byPeriod.map((periodStat) => ({<br>        month: periodStat.period,<br>        total_sessions: periodStat.total_sessions,<br>        total_minutes: periodStat.total_minutes,<br>      })),<br>    };<br>    return yaml.dump(yamlObj, { quotingType: '"', forceQuotes: false });<br>  }<br>}<br>```<br><br>--- |
| StatisticsChartErrorManager | - **[Offloading Class Names]**: StatisticsPage<br>- **[Originating Method Ids]**: SP-5<br><br>**Delegate State Owned:**<br>- None; stateless error handler.<br><br>**Delegate Responsibilities Owned:**<br>- Receives errors produced during chart rendering.<br>- Returns clean, user-friendly error messages for display in UI.<br>- Centralizes mapping of Error objects to message strings.<br><br>**Responsibilities Removed from Parent Class:**<br>- Mapping of raw error objects/messages to UI-presentable error feedback for chart-related issues.<br>- Any string or error formatting logic related to charts.<br><br>**Delegate Public Interface:**<br>```typescript<br>getChartErrorMessage(error: Error): string<br>```<br><br>**Example Interaction:**<br>```typescript<br>const errorMsg = StatisticsChartErrorManager.getChartErrorMessage(error);<br>setChartError(errorMsg);<br>```<br><br>#### üîÅ Refactored Method: StatisticsPage.handleChartError<br>**Breakdown of responsibilities after refactoring:**<br>- The handler now calls `StatisticsChartErrorManager.getChartErrorMessage`.<br>- It passes the error object and receives a clean string.<br>- It sets local state with this message for display.<br><br>**How the delegate is called:**<br>```typescript<br>const errorMsg = StatisticsChartErrorManager.getChartErrorMessage(error);<br>setChartError(errorMsg);<br>```<br><br>#### üîß Delegate Method: getChartErrorMessage<br>**Responsibility:**  <br>Given a chart rendering error, returns a user-friendly error string suitable for display in the UI. Maps known error types/messages to canned responses, otherwise falls back to a default.<br><br>**Signature:**<br>```typescript<br>static getChartErrorMessage(error: Error): string<br>```<br><br>**Full Implementation:**<br>```typescript<br>export class StatisticsChartErrorManager {<br>  static getChartErrorMessage(error: Error): string {<br>    if (!error) return 'Unknown chart error.';<br>    // Optionally map specific error types/messages here<br>    if (error.message && error.message.toLowerCase().includes('data')) {<br>      return 'Unable to render chart due to invalid or missing data.';<br>    }<br>    if (error.message && error.message.toLowerCase().includes('format')) {<br>      return 'Chart data format error.';<br>    }<br>    return error.message or 'Chart rendering error.';<br>  }<br>}<br>```<br><br>--- |
| StatisticsPagePeriodSelector | - **[Offloading Class Names]**: StatisticsPage<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None; visual-only, stateless (controlled by props).<br><br>**Delegate Responsibilities Owned:**<br>- Renders the time period selector UI for statistics.<br>- Receives options, current selection, and change handler as props.<br>- Handles accessibility and layout for selection controls.<br><br>**Responsibilities Removed from Parent Class:**<br>- Inlined JSX for the period selector row (RadioButton.Group, labels, mapping).<br><br>**Delegate Public Interface:**<br>```typescript<br>type StatisticsPagePeriodSelectorProps = {<br>  selectedPeriod: string;<br>  options: { key: string; label: string }[];<br>  onChange: (key: string) => void;<br>};<br>```<br><br>**Example Interaction:**<br>```tsx<br><StatisticsPagePeriodSelector<br>  selectedPeriod={selectedPeriod}<br>  options={PERIOD_OPTIONS}<br>  onChange={handlePeriodChange}<br>/><br>```<br><br>#### üîß Delegate Component: StatisticsPagePeriodSelector<br>**Responsibility:**  <br>Pure UI component for picking the statistics aggregation period, using Paper radio buttons and labels.<br><br>**Full Implementation:**<br>```typescript<br>import React from 'react';<br>import { View, StyleSheet } from 'react-native';<br>import { RadioButton, Text } from 'react-native-paper';<br><br>type StatisticsPagePeriodSelectorProps = {<br>  selectedPeriod: string;<br>  options: { key: string; label: string }[];<br>  onChange: (key: string) => void;<br>};<br><br>export const StatisticsPagePeriodSelector: React.FC<StatisticsPagePeriodSelectorProps> = ({<br>  selectedPeriod,<br>  options,<br>  onChange,<br>}) => (<br>  <RadioButton.Group<br>    onValueChange={onChange}<br>    value={selectedPeriod}<br>  ><br>    <View style={styles.periodRow}><br>      {options.map((option) => (<br>        <View key={option.key} style={styles.radioItem}><br>          <RadioButton value={option.key} /><br>          <Text style={styles.radioLabel}>{option.label}</Text><br>        </View><br>      ))}<br>    </View><br>  </RadioButton.Group><br>);<br><br>const styles = StyleSheet.create({<br>  periodRow: {<br>    flexDirection: 'row',<br>    flexWrap: 'wrap',<br>    justifyContent: 'center',<br>    marginVertical: 8,<br>  },<br>  radioItem: {<br>    flexDirection: 'row',<br>    alignItems: 'center',<br>    marginRight: 18,<br>    marginBottom: 4,<br>  },<br>  radioLabel: {<br>    fontSize: 15,<br>    marginLeft: 2,<br>  },<br>});<br>```<br><br>--- |
| StatisticsByMonthDetailList | - **[Offloading Class Names]**: StatisticsPage<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None; visual, stateless, parametric on props.<br><br>**Delegate Responsibilities Owned:**<br>- Renders the "By Month" detail list for statistics page.<br>- Receives byPeriod array, displays period, session, and minute fields in layout.<br>- Handles empty state UI if no periods are available.<br><br>**Responsibilities Removed from Parent Class:**<br>- All inlined JSX for rendering period stats rows for the "By Month" detail card.<br><br>**Delegate Public Interface:**<br>```typescript<br>type StatisticsByMonthDetailListProps = {<br>  byPeriod: StatsByPeriod[];<br>};<br>```<br><br>**Example Interaction:**<br>```tsx<br><StatisticsByMonthDetailList byPeriod={byPeriod} /><br>```<br><br>#### üîß Delegate Component: StatisticsByMonthDetailList<br>**Responsibility:**<br>Given a byPeriod array, renders a styled per-month breakdown list. Handles the empty case with a HelperText.<br><br>**Full Implementation:**<br>```typescript<br>import React from 'react';<br>import { View, StyleSheet } from 'react-native';<br>import { Text, HelperText } from 'react-native-paper';<br><br>type StatisticsByMonthDetailListProps = {<br>  byPeriod: StatsByPeriod[];<br>};<br><br>export const StatisticsByMonthDetailList: React.FC<StatisticsByMonthDetailListProps> = ({<br>  byPeriod,<br>}) => (<br>  <View><br>    {byPeriod.length === 0 ? (<br>      <HelperText type="info" visible={true}><br>        No data for this period.<br>      </HelperText><br>    ) : (<br>      byPeriod.map((stat) => (<br>        <View key={stat.period} style={styles.detailRow}><br>          <Text style={styles.detailPeriod}>{stat.period}</Text><br>          <Text style={styles.detailText}>Sessions: {stat.total_sessions}</Text><br>          <Text style={styles.detailText}>Minutes: {stat.total_minutes}</Text><br>        </View><br>      ))<br>    )}<br>  </View><br>);<br><br>const styles = StyleSheet.create({<br>  detailRow: {<br>    flexDirection: 'row',<br>    justifyContent: 'space-between',<br>    marginVertical: 3,<br>    borderBottomWidth: StyleSheet.hairlineWidth,<br>    borderColor: '#eee',<br>    paddingBottom: 2,<br>  },<br>  detailPeriod: {<br>    flex: 1.2,<br>    fontWeight: 'bold',<br>  },<br>  detailText: {<br>    flex: 1,<br>    textAlign: 'right',<br>  },<br>});<br>```<br><br>---<br><br>End of report. |
| SettingsPersistenceDelegate | - **[Offloading Class Names]**: SettingsStore<br>- **[Originating Method Ids]**: SS-1, SSS-1, SSS-2, SSS-3, SSS-4, SSS-5, SSS-6, SSS-7, SSS-8, SSS-9<br><br>**Delegate State Owned:**<br>- None (stateless; all state is passed in via method arguments or returned directly).<br><br>**Delegate Responsibilities Owned:**<br>- All data persistence and retrieval of the `Settings` object to and from SQLite, AsyncStorage, and (if needed) SecureStore.<br>- Data validation and serialization/deserialization between JavaScript/TypeScript objects and DB/storage rows.<br>- Atomic updates: ensures all data is fully written (or rolled back/fallen back to default) in the event of failure.<br>- Handling special logic for fields stored outside of SQLite (e.g., background image in AsyncStorage).<br>- Fallback/restore logic to ensure consistency and recovery from corrupt storage.<br>- Validation of input and output, ensuring contract with the Settings model.<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct interaction with the persistence layer (SQLite transactions, AsyncStorage calls).<br>- All field validation and conversion logic for persisted settings data.<br>- Fallback to default values on error or missing/corrupt storage.<br>- Atomic, transactional guarantees for persistence.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsPersistenceDelegate {<br>    getSettings(): Promise<Settings>;<br>    saveSettings(settings: Settings): Promise<void>;<br>    saveField<K extends keyof Settings>(key: K, value: Settings[K]): Promise<void>;<br>    revertToPersistedSettings(): Promise<Settings>;<br>    setDefaults(): Promise<Settings>;<br>    validateSettings(settings: Settings): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const persistence = new SettingsPersistenceDelegate();<br>const currentSettings = await persistence.getSettings();<br>await persistence.saveField("adsFreePurchased", true);<br>await persistence.saveSettings(newSettings);<br>const restored = await persistence.revertToPersistedSettings();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: SettingsStore.setSettings<br>**Breakdown of responsibilities after refactoring:**<br>- The SettingsStore now delegates all persistence, serialization, and validation logic to `SettingsPersistenceDelegate`.<br>- The method in SettingsStore is only responsible for updating the in-memory Zustand state and delegating the actual persistence call.<br>- All validation, as well as error handling and fallback storage, is handled by the delegate.<br>- The SettingsStore calls `SettingsPersistenceDelegate.saveSettings(settings)` after updating the in-memory state.<br><br>**Delegate Call:**<br>```typescript<br>async setSettings(settings: Settings) {<br>    this.persistence.validateSettings(settings); // Throws if invalid<br>    set({ settings: { ...settings } });<br>    await this.persistence.saveSettings(settings);<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: SettingsStore.setTheme, setDndEnabled, setKeepScreenOn, setCountUp, setBackupEnabled, setAdsFreePurchased, setBackgroundImage<br>**Breakdown of responsibilities after refactoring:**<br>- All these methods update the in-memory Zustand slice, then delegate atomic persistence of the affected field to `SettingsPersistenceDelegate.saveField`.<br>- All type validation, conversion (e.g., boolean to 0/1 in SQLite), and field-specific storage (AsyncStorage for background image) are handled by the delegate.<br><br>**Delegate Call Example (for setDndEnabled):**<br>```typescript<br>setDndEnabled(enabled: boolean) {<br>    set(state => ({ settings: { ...state.settings, dndEnabled: enabled } }));<br>    this.persistence.saveField('dndEnabled', enabled);<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: SettingsStore.setHydratedSettings<br>**Breakdown of responsibilities after refactoring:**<br>- Validates the incoming hydrated settings object via the delegate.<br>- Only updates in-memory Zustand state (no persistence).<br>- Ensures incoming data is correct type/shape using `validateSettings`.<br><br>**Delegate Call:**<br>```typescript<br>setHydratedSettings(settings: Settings) {<br>    this.persistence.validateSettings(settings);<br>    set({ settings: { ...settings } });<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: SettingsStore.setDefaults<br>**Breakdown of responsibilities after refactoring:**<br>- Invokes the delegate to set the default values persistently and returns the new default settings object.<br>- The parent method only updates the in-memory state using the returned values.<br><br>**Delegate Call:**<br>```typescript<br>async setDefaults() {<br>    const defaults = await this.persistence.setDefaults();<br>    set({ settings: { ...defaults } });<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: SettingsStore.revertToPersistedSettings<br>**Breakdown of responsibilities after refactoring:**<br>- Retrieves the last persisted settings (or defaults if not available) from the delegate.<br>- Updates in-memory Zustand state only.<br><br>**Delegate Call:**<br>```typescript<br>async revertToPersistedSettings() {<br>    const restored = await this.persistence.revertToPersistedSettings();<br>    set({ settings: { ...restored } });<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: SettingsStore.handleSettingsChange<br>**Breakdown of responsibilities after refactoring:**<br>- Validates the partial update via the delegate.<br>- Merges the partial settings into current state.<br>- Calls `saveSettings` on the delegate for atomic persistence.<br><br>**Delegate Call:**<br>```typescript<br>handleSettingsChange(changedSettings: Partial<Settings>) {<br>    const prev = get().settings;<br>    const next: Settings = { ...prev, ...changedSettings };<br>    this.persistence.validateSettings(next);<br>    set({ settings: next });<br>    this.persistence.saveSettings(next);<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: getSettings<br>**Responsibility:** Reads the current settings from SQLite, falls back to defaults if not available or corrupt. Handles deserialization and also fetches background image from AsyncStorage if needed.<br>```typescript<br>async getSettings(): Promise<Settings> {<br>    // Attempt to read primary settings row from SQLite<br>    return new Promise<Settings>((resolve, reject) => {<br>        db.transaction(tx => {<br>            tx.executeSql(<br>                `SELECT * FROM Settings LIMIT 1;`,<br>                [],<br>                async (_, result) => {<br>                    if (result.rows.length === 0) {<br>                        // No row‚Äîreturn defaults<br>                        resolve(await this.setDefaults());<br>                        return;<br>                    }<br>                    const row = result.rows.item(0);<br>                    // Retrieve background image from AsyncStorage if not present<br>                    let bgImage = row.sessionBackgroundImage or '';<br>                    if (!bgImage) {<br>                        bgImage = await AsyncStorage.getItem(ASYNC_STORAGE_BG_IMAGE_KEY) or "";<br>                    }<br>                    const settings: Settings = {<br>                        theme: row.theme,<br>                        adsFreePurchased: !!row.adsFreePurchased,<br>                        dndEnabled: !!row.dndEnabled,<br>                        backupEnabled: !!row.backupEnabled,<br>                        keepScreenOn: !!row.keepScreenOn,<br>                        countUp: !!row.countUp,<br>                        sessionBackgroundImage: bgImage,<br>                    };<br>                    this.validateSettings(settings);<br>                    resolve(settings);<br>                },<br>                (_, error) => {<br>                    // On any SQL error, return defaults<br>                    resolve(this.setDefaults());<br>                    return false;<br>                },<br>            );<br>        });<br>    });<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: saveSettings<br>**Responsibility:** Takes a full, validated `Settings` object and atomically persists all fields to SQLite (or AsyncStorage as needed). Ensures transactional update.<br>```typescript<br>async saveSettings(settings: Settings): Promise<void> {<br>    this.validateSettings(settings);<br>    return new Promise<void>((resolve, reject) => {<br>        db.transaction(tx => {<br>            tx.executeSql(<br>                `<br>                INSERT OR REPLACE INTO Settings<br>                  (id, theme, adsFreePurchased, dndEnabled, backupEnabled, keepScreenOn, countUp, sessionBackgroundImage)<br>                VALUES<br>                  (1, ?, ?, ?, ?, ?, ?, ?);<br>                `,<br>                [<br>                    settings.theme,<br>                    settings.adsFreePurchased ? 1 : 0,<br>                    settings.dndEnabled ? 1 : 0,<br>                    settings.backupEnabled ? 1 : 0,<br>                    settings.keepScreenOn ? 1 : 0,<br>                    settings.countUp ? 1 : 0,<br>                    settings.sessionBackgroundImage or "",<br>                ],<br>                async () => {<br>                    // Also persist bg image to AsyncStorage<br>                    if (settings.sessionBackgroundImage !== undefined) {<br>                        await AsyncStorage.setItem(ASYNC_STORAGE_BG_IMAGE_KEY, settings.sessionBackgroundImage or "");<br>                    }<br>                    resolve();<br>                },<br>                (_, error) => {<br>                    reject(error);<br>                    return false;<br>                },<br>            );<br>        });<br>    });<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: saveField<br>**Responsibility:** Atomically persists a single field of the Settings object (e.g., `adsFreePurchased`) to SQLite or AsyncStorage as appropriate, after validating the value.<br>```typescript<br>async saveField<K extends keyof Settings>(key: K, value: Settings[K]): Promise<void> {<br>    // Validation<br>    if (value === undefined or value === null) {<br>        throw new TypeError(`Missing required setting field: ${key}`);<br>    }<br>    if (key === "sessionBackgroundImage") {<br>        if (!value or typeof value !== "string") {<br>            throw new TypeError("sessionBackgroundImage must be a non-empty string");<br>        }<br>        await AsyncStorage.setItem(ASYNC_STORAGE_BG_IMAGE_KEY, value);<br>        // Also update SQLite for cross-persistence<br>        await this.saveSettings({ ...(await this.getSettings()), sessionBackgroundImage: value });<br>        return;<br>    }<br>    // For all other fields, update SQLite and use getSettings to fill in the rest<br>    const prev = await this.getSettings();<br>    const next: Settings = { ...prev, [key]: value };<br>    this.validateSettings(next);<br>    await this.saveSettings(next);<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: revertToPersistedSettings<br>**Responsibility:** Attempts to read persisted settings from SQLite; if corrupt or unavailable, falls back to defaults and persists them.<br>```typescript<br>async revertToPersistedSettings(): Promise<Settings> {<br>    try {<br>        return await this.getSettings();<br>    } catch {<br>        return await this.setDefaults();<br>    }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: setDefaults<br>**Responsibility:** Returns and persists the default values for all settings.<br>```typescript<br>async setDefaults(): Promise<Settings> {<br>    const DEFAULT_SETTINGS: Settings = {<br>        theme: "default",<br>        adsFreePurchased: false,<br>        dndEnabled: false,<br>        backupEnabled: false,<br>        keepScreenOn: false,<br>        countUp: false,<br>        sessionBackgroundImage: "",<br>    };<br>    await this.saveSettings(DEFAULT_SETTINGS);<br>    return { ...DEFAULT_SETTINGS };<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: validateSettings<br>**Responsibility:** Throws an error if any required field is missing or of invalid type according to the current schema/contract.<br>```typescript<br>validateSettings(settings: Settings): void {<br>    for (const [key, rule] of Object.entries(settingsValidation)) {<br>        const value = (settings as any)[key];<br>        if (rule.required && (value === undefined or value === null)) {<br>            throw new TypeError(`Missing required setting field: ${key}`);<br>        }<br>        if (rule.type === 'boolean' && typeof value !== 'boolean') {<br>            throw new TypeError(`Invalid type for setting field: ${key}. Expected boolean.`);<br>        }<br>        if (rule.type === 'string' && typeof value !== 'string') {<br>            throw new TypeError(`Invalid type for setting field: ${key}. Expected string.`);<br>        }<br>    }<br>}<br>```<br><br>---<br><br>End of report. |
| SettingsDialogManager | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- `showThemeDialog: boolean`<br>- `showImageDialog: boolean`<br>- `showRestoreDialog: boolean`<br>- `pendingRestoreMeta: BackupMeta or null`<br>- `errorDialog: string`<br>- `showSnackbar: boolean`<br>- `snackbarMsg: string`<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulating all logic and state for non-trivial modal/dialog display, including:<br>  - Theme selection dialog<br>  - Session background image selection dialog<br>  - Restore from backup confirmation dialog<br>  - Error dialog and message management<br>  - Snackbar management for transient success/error messages<br>- Managing all transitions of dialog open/close, content population, and state reset.<br>- Providing an explicit public interface to open/close dialogs, set error/snackbar messages, and manage pending selections.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer directly manages `showThemeDialog`, `showImageDialog`, `showRestoreDialog`, `pendingRestoreMeta`, `showSnackbar`, `snackbarMsg`, or `errorDialog` state.<br>- The parent delegates all logic for dialog display and feedback to this manager.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsDialogManager {<br>  // State properties<br>  showThemeDialog: boolean;<br>  showImageDialog: boolean;<br>  showRestoreDialog: boolean;<br>  pendingRestoreMeta: BackupMeta or null;<br>  errorDialog: string;<br>  showSnackbar: boolean;<br>  snackbarMsg: string;<br><br>  // Dialog methods<br>  openThemeDialog(): void;<br>  closeThemeDialog(): void;<br>  openImageDialog(): void;<br>  closeImageDialog(): void;<br>  openRestoreDialog(meta?: BackupMeta): void;<br>  closeRestoreDialog(): void;<br>  setPendingRestoreMeta(meta: BackupMeta or null): void;<br>  setErrorDialog(msg: string): void;<br>  clearErrorDialog(): void;<br>  setSnackbar(msg: string): void;<br>  clearSnackbar(): void;<br>}<br><br>// Example usage in the parent:<br>dialogManager.openThemeDialog();<br>dialogManager.setErrorDialog('An error occurred!');<br>dialogManager.openRestoreDialog(selectedBackupMeta);<br>if (dialogManager.showThemeDialog) { /* Render Dialog */ }<br>```<br><br>#### üîß Delegate Method: openThemeDialog / closeThemeDialog<br><br>**Responsibility:**  <br>Open and close the theme selection dialog. Sets the internal `showThemeDialog` boolean state.<br><br>**Signature:**<br>```typescript<br>openThemeDialog(): void;<br>closeThemeDialog(): void;<br>```<br><br>**Implementation:**<br>```typescript<br>openThemeDialog() {<br>  this.showThemeDialog = true;<br>}<br>closeThemeDialog() {<br>  this.showThemeDialog = false;<br>}<br>```<br><br>#### üîß Delegate Method: openImageDialog / closeImageDialog<br><br>**Responsibility:**  <br>Open and close the session background image selection dialog.<br><br>**Signature:**<br>```typescript<br>openImageDialog(): void;<br>closeImageDialog(): void;<br>```<br><br>**Implementation:**<br>```typescript<br>openImageDialog() {<br>  this.showImageDialog = true;<br>}<br>closeImageDialog() {<br>  this.showImageDialog = false;<br>}<br>```<br><br>#### üîß Delegate Method: openRestoreDialog / closeRestoreDialog<br><br>**Responsibility:**  <br>Open and close the restore-from-backup confirmation dialog, set and clear the pending restore metadata for display.<br><br>**Signature:**<br>```typescript<br>openRestoreDialog(meta?: BackupMeta): void;<br>closeRestoreDialog(): void;<br>setPendingRestoreMeta(meta: BackupMeta or null): void;<br>```<br><br>**Implementation:**<br>```typescript<br>openRestoreDialog(meta?: BackupMeta) {<br>  this.pendingRestoreMeta = meta ?? null;<br>  this.showRestoreDialog = true;<br>}<br>closeRestoreDialog() {<br>  this.showRestoreDialog = false;<br>  this.pendingRestoreMeta = null;<br>}<br>setPendingRestoreMeta(meta: BackupMeta or null) {<br>  this.pendingRestoreMeta = meta;<br>}<br>```<br><br>#### üîß Delegate Method: setErrorDialog / clearErrorDialog<br><br>**Responsibility:**  <br>Set and clear the error dialog message. Triggers the error dialog UI.<br><br>**Signature:**<br>```typescript<br>setErrorDialog(msg: string): void;<br>clearErrorDialog(): void;<br>```<br><br>**Implementation:**<br>```typescript<br>setErrorDialog(msg: string) {<br>  this.errorDialog = msg;<br>}<br>clearErrorDialog() {<br>  this.errorDialog = '';<br>}<br>```<br><br>#### üîß Delegate Method: setSnackbar / clearSnackbar<br><br>**Responsibility:**  <br>Set and clear the snackbar message. Triggers the snackbar UI.<br><br>**Signature:**<br>```typescript<br>setSnackbar(msg: string): void;<br>clearSnackbar(): void;<br>```<br><br>**Implementation:**<br>```typescript<br>setSnackbar(msg: string) {<br>  this.snackbarMsg = msg;<br>  this.showSnackbar = true;<br>}<br>clearSnackbar() {<br>  this.snackbarMsg = '';<br>  this.showSnackbar = false;<br>}<br>```<br><br>--- |
| SettingsBackupMetadataManager | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- `backupList: BackupMeta[]`<br>- `lastBackupIso: string or null`<br><br>**Delegate Responsibilities Owned:**<br>- Reading, parsing, and updating the list of available backups from SecureStore.<br>- Reading and parsing the last backup timestamp from SecureStore.<br>- Providing methods to refresh and access the latest backup metadata and last backup status.<br>- Handling parsing/validation of the SecureStore data.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer fetches or parses backup metadata or last backup timestamps itself.<br>- The parent now receives backup list and timestamp from this delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsBackupMetadataManager {<br>  backupList: BackupMeta[];<br>  lastBackupIso: string or null;<br>  refreshBackupMetadata(): Promise<void>;<br>  getBackupList(): BackupMeta[];<br>  getLastBackupIso(): string or null;<br>}<br><br>// Example usage:<br>await backupMetadataManager.refreshBackupMetadata();<br>const backups = backupMetadataManager.getBackupList();<br>const lastBackup = backupMetadataManager.getLastBackupIso();<br>```<br><br>#### üîß Delegate Method: refreshBackupMetadata<br><br>**Responsibility:**  <br>Fetches the backup metadata and last backup timestamp from SecureStore, parses, validates, and populates the delegate's state.<br><br>**Signature:**<br>```typescript<br>refreshBackupMetadata(): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async refreshBackupMetadata() {<br>  const metaJson = await SecureStore.getItemAsync('BACKUP_METADATA');<br>  if (metaJson) {<br>    try {<br>      this.backupList = JSON.parse(metaJson);<br>    } catch {<br>      this.backupList = [];<br>    }<br>  } else {<br>    this.backupList = [];<br>  }<br>  const lastBackup = await SecureStore.getItemAsync('LAST_BACKUP_TIMESTAMP');<br>  this.lastBackupIso = lastBackup or null;<br>}<br>```<br><br>#### üîß Delegate Method: getBackupList<br><br>**Responsibility:**  <br>Returns the most recent parsed backup list.<br><br>**Signature:**<br>```typescript<br>getBackupList(): BackupMeta[];<br>```<br><br>**Implementation:**<br>```typescript<br>getBackupList() {<br>  return this.backupList;<br>}<br>```<br><br>#### üîß Delegate Method: getLastBackupIso<br><br>**Responsibility:**  <br>Returns the last backup ISO timestamp.<br><br>**Signature:**<br>```typescript<br>getLastBackupIso(): string or null;<br>```<br><br>**Implementation:**<br>```typescript<br>getLastBackupIso() {<br>  return this.lastBackupIso;<br>}<br>```<br><br>--- |
| SettingsMonetizationHandler | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: SM-19, SM-20, SM-21, SM-22, SM-23, SM-24<br><br>**Delegate State Owned:**<br>- `isPurchasing: boolean`<br>- `isRestoringPurchase: boolean`<br>- `purchaseListenerRegistered: boolean`<br><br>**Delegate Responsibilities Owned:**<br>- Managing the state and side-effects of in-app purchases for ad removal and restoration.<br>- Initiating purchase and restore flows using Expo InAppPurchases APIs.<br>- Registering and handling purchase and restore listeners.<br>- Handling success and failure scenarios for both purchase and restoration.<br>- Exposing explicit callbacks for handling UI feedback or side-effects.<br>- Managing loading/disabled state for monetization-related UI.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent class no longer manages purchase/restoration state or listener registration directly.<br>- All side-effects and state changes for monetization are handled in this delegate.<br>- The parent class now receives purchase/restore state and explicit callbacks from the delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsMonetizationHandler {<br>  isPurchasing: boolean;<br>  isRestoringPurchase: boolean;<br><br>  startRemoveAdsPurchase(onSuccess: (result: any) => void, onFailure: (errorMsg: string) => void): Promise<void>;<br>  startRestorePurchase(onSuccess: (result: any) => void, onFailure: (errorMsg: string) => void): Promise<void>;<br>  registerPurchaseListener(adRemovalProductId: string): void;<br>  unregisterPurchaseListener(): void;<br>}<br><br>// Example usage:<br>await monetizationHandler.startRemoveAdsPurchase(handlePurchaseSuccess, handlePurchaseFailure);<br>await monetizationHandler.startRestorePurchase(handleRestoreSuccess, handleRestoreFailure);<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handleRemoveAds<br>**Responsibilities after refactoring:**<br>- Delegates the entire purchase flow and state management to the delegate.<br>- Calls `monetizationHandler.startRemoveAdsPurchase(handlePurchaseSuccess, handlePurchaseFailure);`<br>- UI loading state is updated from the delegate's `isPurchasing` state.<br><br>**Code Example:**<br>```typescript<br>const handleRemoveAds = useCallback(async () => {<br>  await monetizationHandler.startRemoveAdsPurchase(handlePurchaseSuccess, handlePurchaseFailure);<br>}, [monetizationHandler, handlePurchaseSuccess, handlePurchaseFailure]);<br>```<br><br>#### üîß Delegate Method: startRemoveAdsPurchase<br><br>**Responsibility:**  <br>Initiate in-app purchase flow for ad removal, set and manage purchase state, handle side effects and callback on completion.<br><br>**Signature:**<br>```typescript<br>startRemoveAdsPurchase(<br>  onSuccess: (result: any) => void,<br>  onFailure: (errorMsg: string) => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async startRemoveAdsPurchase(onSuccess, onFailure) {<br>  this.isPurchasing = true;<br>  try {<br>    await InAppPurchases.connectAsync();<br>    await InAppPurchases.purchaseItemAsync(this.adRemovalProductId);<br>    // Listener will call onSuccess/onFailure<br>  } catch (e: any) {<br>    onFailure('Purchase failed: ' + (e?.message or e));<br>    this.isPurchasing = false;<br>  }<br>}<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handlePurchaseSuccess / handlePurchaseFailure<br><br>**Responsibilities after refactoring:**<br>- Are invoked as callbacks from the delegate when a purchase event is received.<br>- Only update Zustand state for ad removal and display UI feedback/snackbar.<br><br>**Code Example:**<br>```typescript<br>const handlePurchaseSuccess = useCallback(async (_result: any) => {<br>  await setAdsFreePurchased(true);<br>  monetizationHandler.isPurchasing = false;<br>  dialogManager.setSnackbar('Ads removed successfully!');<br>}, [setAdsFreePurchased, monetizationHandler, dialogManager]);<br>const handlePurchaseFailure = useCallback((msg: string) => {<br>  dialogManager.setErrorDialog(msg or 'Purchase failed or cancelled.');<br>  monetizationHandler.isPurchasing = false;<br>}, [dialogManager, monetizationHandler]);<br>```<br><br>#### üîß Delegate Method: startRestorePurchase<br><br>**Responsibility:**  <br>Initiate restoration of previous ad removal purchase and manage all loading state and side effects.<br><br>**Signature:**<br>```typescript<br>startRestorePurchase(<br>  onSuccess: (result: any) => void,<br>  onFailure: (errorMsg: string) => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async startRestorePurchase(onSuccess, onFailure) {<br>  this.isRestoringPurchase = true;<br>  try {<br>    await InAppPurchases.connectAsync();<br>    await InAppPurchases.getPurchaseHistoryAsync();<br>    // Listener will call onSuccess/onFailure<br>  } catch (e: any) {<br>    onFailure('Restore failed: ' + (e?.message or e));<br>    this.isRestoringPurchase = false;<br>  }<br>}<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handleRestoreSuccess / handleRestoreFailure<br><br>**Responsibilities after refactoring:**<br>- Are invoked as callbacks from the delegate when a restore event is received.<br>- Only update Zustand state for ad removal and display UI feedback/snackbar.<br><br>**Code Example:**<br>```typescript<br>const handleRestoreSuccess = useCallback(async (_result: any) => {<br>  await setAdsFreePurchased(true);<br>  monetizationHandler.isRestoringPurchase = false;<br>  dialogManager.setSnackbar('Restored purchase successfully!');<br>}, [setAdsFreePurchased, monetizationHandler, dialogManager]);<br>const handleRestoreFailure = useCallback((msg: string) => {<br>  dialogManager.setErrorDialog(msg or 'Restore failed or cancelled.');<br>  monetizationHandler.isRestoringPurchase = false;<br>}, [dialogManager, dialogManager]);<br>```<br><br>#### üîß Delegate Method: registerPurchaseListener / unregisterPurchaseListener<br><br>**Responsibility:**  <br>Register/unregister the in-app purchase event listeners that route purchase/restore events to the correct callbacks.<br><br>**Signature:**<br>```typescript<br>registerPurchaseListener(adRemovalProductId: string): void;<br>unregisterPurchaseListener(): void;<br>```<br><br>**Implementation:**<br>```typescript<br>registerPurchaseListener(adRemovalProductId: string) {<br>  if (this.purchaseListenerRegistered) return;<br>  this.adRemovalProductId = adRemovalProductId;<br>  this.purchaseListener = ({ responseCode, results, errorCode }) => {<br>    if (responseCode === InAppPurchases.IAPResponseCode.OK) {<br>      for (const purchase of results) {<br>        if (!purchase.acknowledged && purchase.productId === this.adRemovalProductId) {<br>          this.pendingOnSuccess?.(purchase);<br>          InAppPurchases.finishTransactionAsync(purchase, false);<br>        }<br>      }<br>    } else if (responseCode === InAppPurchases.IAPResponseCode.USER_CANCELED) {<br>      this.pendingOnFailure?.(errorCode or 'Purchase cancelled.');<br>    } else {<br>      this.pendingOnFailure?.(errorCode or 'Purchase failed.');<br>    }<br>  };<br>  InAppPurchases.setPurchaseListener(this.purchaseListener);<br>  this.purchaseListenerRegistered = true;<br>}<br>unregisterPurchaseListener() {<br>  if (!this.purchaseListenerRegistered) return;<br>  InAppPurchases.setPurchaseListener(() => {});<br>  this.purchaseListenerRegistered = false;<br>}<br>```<br><br>--- |
| SettingsSharingExportHandler | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: SM-4, SM-26, SM-27<br><br>**Delegate State Owned:**<br>- `isSharing: boolean`<br>- `sharingType: 'app' or 'diary' or 'statistics' or null`<br><br>**Delegate Responsibilities Owned:**<br>- Managing all side-effects and state for diary export, app sharing, and rate-us navigation.<br>- Serializing diary entries to YAML and invoking the sharing dialog.<br>- Opening the app share dialog.<br>- Opening the Play Store (rate us) dialog.<br>- Managing the loading/disabled state for sharing-related UI components.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer serializes diary entries or opens sharing/rate dialogs itself.<br>- The parent no longer manages sharing state.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsSharingExportHandler {<br>  isSharing: boolean;<br>  sharingType: 'app' or 'diary' or 'statistics' or null;<br><br>  exportDiary(diaryEntries: DiaryEntry[], onError: (msg: string) => void): Promise<void>;<br>  shareApp(onError: (msg: string) => void): Promise<void>;<br>  rateUs(onError: (msg: string) => void): Promise<void>;<br>}<br><br>// Example usage:<br>await sharingExportHandler.exportDiary(diaryEntries, dialogManager.setErrorDialog);<br>await sharingExportHandler.shareApp(dialogManager.setErrorDialog);<br>await sharingExportHandler.rateUs(dialogManager.setErrorDialog);<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handleExportDiary<br><br>**Responsibilities after refactoring:**<br>- Delegates export and sharing to the handler.<br>- Passes all diary entries and an error callback.<br>- UI loading state is updated from `handler.isSharing`/`handler.sharingType`.<br><br>**Code Example:**<br>```typescript<br>const handleExportDiary = useCallback(async () => {<br>  await sharingExportHandler.exportDiary(diaryEntries, dialogManager.setErrorDialog);<br>}, [sharingExportHandler, diaryEntries, dialogManager]);<br>```<br><br>#### üîß Delegate Method: exportDiary<br><br>**Responsibility:**  <br>Serializes all diary entries to YAML and opens the sharing dialog. Manages state for sharing feedback.<br><br>**Signature:**<br>```typescript<br>exportDiary(<br>  diaryEntries: DiaryEntry[],<br>  onError: (msg: string) => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async exportDiary(diaryEntries, onError) {<br>  this.isSharing = true;<br>  this.sharingType = 'diary';<br>  try {<br>    const exportObj = {<br>      diary_entries: diaryEntries.map(entry => ({<br>        timestamp: entry.timestamp,<br>        content: entry.content,<br>      })),<br>    };<br>    const yaml = YAML.dump(exportObj);<br>    await Share.open({<br>      title: 'Export Diary Entries',<br>      message: yaml,<br>    });<br>  } catch (e: any) {<br>    onError('Failed to export diary entries: ' + e.message);<br>  }<br>  this.isSharing = false;<br>  this.sharingType = null;<br>}<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handleShareApp<br><br>**Responsibilities after refactoring:**<br>- Calls the delegate handler to open the sharing dialog for the app with a pre-filled message.<br><br>**Code Example:**<br>```typescript<br>const handleShareApp = useCallback(async () => {<br>  await sharingExportHandler.shareApp(dialogManager.setErrorDialog);<br>}, [sharingExportHandler, dialogManager]);<br>```<br><br>#### üîß Delegate Method: shareApp<br><br>**Responsibility:**  <br>Opens the share dialog for the app link/message, manages state for sharing feedback.<br><br>**Signature:**<br>```typescript<br>shareApp(onError: (msg: string) => void): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async shareApp(onError) {<br>  this.isSharing = true;<br>  this.sharingType = 'app';<br>  try {<br>    await Share.open({<br>      title: 'Share App',<br>      message: APP_SHARE_MESSAGE,<br>    });<br>  } catch (e: any) {<br>    if (e.message && e.message !== 'User did not share') onError('Failed to share app: ' + e.message);<br>  }<br>  this.isSharing = false;<br>  this.sharingType = null;<br>}<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handleRateUs<br><br>**Responsibilities after refactoring:**<br>- Calls the delegate handler to open the Play Store (rate us).<br><br>**Code Example:**<br>```typescript<br>const handleRateUs = useCallback(async () => {<br>  await sharingExportHandler.rateUs(dialogManager.setErrorDialog);<br>}, [sharingExportHandler, dialogManager]);<br>```<br><br>#### üîß Delegate Method: rateUs<br><br>**Responsibility:**  <br>Opens the platform-specific Play Store URL for rating. Handles any navigation errors.<br><br>**Signature:**<br>```typescript<br>rateUs(onError: (msg: string) => void): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async rateUs(onError) {<br>  try {<br>    await Linking.openURL(PLAY_STORE_URL);<br>  } catch (e: any) {<br>    onError('Failed to open store: ' + (e.message or e));<br>  }<br>}<br>```<br><br>--- |
| SettingsPermissionsHandler | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- `dndToggleDisabled: boolean`<br><br>**Delegate Responsibilities Owned:**<br>- Managing the logic for requesting/checking Do Not Disturb (DND) and other necessary permissions.<br>- Handling permission results and updating state/UI via explicit handler methods.<br>- Managing the enabled/disabled state of DND toggle and providing result callbacks for the parent.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer checks or requests DND permission directly or sets the toggle disabled state.<br>- The parent receives permission results and updates state/UI from this handler.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsPermissionsHandler {<br>  dndToggleDisabled: boolean;<br><br>  requestDndPermission(onGranted: () => void, onDenied: () => void): Promise<void>;<br>  handlePermissionResult(status: string): void;<br>}<br><br>// Example usage:<br>await permissionsHandler.requestDndPermission(<br>  () => { setDndEnabled(true); },<br>  () => { dialogManager.setSnackbar('DND permission denied.'); }<br>);<br>```<br><br>#### üîß Delegate Method: requestDndPermission<br><br>**Responsibility:**  <br>Requests/checks DND permission, and invokes appropriate callbacks for granted/denied.<br><br>**Signature:**<br>```typescript<br>requestDndPermission(onGranted: () => void, onDenied: () => void): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async requestDndPermission(onGranted, onDenied) {<br>  this.dndToggleDisabled = true;<br>  try {<br>    const status = await DND.checkDndPermission();<br>    if (status === 'authorized' or status === 'granted') {<br>      this.dndToggleDisabled = false;<br>      onGranted();<br>      return;<br>    }<br>    const requestStatus = await DND.requestDndAccess();<br>    if (requestStatus === 'authorized' or requestStatus === 'granted') {<br>      this.dndToggleDisabled = false;<br>      onGranted();<br>    } else {<br>      this.dndToggleDisabled = false;<br>      onDenied();<br>    }<br>  } catch {<br>    this.dndToggleDisabled = false;<br>    onDenied();<br>  }<br>}<br>```<br><br>#### üîß Delegate Method: handlePermissionResult<br><br>**Responsibility:**  <br>Handles the result of a permission API (e.g., DND or storage); disables toggles and triggers feedback as appropriate.<br><br>**Signature:**<br>```typescript<br>handlePermissionResult(<br>  status: 'granted' or 'denied' or 'blocked' or 'unavailable',<br>  onDenied: () => void<br>): void;<br>```<br><br>**Implementation:**<br>```typescript<br>handlePermissionResult(status, onDenied) {<br>  if (status !== 'granted' && status !== 'authorized') {<br>    this.dndToggleDisabled = true;<br>    onDenied();<br>  } else {<br>    this.dndToggleDisabled = false;<br>  }<br>}<br>```<br><br>--- |
| SettingsBackgroundImagePicker | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: SM-2, SM-3, SM-5<br><br>**Delegate State Owned:**<br>- None (stateless)<br><br>**Delegate Responsibilities Owned:**<br>- Managing all logic for launching image picker dialogs.<br>- Handling image picker results, validating URIs, and updating the parent via callbacks.<br>- Handling selection of built-in images and invoking the parent setter.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer launches image/gallery pickers or validates picker results directly.<br>- The parent receives selected image references from this delegate.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsBackgroundImagePicker {<br>  launchImagePicker(onImagePicked: (result: { cancelled: boolean, uri?: string }) => Promise<void>): Promise<void>;<br>  handleImagePicked(<br>    result: { cancelled: boolean, uri?: string },<br>    onSetBackgroundImage: (uri: string) => Promise<void>,<br>    onCloseDialog: () => void<br>  ): Promise<void>;<br>  handleBuiltInImageSelect(<br>    imageRef: string,<br>    onSetBackgroundImage: (ref: string) => Promise<void>,<br>    onCloseDialog: () => void<br>  ): Promise<void>;<br>}<br><br>// Example usage:<br>await backgroundImagePicker.launchImagePicker(onImagePicked);<br>await backgroundImagePicker.handleImagePicked(result, setBackgroundImage, closeDialog);<br>await backgroundImagePicker.handleBuiltInImageSelect('calm_blue', setBackgroundImage, closeDialog);<br>```<br><br>#### üîß Delegate Method: launchImagePicker<br><br>**Responsibility:**  <br>Launches the system image picker and passes result to supplied callback.<br><br>**Signature:**<br>```typescript<br>launchImagePicker(<br>  onImagePicked: (result: { cancelled: boolean, uri?: string }) => Promise<void><br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async launchImagePicker(onImagePicked) {<br>  const result = await ImagePicker.launchImageLibraryAsync({<br>    mediaTypes: ImagePicker.MediaTypeOptions.Images,<br>    quality: 1,<br>  });<br>  await onImagePicked(result);<br>}<br>```<br><br>#### üîß Delegate Method: handleImagePicked<br><br>**Responsibility:**  <br>Validates image picker result and updates background image if valid, closes dialog if image is set.<br><br>**Signature:**<br>```typescript<br>handleImagePicked(<br>  result: { cancelled: boolean, uri?: string },<br>  onSetBackgroundImage: (uri: string) => Promise<void>,<br>  onCloseDialog: () => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async handleImagePicked(result, onSetBackgroundImage, onCloseDialog) {<br>  if (result.cancelled) return;<br>  if (result.uri) {<br>    await onSetBackgroundImage(result.uri);<br>    onCloseDialog();<br>  }<br>}<br>```<br><br>#### üîß Delegate Method: handleBuiltInImageSelect<br><br>**Responsibility:**  <br>Handles selection of a built-in background image.<br><br>**Signature:**<br>```typescript<br>handleBuiltInImageSelect(<br>  imageRef: string,<br>  onSetBackgroundImage: (ref: string) => Promise<void>,<br>  onCloseDialog: () => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async handleBuiltInImageSelect(imageRef, onSetBackgroundImage, onCloseDialog) {<br>  await onSetBackgroundImage(imageRef);<br>  onCloseDialog();<br>}<br>```<br><br>--- |
| SettingsRestoreBackupHandler | - **[Offloading Class Names]**: SettingsMenu<br>- **[Originating Method Ids]**: SM-12, SM-13, SM-17, SM-18<br><br>**Delegate State Owned:**<br>- `restoreLoading: boolean`<br><br>**Delegate Responsibilities Owned:**<br>- Managing the flow for initiating backup restore via file picker or list selection.<br>- Managing the confirmation dialog and calling BackupJobHandler.<br>- Handling all error feedback and UI loading state.<br>- Invoking explicit callbacks on success/failure for UI notification.<br><br>**Responsibilities Removed from Parent Class:**<br>- The parent no longer performs backup restore file selection, confirmation, or loading state management directly.<br>- All side-effects and UI state for restore are handled here.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SettingsRestoreBackupHandler {<br>  restoreLoading: boolean;<br><br>  initiateRestoreViaFilePicker(<br>    onRestoreSelected: (fileUri: string) => void,<br>    onError: (msg: string) => void<br>  ): Promise<void>;<br>  confirmRestore(<br>    backupMeta: BackupMeta,<br>    onSuccess: () => void,<br>    onError: (msg: string) => void<br>  ): Promise<void>;<br>}<br><br>// Example usage:<br>await restoreBackupHandler.initiateRestoreViaFilePicker(handleRestoreSelected, dialogManager.setErrorDialog);<br>await restoreBackupHandler.confirmRestore(selectedBackupMeta, onRestoreSuccess, dialogManager.setErrorDialog);<br>```<br><br>#### üîÅ Refactored Method: SettingsMenu.handleRestoreBackup, SettingsMenu.handleRestoreBackupPress, SettingsMenu.onFilePicked, SettingsMenu.handleConfirmRestore<br><br>**Responsibilities after refactoring:**<br>- Delegates all restore logic to handler methods.<br>- Passes backupMeta or fileUri as needed, along with UI callbacks.<br><br>**Code Example:**<br>```typescript<br>const handleRestoreBackup = useCallback(async () => {<br>  await restoreBackupHandler.initiateRestoreViaFilePicker(<br>    (fileUri) => dialogManager.openRestoreDialog({ filePath: fileUri, timestamp: new Date().toISOString() }),<br>    dialogManager.setErrorDialog<br>  );<br>}, [restoreBackupHandler, dialogManager]);<br>const handleRestoreBackupPress = useCallback((backupMeta: BackupMeta) => {<br>  dialogManager.openRestoreDialog(backupMeta);<br>}, [dialogManager]);<br>const handleConfirmRestore = useCallback(async () => {<br>  if (!dialogManager.pendingRestoreMeta) return;<br>  await restoreBackupHandler.confirmRestore(<br>    dialogManager.pendingRestoreMeta,<br>    () => {<br>      dialogManager.setSnackbar('Database restored from backup.');<br>      dialogManager.closeRestoreDialog();<br>    },<br>    dialogManager.setErrorDialog<br>  );<br>}, [restoreBackupHandler, dialogManager]);<br>```<br><br>#### üîß Delegate Method: initiateRestoreViaFilePicker<br><br>**Responsibility:**  <br>Initiates the file picker and invokes callback on file selection.<br><br>**Signature:**<br>```typescript<br>initiateRestoreViaFilePicker(<br>  onRestoreSelected: (fileUri: string) => void,<br>  onError: (msg: string) => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async initiateRestoreViaFilePicker(onRestoreSelected, onError) {<br>  try {<br>    const result = await FileSystem.pickDocumentAsync({ type: 'application/octet-stream' });<br>    if (!result.cancelled && result.uri) {<br>      onRestoreSelected(result.uri);<br>    }<br>  } catch (e: any) {<br>    onError('Backup restore failed: ' + (e.message or e));<br>  }<br>}<br>```<br><br>#### üîß Delegate Method: confirmRestore<br><br>**Responsibility:**  <br>Validates and restores the database from backup file via BackupJobHandler, manages loading state, and invokes callbacks for UI feedback.<br><br>**Signature:**<br>```typescript<br>confirmRestore(<br>  backupMeta: BackupMeta,<br>  onSuccess: () => void,<br>  onError: (msg: string) => void<br>): Promise<void>;<br>```<br><br>**Implementation:**<br>```typescript<br>async confirmRestore(backupMeta, onSuccess, onError) {<br>  this.restoreLoading = true;<br>  try {<br>    await BackupJobHandler.restoreDatabaseFromFile(backupMeta.filePath);<br>    onSuccess();<br>  } catch (e: any) {<br>    onError('Restore failed: ' + (e.message or e));<br>  }<br>  this.restoreLoading = false;<br>}<br>```<br><br>---<br><br>End of report. |
| NotificationSQLiteHelper | - **[Offloading Class Names]**: NotificationManagerImpl<br>- **[Originating Method Ids]**: NM-1, NM-2, NM-3, NM-4, NM-5, NM-6, NM-8, NM-9<br><br>**Delegate State Owned:**<br>- None (stateless utility class; all state is passed in or read from SQLite via function arguments).<br><br>**Delegate Responsibilities Owned:**<br>- All direct SQLite operations for reminders/notifications, including:<br>  - Inserting, updating, and deleting notification records.<br>  - Querying for reminders (by timerId, enabled state, all).<br>  - Performing transactional deletes/updates as required by atomicity.<br>- Parsing raw SQLite rows to validated `NotificationRecord` objects.<br>- Ensuring database integrity for notification operations (no partial writes).<br><br>**Responsibilities Removed from Parent Class:**<br>- All raw SQL queries for notifications/reminders (insert/update/delete/select).<br>- Management of SQLite transaction boundaries for notification-related changes.<br>- Parsing and validation of SQLite result rows into domain models for reminders.<br><br>**Delegate Public Interface:**<br>```typescript<br>class NotificationSQLiteHelper {<br>  static async upsertNotificationRecord(table: string, record: NotificationRecord): Promise<void>;<br>  static async updateNotificationId(table: string, timerId: string, newId: string): Promise<void>;<br>  static async deleteNotificationById(table: string, notificationId: string): Promise<void>;<br>  static async deleteNotificationsByTimerId(table: string, timerId: string): Promise<void>;<br>  static async queryEnabledReminders(table: string): Promise<NotificationRecord[]>;<br>  static async queryRemindersByTimerId(table: string, timerId: string): Promise<NotificationRecord[]>;<br>  static async queryAllReminders(table: string): Promise<NotificationRecord[]>;<br>  static parseRowToRecord(row: Record<string, any>): NotificationRecord;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// Parent class (NotificationManagerImpl) usage<br>await NotificationSQLiteHelper.upsertNotificationRecord(NOTIFICATIONS_TABLE, reminderData);<br>const reminders = await NotificationSQLiteHelper.queryEnabledReminders(NOTIFICATIONS_TABLE);<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.scheduleOrUpdateReminder<br><br>**Breakdown after refactoring:**<br>- No longer contains direct SQL statements or result parsing.<br>- Delegates all DB writes/updates to `NotificationSQLiteHelper`, passing in the target table and domain model.<br>- Focuses on business flow (what to persist and when), not on persistence mechanics.<br><br>**Delegate Call Example:**<br>```typescript<br>await NotificationSQLiteHelper.upsertNotificationRecord(NOTIFICATIONS_TABLE, reminderData);<br>// (other logic follows)<br>await NotificationSQLiteHelper.updateNotificationId(NOTIFICATIONS_TABLE, timerId, notificationId);<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.cancelReminder<br><br>**Breakdown after refactoring:**<br>- Queries notification IDs and deletes by calling delegate functions.<br>- Omits all SQLs and manual transaction logic.<br><br>**Delegate Call Example:**<br>```typescript<br>const reminders = await NotificationSQLiteHelper.queryRemindersByTimerId(NOTIFICATIONS_TABLE, timerId);<br>for (const reminder of reminders) {<br>  await Notifications.cancelScheduledNotificationAsync(reminder.id);<br>  await NotificationSQLiteHelper.deleteNotificationById(NOTIFICATIONS_TABLE, reminder.id);<br>}<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.cancelAllRemindersForTimer<br><br>**Breakdown after refactoring:**<br>- Calls a single helper to delete all notification records for a timer, after cancelling them in expo-notifications.<br><br>**Delegate Call Example:**<br>```typescript<br>const reminders = await NotificationSQLiteHelper.queryRemindersByTimerId(NOTIFICATIONS_TABLE, timerId);<br>for (const reminder of reminders) {<br>  await Notifications.cancelScheduledNotificationAsync(reminder.id);<br>}<br>await NotificationSQLiteHelper.deleteNotificationsByTimerId(NOTIFICATIONS_TABLE, timerId);<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.loadAllRemindersFromDB<br><br>**Breakdown after refactoring:**<br>- Now a call to query the delegate for enabled reminders, receiving parsed domain objects.<br><br>**Delegate Call Example:**<br>```typescript<br>const notifs = await NotificationSQLiteHelper.queryEnabledReminders(NOTIFICATIONS_TABLE);<br>// ...pass notifs to Zustand slice, etc.<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.syncScheduledNotifications<br><br>**Breakdown after refactoring:**<br>- Loads reminders with a helper, then compares with expo state.<br><br>**Delegate Call Example:**<br>```typescript<br>const dbNotifs = await NotificationSQLiteHelper.queryEnabledReminders(NOTIFICATIONS_TABLE);<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.scheduleReminder<br><br>**Breakdown after refactoring:**<br>- Uses delegate for ID update if needed.<br><br>**Delegate Call Example:**<br>```typescript<br>if (reminderData.id !== notificationId) {<br>  await NotificationSQLiteHelper.updateNotificationId(NOTIFICATIONS_TABLE, timerId, notificationId);<br>}<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.onNotificationScheduled<br><br>**Breakdown after refactoring:**<br>- Purely calls upsert via helper.<br><br>**Delegate Call Example:**<br>```typescript<br>await NotificationSQLiteHelper.upsertNotificationRecord(NOTIFICATIONS_TABLE, { ...data, id: notificationId });<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.onNotificationCancel<br><br>**Breakdown after refactoring:**<br>- Purely calls delete via helper.<br><br>**Delegate Call Example:**<br>```typescript<br>await NotificationSQLiteHelper.deleteNotificationById(NOTIFICATIONS_TABLE, notificationId);<br>```<br><br>#### üîß Delegate Method: upsertNotificationRecord<br><br>**Responsibility:**<br>- Inserts or replaces a notification record in the SQLite table, mapping all fields from the domain model and ensuring correct type mapping.<br><br>**Signature:**<br>```typescript<br>static async upsertNotificationRecord(table: string, record: NotificationRecord): Promise<void><br>```<br><br>**Code:**<br>```typescript<br>static async upsertNotificationRecord(table: string, record: NotificationRecord): Promise<void> {<br>  await sqlAsync(<br>    `INSERT OR REPLACE INTO ${table}<br>      (id, frequency, time, sessionTimerId, enabled)<br>     VALUES (?, ?, ?, ?, ?);`,<br>    [<br>      record.id,<br>      record.frequency,<br>      record.time,<br>      record.sessionTimerId,<br>      record.enabled ? 1 : 0,<br>    ]<br>  );<br>}<br>```<br><br>#### üîß Delegate Method: updateNotificationId<br><br>**Responsibility:**<br>- Updates the notification ID field for a given timerId.<br><br>**Signature:**<br>```typescript<br>static async updateNotificationId(table: string, timerId: string, newId: string): Promise<void><br>```<br><br>**Code:**<br>```typescript<br>static async updateNotificationId(table: string, timerId: string, newId: string): Promise<void> {<br>  await sqlAsync(<br>    `UPDATE ${table} SET id = ? WHERE sessionTimerId = ?;`,<br>    [newId, timerId]<br>  );<br>}<br>```<br><br>#### üîß Delegate Method: deleteNotificationById<br><br>**Responsibility:**<br>- Deletes a notification record using its unique id.<br><br>**Signature:**<br>```typescript<br>static async deleteNotificationById(table: string, notificationId: string): Promise<void><br>```<br><br>**Code:**<br>```typescript<br>static async deleteNotificationById(table: string, notificationId: string): Promise<void> {<br>  await sqlAsync(<br>    `DELETE FROM ${table} WHERE id = ?;`,<br>    [notificationId]<br>  );<br>}<br>```<br><br>#### üîß Delegate Method: deleteNotificationsByTimerId<br><br>**Responsibility:**<br>- Deletes all notifications for a given timerId (atomic operation as per design).<br><br>**Signature:**<br>```typescript<br>static async deleteNotificationsByTimerId(table: string, timerId: string): Promise<void><br>```<br><br>**Code:**<br>```typescript<br>static async deleteNotificationsByTimerId(table: string, timerId: string): Promise<void> {<br>  await sqlAsync(<br>    `DELETE FROM ${table} WHERE sessionTimerId = ?;`,<br>    [timerId]<br>  );<br>}<br>```<br><br>#### üîß Delegate Method: queryEnabledReminders<br><br>**Responsibility:**<br>- Returns all enabled notification records from the table, parsing each row to a validated NotificationRecord.<br><br>**Signature:**<br>```typescript<br>static async queryEnabledReminders(table: string): Promise<NotificationRecord[]><br>```<br><br>**Code:**<br>```typescript<br>static async queryEnabledReminders(table: string): Promise<NotificationRecord[]> {<br>  const result = await sqlAsync(<br>    `SELECT id, frequency, time, sessionTimerId, enabled FROM ${table} WHERE enabled = 1;`<br>  );<br>  const notifs: NotificationRecord[] = [];<br>  for (let i = 0; i < result.rows.length; ++i) {<br>    notifs.push(NotificationSQLiteHelper.parseRowToRecord(result.rows.item(i)));<br>  }<br>  return notifs;<br>}<br>```<br><br>#### üîß Delegate Method: queryRemindersByTimerId<br><br>**Responsibility:**<br>- Returns all notification records for a timerId.<br><br>**Signature:**<br>```typescript<br>static async queryRemindersByTimerId(table: string, timerId: string): Promise<NotificationRecord[]><br>```<br><br>**Code:**<br>```typescript<br>static async queryRemindersByTimerId(table: string, timerId: string): Promise<NotificationRecord[]> {<br>  const result = await sqlAsync(<br>    `SELECT id, frequency, time, sessionTimerId, enabled FROM ${table} WHERE sessionTimerId = ?;`,<br>    [timerId]<br>  );<br>  const notifs: NotificationRecord[] = [];<br>  for (let i = 0; i < result.rows.length; ++i) {<br>    notifs.push(NotificationSQLiteHelper.parseRowToRecord(result.rows.item(i)));<br>  }<br>  return notifs;<br>}<br>```<br><br>#### üîß Delegate Method: queryAllReminders<br><br>**Responsibility:**<br>- Returns all notification records in the table.<br><br>**Signature:**<br>```typescript<br>static async queryAllReminders(table: string): Promise<NotificationRecord[]><br>```<br><br>**Code:**<br>```typescript<br>static async queryAllReminders(table: string): Promise<NotificationRecord[]> {<br>  const result = await sqlAsync(<br>    `SELECT id, frequency, time, sessionTimerId, enabled FROM ${table};`<br>  );<br>  const notifs: NotificationRecord[] = [];<br>  for (let i = 0; i < result.rows.length; ++i) {<br>    notifs.push(NotificationSQLiteHelper.parseRowToRecord(result.rows.item(i)));<br>  }<br>  return notifs;<br>}<br>```<br><br>#### üîß Delegate Method: parseRowToRecord<br><br>**Responsibility:**<br>- Takes a raw SQLite row and produces a type-safe, validated NotificationRecord.<br><br>**Signature:**<br>```typescript<br>static parseRowToRecord(row: Record<string, any>): NotificationRecord<br>```<br><br>**Code:**<br>```typescript<br>static parseRowToRecord(row: Record<string, any>): NotificationRecord {<br>  return {<br>    id: String(row.id),<br>    frequency: String(row.frequency),<br>    time: String(row.time),<br>    sessionTimerId: String(row.sessionTimerId),<br>    enabled: !!row.enabled,<br>  };<br>}<br>```<br><br>--- |
| NotificationTimeTriggerGenerator | - **[Offloading Class Names]**: NotificationManagerImpl<br>- **[Originating Method Ids]**: NM-1, NM-6<br><br>**Delegate State Owned:**<br>- None (pure function; stateless).<br><br>**Delegate Responsibilities Owned:**<br>- Computes the correct `Date` and trigger object for scheduling notifications with `expo-notifications` based on provided time strings and frequency.<br>- Ensures correct "next fire" date and trigger structure is produced, including daily and recurring patterns.<br>- Handles all time arithmetic and logic for "next available" notification.<br><br>**Responsibilities Removed from Parent Class:**<br>- All manual construction of time/trigger objects for notification scheduling.<br>- Date/time validation and rollover logic for scheduling (e.g., tomorrow if time is in past).<br><br>**Delegate Public Interface:**<br>```typescript<br>class NotificationTimeTriggerGenerator {<br>  static computeNextTrigger(<br>    currentTime: Date,<br>    timeString: string,<br>    frequency: string<br>  ): { triggerDate: Date; triggerObject: Notifications.DailyTriggerInput };<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const { triggerDate, triggerObject } =<br>  NotificationTimeTriggerGenerator.computeNextTrigger(now, reminderData.time, reminderData.frequency);<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.scheduleOrUpdateReminder<br><br>**Breakdown after refactoring:**<br>- No longer parses and computes trigger dates inline.<br>- Delegates all trigger computation to the helper, receives both `triggerDate` and `triggerObject` for scheduling.<br><br>**Delegate Call Example:**<br>```typescript<br>const { triggerDate, triggerObject } =<br>  NotificationTimeTriggerGenerator.computeNextTrigger(new Date(), reminderData.time, reminderData.frequency);<br>const notificationId = await Notifications.scheduleNotificationAsync({<br>  content: { /* ... */ },<br>  trigger: triggerObject,<br>});<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.scheduleReminder<br><br>**Breakdown after refactoring:**<br>- Same as above; computes time/trigger with the delegate.<br><br>**Delegate Call Example:**<br>```typescript<br>const { triggerDate, triggerObject } =<br>  NotificationTimeTriggerGenerator.computeNextTrigger(new Date(), reminderData.time, reminderData.frequency);<br>const notificationId = await Notifications.scheduleNotificationAsync({<br>  content: { /* ... */ },<br>  trigger: triggerObject,<br>});<br>```<br><br>#### üîß Delegate Method: computeNextTrigger<br><br>**Responsibility:**<br>- Converts a "HH:mm" or ISO8601 time and frequency string into both the next fire Date and the correct trigger object for `expo-notifications`.<br>- Handles "daily", "every_n_days", and "every_n_hours" frequencies.<br>- Ensures notifications for past times are scheduled for the next valid interval.<br><br>**Signature:**<br>```typescript<br>static computeNextTrigger(<br>  currentTime: Date,<br>  timeString: string,<br>  frequency: string<br>): { triggerDate: Date; triggerObject: Notifications.DailyTriggerInput }<br>```<br><br>**Code:**<br>```typescript<br>static computeNextTrigger(<br>  currentTime: Date,<br>  timeString: string,<br>  frequency: string<br>): { triggerDate: Date; triggerObject: Notifications.DailyTriggerInput } {<br>  let hours: number, minutes: number;<br>  if (/^\d{2}:\d{2}$/.test(timeString)) {<br>    [hours, minutes] = timeString.split(':').map(Number);<br>  } else {<br>    const date = new Date(timeString);<br>    hours = date.getHours();<br>    minutes = date.getMinutes();<br>  }<br>  let triggerDate = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate(), hours, minutes, 0, 0);<br>  let triggerObject: Notifications.DailyTriggerInput or Notifications.TimeIntervalTriggerInput;<br><br>  switch (frequency) {<br>    case "daily":<br>      if (triggerDate.getTime() <= currentTime.getTime()) {<br>        triggerDate.setDate(triggerDate.getDate() + 1);<br>      }<br>      triggerObject = { hour: hours, minute: minutes, repeats: true };<br>      break;<br>    case "every_n_days":<br>      if (triggerDate.getTime() <= currentTime.getTime()) {<br>        triggerDate.setDate(triggerDate.getDate() + 1);<br>      }<br>      // Expo Notifications only supports "repeats: true" for daily/weekly; must schedule for next occurrence and re-schedule after fire in app logic if true n-days repeating is needed<br>      triggerObject = { hour: hours, minute: minutes, repeats: true };<br>      break;<br>    case "every_n_hours":<br>      // For simplicity, fire in next n hours, assume n = 2 (for "every 2 hours"), real implementation may extract n from a field<br>      let intervalHours = 2;<br>      triggerDate = new Date(currentTime.getTime() + intervalHours * 3600 * 1000);<br>      triggerObject = { seconds: intervalHours * 3600, repeats: true };<br>      break;<br>    default:<br>      throw new Error(`Unknown frequency: ${frequency}`);<br>  }<br><br>  return { triggerDate, triggerObject };<br>}<br>```<br><br>--- |
| NotificationScheduleErrorHandler | - **[Offloading Class Names]**: NotificationManagerImpl<br>- **[Originating Method Ids]**: NM-10<br><br>**Delegate State Owned:**<br>- None (stateless).<br><br>**Delegate Responsibilities Owned:**<br>- Restores notification state/UI after failure by re-hydrating from the DB.<br>- Throws or triggers notification scheduling errors to the consuming UI for surface via dialogs.<br>- Ensures atomicity by forcing a reload of persisted notifications after errors, clearing any partial memory state.<br><br>**Responsibilities Removed from Parent Class:**<br>- Manual error/UI rollback after notification scheduling/cancellation failures.<br>- State restoration from DB after notification errors.<br><br>**Delegate Public Interface:**<br>```typescript<br>class NotificationScheduleErrorHandler {<br>  static async handleError(<br>    dbTable: string,<br>    loadAllRemindersFromDB: () => Promise<void>,<br>    error: Error<br>  ): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>await NotificationScheduleErrorHandler.handleError(<br>  NOTIFICATIONS_TABLE,<br>  this.loadAllRemindersFromDB.bind(this),<br>  error<br>);<br>```<br><br>#### üîÅ Refactored Method: NotificationManagerImpl.onNotificationScheduleFailure<br><br>**Breakdown after refactoring:**<br>- No longer needs to contain state restoration and error surfacing; this is handled in the delegate.<br>- Simply calls the delegate, passing the DB table, the "re-hydrate" function, and the caught error.<br><br>**Delegate Call Example:**<br>```typescript<br>await NotificationScheduleErrorHandler.handleError(NOTIFICATIONS_TABLE, this.loadAllRemindersFromDB.bind(this), error);<br>```<br><br>#### üîß Delegate Method: handleError<br><br>**Responsibility:**<br>- Rolls back all notification state/UI to the last persisted DB state.<br>- Calls provided "reload" method (usually NotificationManagerImpl.loadAllRemindersFromDB).<br>- Throws the error to be caught in UI for dialog display.<br><br>**Signature:**<br>```typescript<br>static async handleError(<br>  dbTable: string,<br>  loadAllRemindersFromDB: () => Promise<void>,<br>  error: Error<br>): Promise<void><br>```<br><br>**Code:**<br>```typescript<br>static async handleError(<br>  dbTable: string,<br>  loadAllRemindersFromDB: () => Promise<void>,<br>  error: Error<br>): Promise<void> {<br>  // Reload persisted state to rollback any in-memory changes<br>  await loadAllRemindersFromDB();<br>  // Rethrow error to propagate to React Native Paper Dialog/UI handler<br>  throw error;<br>}<br>```<br><br>---<br><br>End of report. |
| BackupFileIOManager | - **[Offloading Class Names]**: BackupJobHandlerImpl<br>- **[Originating Method Ids]**: BKH-1, BKH-7, BKH-8, BKH-9, BKH-11<br>  <br><br>**Delegate State Owned:**<br>- None persistent‚Äîstateless; all operations are method-scoped and atomic in execution.<br><br>**Delegate Responsibilities Owned:**<br>- Validate existence, extension, size of backup files.<br>- Perform atomic file copy operations for backup and restore (using `expo-file-system`).<br>- Ensure backup directory exists before writing.<br>- Generate timestamped backup filenames.<br>- List, parse, and prune backup files in backup directory according to retention policy.<br>- Build, serialize, and store backup metadata to SecureStore.<br>- Parse timestamps from filenames.<br><br>**Responsibilities Removed from Parent Class:**<br>- All raw file I/O regarding backups and restoration, including atomic copy, directory management, filename composition, backup metadata creation/updating, and file validation logic.<br><br>**Delegate Public Interface:**<br>```typescript<br>class BackupFileIOManager {<br>  validateBackupFile(fileUri: string): Promise<void>;<br>  copyFileToDestination(from: string, to: string): Promise<void>;<br>  ensureDirectoryExists(dir: string): Promise<void>;<br>  generateBackupFilename(now: Date): string;<br>  pruneOldBackups(backupDir: string, maxBackups: number): Promise<void>;<br>  listBackupFilesWithMeta(backupDir: string): Promise<BackupMeta[]>;<br>  saveBackupMetadata(meta: BackupMeta[], key: string): Promise<void>;<br>  parseTimestampFromFilename(fname: string): number or null;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const fileIO = new BackupFileIOManager();<br>await fileIO.validateBackupFile(backupUri);<br>await fileIO.copyFileToDestination(backupUri, SQLITE_DB_PATH);<br>const backupMeta = await fileIO.listBackupFilesWithMeta(BACKUP_DIR);<br>await fileIO.saveBackupMetadata(backupMeta, BACKUP_META_KEY);<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.restoreDatabaseFromFile<br><br>**Breakdown of responsibilities after refactoring:**<br>- This method now delegates all file validation and file copy responsibilities to `BackupFileIOManager`.<br>- It calls `fileIO.validateBackupFile(fileUri)` before proceeding.<br>- It calls `fileIO.copyFileToDestination(from, to)` for atomic replacement.<br>- After successful copy, handles hydration and metadata update as before.<br><br>**Code snippet:**<br>```typescript<br>async restoreDatabaseFromFile(fileUri: string): Promise<void> {<br>  if (!(await this.handleConcurrentBackupOrRestoreAttempt())) return;<br>  try {<br>    await this.fileIO.validateBackupFile(fileUri);<br>    await this.fileIO.copyFileToDestination(fileUri, SQLITE_DB_PATH);<br>    await this.reloadEntitiesFromRestoredDB();<br>    await this.fileIO.saveBackupMetadata(<br>      await this.fileIO.listBackupFilesWithMeta(BACKUP_DIR),<br>      BACKUP_META_KEY<br>    );<br>    await SecureStore.setItemAsync(LAST_BACKUP_TIMESTAMP_KEY, new Date().toISOString());<br>    useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>  } catch (err) {<br>    useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>    this.handleBackupOrRestoreError(err);<br>  }<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.executeBackup<br><br>**Breakdown of responsibilities after refactoring:**<br>- Delegates ensuring directory, filename generation, file copying, and metadata update to `BackupFileIOManager`.<br>- Only orchestrates the timing and flow, setting/resetting concurrency flag.<br><br>**Code snippet:**<br>```typescript<br>async executeBackup(): Promise<void> {<br>  if (!(await this.handleConcurrentBackupOrRestoreAttempt())) return;<br>  try {<br>    await this.fileIO.ensureDirectoryExists(BACKUP_DIR);<br>    const now = new Date();<br>    const destFile = BACKUP_DIR + this.fileIO.generateBackupFilename(now);<br>    await this.fileIO.copyFileToDestination(SQLITE_DB_PATH, destFile);<br>    await SecureStore.setItemAsync(LAST_BACKUP_TIMESTAMP_KEY, now.toISOString());<br>    await this.fileIO.pruneOldBackups(BACKUP_DIR, MAX_BACKUPS);<br>    await this.fileIO.saveBackupMetadata(<br>      await this.fileIO.listBackupFilesWithMeta(BACKUP_DIR),<br>      BACKUP_META_KEY<br>    );<br>    useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>  } catch (err) {<br>    useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>    await this.handleBackupFailure(err);<br>  }<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.cleanupOldBackups<br><br>**Breakdown:**<br>- Fully delegates all listing, sorting, selection, and deletion of old backup files to `BackupFileIOManager`.<br><br>**Code snippet:**<br>```typescript<br>async cleanupOldBackups(): Promise<void> {<br>  await this.fileIO.pruneOldBackups(BACKUP_DIR, MAX_BACKUPS);<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.updateBackupMetadata<br><br>**Breakdown:**<br>- Lists backup files and writes backup meta to SecureStore using `BackupFileIOManager`.<br><br>**Code snippet:**<br>```typescript<br>async updateBackupMetadata(): Promise<void> {<br>  const backupMeta = await this.fileIO.listBackupFilesWithMeta(BACKUP_DIR);<br>  await this.fileIO.saveBackupMetadata(backupMeta, BACKUP_META_KEY);<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.executeRestore<br><br>**Breakdown:**<br>- Delegates file validation and atomic copy to `BackupFileIOManager`.<br>- Handles hydration and concurrency as before.<br><br>**Code snippet:**<br>```typescript<br>async executeRestore(selectedBackupFile: { uri: string }): Promise<void> {<br>  if (!(await this.handleConcurrentBackupOrRestoreAttempt())) return;<br>  try {<br>    await this.fileIO.validateBackupFile(selectedBackupFile.uri);<br>    await this.fileIO.copyFileToDestination(selectedBackupFile.uri, SQLITE_DB_PATH);<br>    await this.reloadEntitiesFromRestoredDB();<br>    await this.updateBackupMetadata();<br>    useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>  } catch (err) {<br>    useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>    this.handleBackupOrRestoreError(err);<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: validateBackupFile<br><br>- **Responsibility**: Validates that a file exists, is a file, has `.db` extension, and is non-zero-sized.<br>- **Signature**: `async validateBackupFile(fileUri: string): Promise<void>`<br>- **Throws**: If any validation fails.<br><br>**Code:**<br>```typescript<br>async validateBackupFile(fileUri: string): Promise<void> {<br>  const info = await FileSystem.getInfoAsync(fileUri);<br>  if (!info.exists or !info.isFile) {<br>    throw new Error('Selected backup file does not exist.');<br>  }<br>  if (!fileUri.endsWith('.db')) {<br>    throw new Error('Selected backup file must have .db extension.');<br>  }<br>  if (info.size === 0) {<br>    throw new Error('Backup file is empty.');<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: copyFileToDestination<br><br>- **Responsibility**: Performs atomic file copy from `from` to `to`.<br>- **Signature**: `async copyFileToDestination(from: string, to: string): Promise<void>`<br><br>**Code:**<br>```typescript<br>async copyFileToDestination(from: string, to: string): Promise<void> {<br>  await FileSystem.copyAsync({ from, to });<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: ensureDirectoryExists<br><br>- **Responsibility**: Checks if directory exists and creates it if not.<br>- **Signature**: `async ensureDirectoryExists(dir: string): Promise<void>`<br><br>**Code:**<br>```typescript<br>async ensureDirectoryExists(dir: string): Promise<void> {<br>  const info = await FileSystem.getInfoAsync(dir);<br>  if (!info.exists) {<br>    await FileSystem.makeDirectoryAsync(dir, { intermediates: true });<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: generateBackupFilename<br><br>- **Responsibility**: Returns a timestamped backup filename for given date.<br>- **Signature**: `generateBackupFilename(now: Date): string`<br><br>**Code:**<br>```typescript<br>generateBackupFilename(now: Date): string {<br>  // YYYY-MM-DDTHH-MM-SS-Z.db (ISO8601 with : replaced by -)<br>  const timestamp = now.toISOString().replace(/[:.]/g, '-');<br>  return `meditation-app-backup-${timestamp}.db`;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: pruneOldBackups<br><br>- **Responsibility**: Deletes oldest .db backup files if more than maxBackups present in dir.<br>- **Signature**: `async pruneOldBackups(backupDir: string, maxBackups: number): Promise<void>`<br><br>**Code:**<br>```typescript<br>async pruneOldBackups(backupDir: string, maxBackups: number): Promise<void> {<br>  const files = await FileSystem.readDirectoryAsync(backupDir);<br>  const backupFiles = files<br>    .filter((fname) => fname.endsWith('.db'))<br>    .map((fname) => ({<br>      filename: fname,<br>      timestamp: this.parseTimestampFromFilename(fname),<br>    }))<br>    .filter((item) => item.timestamp !== null) as { filename: string; timestamp: number }[];<br><br>  if (backupFiles.length > maxBackups) {<br>    backupFiles.sort((a, b) => a.timestamp - b.timestamp); // oldest first<br>    const toDelete = backupFiles.slice(0, backupFiles.length - maxBackups);<br>    for (const file of toDelete) {<br>      await FileSystem.deleteAsync(backupDir + file.filename, { idempotent: true });<br>    }<br>  }<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: listBackupFilesWithMeta<br><br>- **Responsibility**: Returns a list of BackupMeta objects for all valid backup files.<br>- **Signature**: `async listBackupFilesWithMeta(backupDir: string): Promise<BackupMeta[]>`<br><br>**Code:**<br>```typescript<br>async listBackupFilesWithMeta(backupDir: string): Promise<BackupMeta[]> {<br>  const files = await FileSystem.readDirectoryAsync(backupDir);<br>  const backupMeta: BackupMeta[] = [];<br>  for (const fname of files) {<br>    if (!fname.endsWith('.db')) continue;<br>    const timestamp = this.parseTimestampFromFilename(fname);<br>    if (timestamp == null) continue;<br>    backupMeta.push({<br>      filePath: backupDir + fname,<br>      timestamp: new Date(timestamp).toISOString(),<br>    });<br>  }<br>  return backupMeta;<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: saveBackupMetadata<br><br>- **Responsibility**: Serializes and writes backup metadata to SecureStore.<br>- **Signature**: `async saveBackupMetadata(meta: BackupMeta[], key: string): Promise<void>`<br><br>**Code:**<br>```typescript<br>async saveBackupMetadata(meta: BackupMeta[], key: string): Promise<void> {<br>  await SecureStore.setItemAsync(key, JSON.stringify(meta));<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: parseTimestampFromFilename<br><br>- **Responsibility**: Extracts numeric timestamp from backup filename, or returns null.<br>- **Signature**: `parseTimestampFromFilename(fname: string): number or null`<br><br>**Code:**<br>```typescript<br>parseTimestampFromFilename(fname: string): number or null {<br>  // Example: meditation-app-backup-2023-12-31T22-23-44-000Z.db<br>  const match = fname.match(/backup-(.*?)\.db$/);<br>  if (!match) return null;<br>  const iso = match[1].replace(/-/g, ':').replace(/T(\d+):(\d+):(\d+):(\d+)Z/, (m, h, m2, s, ms) =><br>    `T${h}:${m2}:${s}.${ms}Z`<br>  );<br>  const d = new Date(iso);<br>  return isNaN(d.valueOf()) ? null : d.valueOf();<br>}<br>```<br><br>--- |
| BackupConcurrencyFlagManager | - **[Offloading Class Names]**: BackupJobHandlerImpl<br>- **[Originating Method Ids]**: BKH-5<br><br>**Delegate State Owned:**<br>- Encapsulates the Zustand concurrency flag (`isBackupInProgress`).<br><br>**Delegate Responsibilities Owned:**<br>- Provides atomic check/set logic for backup/restore operation concurrency.<br>- Exposes a single method to check if a backup or restore is already in progress, set the flag if not, and provide UI feedback if busy.<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct state access and conditional logic for backup concurrency flag, including UI feedback dispatch.<br><br>**Delegate Public Interface:**<br>```typescript<br>class BackupConcurrencyFlagManager {<br>  handleConcurrentBackupOrRestoreAttempt(uiFeedback?: (msg: string) => void): Promise<boolean>;<br>  resetConcurrencyFlag(): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const concurrencyFlag = new BackupConcurrencyFlagManager();<br>if (!(await concurrencyFlag.handleConcurrentBackupOrRestoreAttempt(uiFeedback))) return;<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.handleConcurrentBackupOrRestoreAttempt<br><br>**Breakdown:**<br>- This method now simply calls the delegate, passing the UI feedback handler.<br><br>**Code:**<br>```typescript<br>async handleConcurrentBackupOrRestoreAttempt(): Promise<boolean> {<br>  return await this.concurrencyFlagManager.handleConcurrentBackupOrRestoreAttempt(uiFeedback);<br>}<br>```<br><br>---<br><br>#### üîß Delegate Method: handleConcurrentBackupOrRestoreAttempt<br><br>- **Responsibility**: Checks if backup/restore is in progress, shows UI feedback if busy, otherwise sets flag and returns true.<br>- **Signature**: `async handleConcurrentBackupOrRestoreAttempt(uiFeedback?: (msg: string) => void): Promise<boolean>`<br><br>**Code:**<br>```typescript<br>async handleConcurrentBackupOrRestoreAttempt(uiFeedback?: (msg: string) => void): Promise<boolean> {<br>  const { isBackupInProgress, setBackupInProgress } = useBackupConcurrencyStore.getState();<br>  if (isBackupInProgress) {<br>    if (uiFeedback) uiFeedback('Backup/restore in progress');<br>    return false;<br>  }<br>  setBackupInProgress(true);<br>  return true;<br>}<br>```<br><br>#### üîß Delegate Method: resetConcurrencyFlag<br><br>- **Responsibility**: Resets the concurrency flag for backup/restore operations.<br>- **Signature**: `resetConcurrencyFlag(): void`<br><br>**Code:**<br>```typescript<br>resetConcurrencyFlag(): void {<br>  useBackupConcurrencyStore.getState().setBackupInProgress(false);<br>}<br>```<br><br>--- |
| BackupEligibilityChecker | - **[Offloading Class Names]**: BackupJobHandlerImpl<br>- **[Originating Method Ids]**: BKH-6<br><br>**Delegate State Owned:**<br>- None; methods are pure and stateless.<br><br>**Delegate Responsibilities Owned:**<br>- Checks if backup is enabled in persisted settings AND that a backup does not already exist for today's date.<br>- Reads persisted flags and timestamps as needed.<br><br>**Responsibilities Removed from Parent Class:**<br>- Logic for cross-checking current settings and backup metadata to determine backup eligibility.<br><br>**Delegate Public Interface:**<br>```typescript<br>class BackupEligibilityChecker {<br>  checkBackupEligibility(): Promise<boolean>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const eligibility = new BackupEligibilityChecker();<br>if (await eligibility.checkBackupEligibility()) {<br>  // proceed with backup<br>}<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.checkBackupEligibility<br><br>**Breakdown:**<br>- This method now simply calls the delegate.<br><br>**Code:**<br>```typescript<br>async checkBackupEligibility(): Promise<boolean> {<br>  return await this.eligibilityChecker.checkBackupEligibility();<br>}<br>```<br><br>#### üîß Delegate Method: checkBackupEligibility<br><br>- **Responsibility**: Reads persisted `backupEnabled` from settings and checks SecureStore for last backup timestamp; returns true only if backup is enabled and no backup made today.<br>- **Signature**: `async checkBackupEligibility(): Promise<boolean>`<br><br>**Code:**<br>```typescript<br>async checkBackupEligibility(): Promise<boolean> {<br>  const backupEnabled = useSettingsStore.getState().settings.backupEnabled === true;<br>  if (!backupEnabled) return false;<br><br>  const lastBackupIso = await SecureStore.getItemAsync(LAST_BACKUP_TIMESTAMP_KEY);<br>  if (lastBackupIso) {<br>    const last = new Date(lastBackupIso);<br>    const now = new Date();<br>    if (<br>      last.getFullYear() === now.getFullYear() &&<br>      last.getMonth() === now.getMonth() &&<br>      last.getDate() === now.getDate()<br>    ) {<br>      return false; // Already backed up today<br>    }<br>  }<br>  return true;<br>}<br>```<br><br>--- |
| BackupJobHydrationManager | - **[Offloading Class Names]**: BackupJobHandlerImpl<br>- **[Originating Method Ids]**: BKH-12<br><br>**Delegate State Owned:**<br>- None; methods are transactionally scoped.<br><br>**Delegate Responsibilities Owned:**<br>- Performs all DB SELECTs for all domain entities after restore.<br>- Calls corresponding Zustand hydration actions for each entity (settings, diaries, session timers, logs).<br><br>**Responsibilities Removed from Parent Class:**<br>- All hydration code and SQL queries required to reload domain state into Zustand after a DB restore.<br><br>**Delegate Public Interface:**<br>```typescript<br>class BackupJobHydrationManager {<br>  reloadEntitiesFromRestoredDB(): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const hydrationManager = new BackupJobHydrationManager();<br>await hydrationManager.reloadEntitiesFromRestoredDB();<br>```<br><br>---<br><br>#### üîÅ Refactored Method: BackupJobHandlerImpl.reloadEntitiesFromRestoredDB<br><br>**Breakdown:**<br>- Parent simply calls the delegate; all SQL queries and hydration responsibilities are moved to the delegate.<br><br>**Code:**<br>```typescript<br>async reloadEntitiesFromRestoredDB(): Promise<void> {<br>  await this.hydrationManager.reloadEntitiesFromRestoredDB();<br>}<br>```<br><br>#### üîß Delegate Method: reloadEntitiesFromRestoredDB<br><br>- **Responsibility**: After DB restore, loads all domain entities (settings, diaries, timers, logs) from SQLite and hydrates respective Zustand slices.<br>- **Signature**: `async reloadEntitiesFromRestoredDB(): Promise<void>`<br><br>**Code:**<br>```typescript<br>async reloadEntitiesFromRestoredDB(): Promise<void> {<br>  const SQLite = require('expo-sqlite');<br>  const db = SQLite.openDatabase('meditation-app.db');<br><br>  // Settings<br>  await new Promise<void>((resolve, reject) => {<br>    db.transaction((tx: any) => {<br>      tx.executeSql(<br>        `SELECT * FROM Settings LIMIT 1;`,<br>        [],<br>        (_: any, result: any) => {<br>          if (result.rows.length) {<br>            const row = result.rows.item(0);<br>            const s: Settings = {<br>              theme: row.theme,<br>              adsFreePurchased: !!row.adsFreePurchased,<br>              dndEnabled: !!row.dndEnabled,<br>              backupEnabled: !!row.backupEnabled,<br>              keepScreenOn: !!row.keepScreenOn,<br>              countUp: !!row.countUp,<br>              sessionBackgroundImage: row.sessionBackgroundImage or "",<br>            };<br>            settingsStore.getState().setHydratedSettings(s);<br>          }<br>          resolve();<br>        },<br>        (_: any, error: any) => {<br>          reject(error);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br><br>  // Diary Entries<br>  await new Promise<void>((resolve, reject) => {<br>    db.transaction((tx: any) => {<br>      tx.executeSql(<br>        `SELECT timestamp, content FROM DiaryEntries;`,<br>        [],<br>        (_: any, result: any) => {<br>          const entries = [];<br>          for (let i = 0; i < result.rows.length; ++i) {<br>            const row = result.rows.item(i);<br>            entries.push({<br>              timestamp: row.timestamp,<br>              content: row.content,<br>            });<br>          }<br>          useDiaryStore.getState().setHydratedEntries(entries);<br>          resolve();<br>        },<br>        (_: any, error: any) => {<br>          reject(error);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br><br>  // SessionTimers<br>  await new Promise<void>((resolve, reject) => {<br>    db.transaction((tx: any) => {<br>      tx.executeSql(<br>        `SELECT * FROM SessionTimers;`,<br>        [],<br>        (_: any, result: any) => {<br>          const timers = [];<br>          for (let i = 0; i < result.rows.length; ++i) {<br>            timers.push(result.rows.item(i));<br>          }<br>          useTimerStateStore.getState().setSessionTimers(timers);<br>          resolve();<br>        },<br>        (_: any, error: any) => {<br>          reject(error);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br><br>  // Meditation Logs<br>  await new Promise<void>((resolve, reject) => {<br>    db.transaction((tx: any) => {<br>      tx.executeSql(<br>        `SELECT timestamp, duration FROM MeditationLogs;`,<br>        [],<br>        (_: any, result: any) => {<br>          const logs = [];<br>          for (let i = 0; i < result.rows.length; ++i) {<br>            logs.push({<br>              timestamp: result.rows.item(i).timestamp,<br>              duration: result.rows.item(i).duration,<br>            });<br>          }<br>          useLogStateStore.getState().setHydratedLogs(logs);<br>          resolve();<br>        },<br>        (_: any, error: any) => {<br>          reject(error);<br>          return false;<br>        }<br>      );<br>    });<br>  });<br>}<br>```<br><br>---<br><br>End of report. |
| ApplicationRuntimeBootstrapper | Orchestrates the initial application-level runtime wiring and dependency readiness, ensuring all primary state stores and singleton services are properly instantiated and their dependencies are available before any React component or service accesses them. Ensures all required dependency injection contracts, store slices, and framework initialization are performed before the app renders and before any component invokes its own lifecycle or binding logic. |

### Component Methods definition:
| Component Name | Signature | Description | Implementation Details |
| -------------- | --------- | ----------- | ---------------------- |
| AppBootManager | checkAndRestoreSessionState(): Promise<void> | Called during application initialization (typically from a root-level `useEffect`). This method queries SQLite and/or the persisted Zustand store for any record of an interrupted or in-progress meditation session. If found, it loads all relevant session state (timer positions, segment index, audio playback position, and full session blueprint) into Zustand, explicitly sets session state to `'paused'`, and restores all timers and audio states accordingly. It then uses React Navigation to present the Meditation Session Window in the paused state. All restored data must conform to the `SessionTimer` and associated runtime session structures as described in the Static Report. Data from storage must be validated for integrity before use; on failure, the state is not loaded and the user is presented with the normal app entry. | AppBootManager.checkAndRestoreSessionState:<br>- **Mechanics**:<br>  1. On application initialization (e.g., in `useEffect` at app root), call this method.<br>  2. Query both:<br>      - SQLite (via `expo-sqlite`) for any record indicating an interrupted or in-progress meditation session (fields: timer positions, segment index, audio playback position, session timer blueprint, etc.).<br>      - Zustand persisted store (in case state is held there) for in-progress session object.<br>  3. If either source contains a valid, non-empty session state:<br>      - Validate that all required fields are present (timer positions, segment index, session blueprint match the expected schema).<br>      - If invalid or incomplete, abort recovery (do NOT restore or mutate state).<br>  4. If valid session state is found:<br>      - Load all session state into Zustand:<br>        - Set session state to `'paused'` (regardless of previous state).<br>        - Restore timer positions, segment index, audio playback state/position.<br>        - Ensure the full session blueprint (all segment and sound config) is set.<br>      - (If timers or audio components are managed via local state in the session window, pass these as navigation params or have the session window subscribe to Zustand.)<br>      - Use React Navigation to set initial route to MeditationSessionWindow, passing params or relying on subscribed Zustand state.<br>  5. If no valid session is found, allow normal app entry (e.g., do nothing, proceed to Main Screen).<br>- **Edge Cases**:<br>  - If data is corrupt, incomplete, or fails schema validation, do not restore (fail gracefully).<br>  - Only restore sessions that are truly in-progress (not completed or terminated).<br>- **Side Effects**:<br>  - Zustand state transition for session.<br>  - Navigation to Meditation Session Window if restoration occurs.<br>- **Invariants**:<br>  - Never partially restore or mutate state if data is invalid.<br>  - Timers/audio must reflect accurate elapsed/remaining time as of interruption.<br>- **Performance**:<br>  - Query and restore should be performed during app boot; no hard real-time constraint, but should complete before user interaction is possible.<br>- **Pseudocode Example**:<br>    ```typescript<br>    async function checkAndRestoreSessionState() {<br>      const session = await loadSessionFromSQLiteOrZustand();<br>      if (session && validateSession(session)) {<br>        zustandStore.session.setAll(session);<br>        zustandStore.session.setState('paused');<br>        navigation.reset({<br>          index: 0,<br>          routes: [{ name: 'MeditationSessionWindow', params: {} }]<br>        });<br>      }<br>      // else do nothing, normal app entry<br>    }<br>    ```<br><br>--- |
| AppBootManager | hydrateSettingsStore(): Promise<void> | Executed during app launch, this method loads persisted settings from either AsyncStorage, SecureStore, or SQLite. The method must parse stored data and, if all required fields are present and valid (according to the `Settings` interface), applies the settings to the Zustand store via `SettingsStore.setHydratedSettings(settings)`. If missing or corrupt data is detected, it delegates to `handleCorruptSettingsData()`. Data is validated against the `Settings` type from the Static Report before being set, ensuring all fields are present and have appropriate types. | AppBootManager.hydrateSettingsStore:<br>- **Mechanics**:<br>  1. On app launch/init, call this method.<br>  2. Attempt to load settings from persistent storage:<br>      - First check AsyncStorage, SecureStore, or SQLite (in that order or as configured).<br>      - Read the entire settings object (must match the `Settings` interface).<br>  3. Parse the loaded data:<br>      - Ensure every required field per the `Settings` structure is present.<br>      - Check each field for correct type (e.g., booleans for toggles, strings for theme, etc.).<br>  4. If all fields are present and valid:<br>      - Call `SettingsStore.setHydratedSettings(settings)` to apply to Zustand.<br>  5. If any field is missing, corrupt, or type-invalid:<br>      - Call `handleCorruptSettingsData()` to apply defaults and trigger user notification.<br>  6. Never persist or apply partial/corrupt data to Zustand.<br>- **Edge Cases**:<br>  - Missing storage key ‚Üí call defaults.<br>  - Malformed or partial object ‚Üí call defaults.<br>- **Side Effects**:<br>  - Zustand state updated on valid parse; else, fallback/defaults triggered.<br>  - No user-visible effect unless data is invalid (in which case, handled by next method).<br>- **Pseudocode Example**:<br>    ```typescript<br>    async function hydrateSettingsStore() {<br>      const raw = await loadSettingsFromStorage();<br>      if (isValidSettings(raw)) {<br>        SettingsStore.setHydratedSettings(raw);<br>      } else {<br>        this.handleCorruptSettingsData();<br>      }<br>    }<br>    ```<br><br>--- |
| AppBootManager | handleCorruptSettingsData(): void | Invoked if settings hydration detects missing/corrupt data. This method applies hardcoded default values (per the `Settings` structure) to the Zustand store using `SettingsStore.setDefaults()`. It also triggers a React Native Paper Snackbar or Dialog to inform the user. The method ensures that the app continues with a valid, default settings state and avoids persisting any invalid/corrupt data. | AppBootManager.handleCorruptSettingsData:<br>- **Mechanics**:<br>  1. Call `SettingsStore.setDefaults()` to set all default settings values as per the `Settings` interface (hardcoded or from a defaults constant).<br>  2. Trigger a React Native Paper Snackbar or Dialog to inform the user: e.g., "Settings were reset due to missing or corrupt configuration."<br>  3. Ensure that the app does not persist any previous, invalid/corrupted state.<br>  4. All subsequent app logic runs on this default settings.<br>- **Edge Cases**:<br>  - If Dialog/Snackbar fails, app should still proceed with defaults.<br>- **Pseudocode Example**:<br>    ```typescript<br>    function handleCorruptSettingsData() {<br>      SettingsStore.setDefaults();<br>      showSnackbar("Settings were reset due to missing or corrupt configuration.");<br>    }<br>    ```<br><br>--- |
| AppBootManager | handleAppStartOrResume(state: AppStateStatus): Promise<void> | Triggered on app launch or resume (via `AppState.addEventListener`). Reads notification and Session Timer reminder state from SQLite by calling `NotificationManager.loadAllRemindersFromDB()`. It then calls `NotificationManager.syncScheduledNotifications()` to ensure all enabled reminders in SQLite have a corresponding scheduled notification in expo-notifications. For any reminder missing a scheduled notification, it schedules it via `NotificationManager.scheduleReminder(timerId, reminderData)`. Finally, it updates Zustand with the latest settings and Session Timer/notification state. All loaded or updated data must match the validation rules of `NotificationRecord` and `Settings` as per the Static Report. | AppBootManager.handleAppStartOrResume:<br>- **Mechanics**:<br>  1. On app boot or resume, call this method (bound to AppState event).<br>  2. Call `NotificationManager.loadAllRemindersFromDB()`:<br>      - Pull all Session Timer reminders from SQLite, returning as `NotificationRecord[]`.<br>  3. Call `NotificationManager.syncScheduledNotifications()`:<br>      - For each reminder loaded, ensure it is scheduled in expo-notifications.<br>      - If a reminder is not yet scheduled (discrepancy between DB and system notifications), call `NotificationManager.scheduleReminder(timerId, reminderData)` for each missing one.<br>  4. After all reminders are synced:<br>      - Update Zustand with the latest notification record state.<br>      - Optionally, call `SettingsPersistenceDelegate.getSettings()` to ensure settings are up to date (if not already hydrated).<br>      - Optionally, also reload SessionTimer list if needed.<br>  5. Ensure all data loaded or scheduled matches domain validation rules (invalid records are skipped or corrected, not persisted).<br>- **Edge Cases**:<br>  - If a reminder fails to schedule, handle error (log if allowed; otherwise, skip).<br>  - If notification data in DB is invalid, skip and continue.<br>- **Performance**:<br>  - Should complete promptly on app boot/resume.<br>- **Pseudocode Example**:<br>    ```typescript<br>    async function handleAppStartOrResume(state) {<br>      const reminders = await NotificationManager.loadAllRemindersFromDB();<br>      await NotificationManager.syncScheduledNotifications(reminders);<br>      SettingsStore.refresh();<br>    }<br>    ```<br><br>--- |
| AppBootManager | unregisterBackupJob(): Promise<void> | Called when the app's backup feature is toggled off or the app is uninstalled. This method unregisters any scheduled background backup jobs by calling `BackgroundFetch.unregisterTaskAsync()` (Expo background-fetch/task-manager API), using the unique task name. No further data handling is necessary, but the method must ensure the flag in persistent storage is updated if relevant. | AppBootManager.unregisterBackupJob:<br>- **Mechanics**:<br>  1. When backup is toggled off or app is uninstalling, call this method.<br>  2. Call `BackgroundFetch.unregisterTaskAsync()` (Expo API) with the backup job's unique task name.<br>  3. (If persistent storage is used for the backupEnabled flag, update it to reflect `false`.)<br>  4. No further actions or UI updates are needed; Expo handles the job teardown.<br>- **Failure Modes**:<br>  - If API call fails, optionally retry or alert, but not required.<br>- **Pseudocode Example**:<br>    ```typescript<br>    async function unregisterBackupJob() {<br>      await BackgroundFetch.unregisterTaskAsync('BackupJob');<br>      await persistSetting('backupEnabled', false);<br>    }<br>    ```<br><br>--- |
| AppBootManager | registerBackupJob(): Promise<void> | Called on app boot or when the backup toggle is enabled. Reads the value of the `backupEnabled` flag from `SettingsStore`. If enabled, it registers the backup job using `BackgroundFetch.registerTaskAsync()` and associates it with the defined backup handler. If disabled, it unregisters the task with `BackgroundFetch.unregisterTaskAsync()`. The method must ensure persistent storage is updated so the current setting is reflected on next boot. No backup is performed directly in this method; it only manages job registration/unregistration. | AppBootManager.registerBackupJob:<br>- **Mechanics**:<br>  1. On app boot or when backup toggle is enabled, call this method.<br>  2. Read the `backupEnabled` flag from `SettingsStore`.<br>  3. If `backupEnabled` is true:<br>      - Call `BackgroundFetch.registerTaskAsync()` with the unique task name and handler (which is defined via `TaskManager.defineTask` elsewhere).<br>      - Ensure persistent storage/setting reflects `true`.<br>  4. If `backupEnabled` is false:<br>      - Call `BackgroundFetch.unregisterTaskAsync()` with the task name.<br>      - Ensure persistent storage/setting reflects `false`.<br>  5. No backup is performed here; only registration/unregistration.<br>- **Edge Cases**:<br>  - If already registered/unregistered, Expo handles idempotence.<br>- **Pseudocode Example**:<br>    ```typescript<br>    async function registerBackupJob() {<br>      const enabled = SettingsStore.getState().backupEnabled;<br>      if (enabled) {<br>        await BackgroundFetch.registerTaskAsync('BackupJob', options);<br>        await persistSetting('backupEnabled', true);<br>      } else {<br>        await BackgroundFetch.unregisterTaskAsync('BackupJob');<br>        await persistSetting('backupEnabled', false);<br>      }<br>    }<br>    ```<br><br>--- |
| NavigationLayer | navigateToSessionTimer(timerId: string): void | Called by `NotificationManager.handleNotificationResponse(response)` when a notification is tapped. Uses React Navigation to navigate to the screen responsible for displaying or editing the Session Timer, passing the `timerId` as a navigation parameter. The navigation parameter must be a valid Session Timer ID as per domain model (`string`, PK in SQLite). |  |
| TimerStateStore | handleNameUniquenessResult(result: SQLResultSet): void | Called by the expo-sqlite SELECT query result callback during Session Timer save. It parses the result to check for a timer with the same name. If a duplicate is found, updates the error state in Zustand for the SessionTimerForm, which triggers the UI to show an inline error message. If no duplicate is found, allows the save process to continue. The method expects the SQL result to match the schema for Session Timers, and the error state must be set such that UI helpers (React Native Paper's `HelperText`) can consume it. |  |
| TimerStateStore | handleSqlMutationComplete(result: SQLResultSet): Promise<void> | Invoked by the expo-sqlite mutation (insert/update/delete) success callback. Reloads the entire list of Session Timers from SQLite, parses the results into `SessionTimer[]` (conforming to the domain model), and updates Zustand with this list. This ensures the in-memory and persistent state are consistent and UI components reactively rerender. Any transformation (e.g., parsing segments JSON from SQLite) must ensure interface compatibility. |  |
| TimerStateStore | handleSqlMutationError(error: SQLError): void | Called when a SQLite mutation (insert, update, or delete) fails. Receives the error object and sets a `mutationError` state in Zustand (of type `string` or similar), leaving other state unchanged. The UI (typically the SessionTimerForm) observes this error state and displays a React Native Paper Dialog or Snackbar. The method ensures that no partial state is applied and that the user's input is preserved for correction and re-submission. |  |
| TimerStateStore | saveSessionTimer(timer: SessionTimer): Promise<void> | <br><br>`saveSessionTimer(timer: SessionTimer): Promise<void>`<br><br>This method now orchestrates the entire process of saving or updating a SessionTimer entity by delegating all business validation, persistence, and notification/reminder coordination to its internal delegates. It performs the following steps:<br><br>1. **Validation**: Calls `this.sessionTimerValidator.validate(timer)` to fully validate the provided timer. If invalid, records the returned error map in local state and throws a `TypeError` immediately.<br>2. **Persistence**: Calls `this.sessionTimerRepo.save(timer)` to persist the timer to SQLite (insert or update). All SQL, field serialization, and atomicity are handled by the delegate; this method propagates any thrown errors.<br>3. **Reminders**: After successful persistence, calls `this.sessionTimerReminderCoordinator.syncRemindersForSave(timer)` to schedule, update, or cancel any reminders according to the timer's configuration.<br>4. **State Update**: After all above steps succeed, refreshes the in-memory timer list from the database by calling `this.sessionTimerRepo.getAll()` and updating Zustand state accordingly. Any errors at any step (validation, persistence, reminders) are surfaced to the UI via error state or thrown.<br><br>All field-by-field logic, SQLite queries, and notification management are now strictly delegated. This method is only responsible for orchestration, state update, and error propagation.<br><br>**Code Example:**<br><br>```typescript<br>public async saveSessionTimer(timer: SessionTimer): Promise<void> {<br>    const { valid, errors } = this.sessionTimerValidator.validate(timer);<br>    this.set({ validationError: valid ? null : errors });<br>    if (!valid) {<br>        throw new TypeError('SessionTimer validation failed');<br>    }<br>    await this.sessionTimerRepo.save(timer);<br>    await this.sessionTimerReminderCoordinator.syncRemindersForSave(timer);<br>    const timers = await this.sessionTimerRepo.getAll();<br>    this.set({ sessionTimers: timers });<br>}<br>```<br><br> |  |
| TimerStateStore | deleteSessionTimer(timerId: string): Promise<void> | <br><br>`deleteSessionTimer(timerId: string): Promise<void>`<br><br>This method now orchestrates the atomic deletion of a SessionTimer entry by delegating reminder cancellation and database removal to its internal delegates:<br><br>1. **Reminder Cancellation**: Calls `this.sessionTimerReminderCoordinator.clearRemindersForDelete(timerId)` to cancel and fully remove any scheduled notifications and notification records for this timer. This ensures no reminders remain before timer deletion.<br>2. **Persistence (Delete)**: Calls `this.sessionTimerRepo.delete(timerId)` to atomically remove the timer record from SQLite. Any database error is propagated.<br>3. **State Update**: After deletion, reloads all SessionTimers from the database via `this.sessionTimerRepo.getAll()` and updates Zustand state.<br><br>All direct notification, SQL, and state consistency logic is now owned by the delegates. This method only orchestrates the overall delete-and-cleanup flow.<br><br>**Code Example:**<br><br>```typescript<br>public async deleteSessionTimer(timerId: string): Promise<void> {<br>    await this.sessionTimerReminderCoordinator.clearRemindersForDelete(timerId);<br>    await this.sessionTimerRepo.delete(timerId);<br>    const timers = await this.sessionTimerRepo.getAll();<br>    this.set({ sessionTimers: timers });<br>}<br>```<br><br> |  |
| TimerStateStore | resetDraftState(): void | <br><br>`resetDraftState(): void`<br><br>This method now resets the draft session timer state by using the delegate to determine whether to clear or restore from the last persisted value:<br><br>1. Looks up the last persisted timer matching the current draft (if any) from `this.sessionTimers`.<br>2. Calls `this.sessionTimerDraftManager.resetDraft(lastPersisted)` to obtain the updated draft state (either a clone of existing or null for new).<br>3. Updates Zustand with the returned draft value and clears any validation errors.<br><br>No draft field logic or decision-making remains in this method; all detailed reset behavior is owned by the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public resetDraftState(): void {<br>    const state = this.get();<br>    const lastPersisted = state.sessionTimers.find(t => t.id === state.draftSessionTimer?.id);<br>    const draft = this.sessionTimerDraftManager.resetDraft(lastPersisted);<br>    this.set({ draftSessionTimer: draft, validationError: null });<br>}<br>```<br><br> |  |
| TimerStateStore | loadSessionTimer(timerId: string): Promise<SessionTimer or null> | <br><br>`loadSessionTimer(timerId: string): Promise<SessionTimer or null>`<br><br>This method now loads a SessionTimer object from SQLite solely by delegating to the repository and updating state:<br><br>1. Calls `this.sessionTimerRepo.getById(timerId)` to retrieve and deserialize a SessionTimer domain object for the provided ID.<br>2. Updates Zustand with the loaded timer, either as the current draft or as appropriate for the parent workflow.<br>3. Returns the loaded timer object or `null` as returned by the delegate.<br><br>All SQL, field parsing, and domain mapping are owned by the delegate. No parsing or conversion is present in the parent.<br><br>**Code Example:**<br><br>```typescript<br>public async loadSessionTimer(timerId: string): Promise<SessionTimer or null> {<br>    const timer = await this.sessionTimerRepo.getById(timerId);<br>    if (timer) {<br>        this.set({ draftSessionTimer: { ...timer } });<br>    }<br>    return timer;<br>}<br>```<br><br>--- |  |
| SessionTimerForm | handleNameChange(value: string): void | Bound to the `onChangeText` prop of the Name TextInput. Receives the new value, updates the name property in the local/draft form state in Zustand, then triggers live validation according to the SessionTimer validation schema. Any validation errors are set in local or Zustand error state, which drives UI feedback (e.g., error message via Paper's `HelperText`). No further actions or side effects are performed. |  |
| SessionTimerForm | handlePreparationTimeChange(value: number): void | Bound to the `onValueChange` event of the Preparation Time Picker. Updates the preparationTime property in the draft form state in Zustand and triggers validation. Any validation errors are updated so UI can display feedback. The value must be an integer ‚â• 0. No persistence or side effect occurs at this stage. |  |
| SessionTimerForm | handleSegmentationSoundPress(): void | <br><br>`handleSegmentationSoundPress(): void`<br><br>This handler is now solely responsible for invoking the delegate to open the sound picker dialog. There is no inline file picker logic or type configuration. The delegate takes as arguments the handler for result (`handleSoundPicked`) and the handler for cancel (`handleSoundPickerCancel`). All result normalization and error/cancel handling is performed by the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public async handleSegmentationSoundPress(): Promise<void> {<br>    await this.filePickerHelper.pickSegmentationSound(this.handleSoundPicked, this.handleSoundPickerCancel);<br>}<br>```<br><br> |  |
| SessionTimerForm | handleSegmentationRepeatChange(value: number): void | Bound to the repetition count selector's `onValueChange` event. Updates the segmentationSound.repetition property in draft Zustand state and runs validation (must be integer 1‚Äì3). Any error state is updated for UI feedback. No persistence occurs at this stage. |  |
| SessionTimerForm | handleSegmentationVolumeChange(value: number): void | Called by the volume slider's `onValueChange`. Updates the segmentationSound.volume in draft Zustand state and validates (integer 0‚Äì5). Validation errors are surfaced for UI helpers. No side effects beyond local state update and validation. |  |
| SessionTimerForm | handleMeditationSoundSourceChange(value: SoundOrigin): void | Bound to the meditation sound source picker. Clears any previous sound selection, sets the new sound origin (`'system'` or `'user_file'`) in Zustand, and conditionally renders dependent UI controls based on state. No side effects or persistence here; ensures form state is consistent for further selections. |  |
| SessionTimerForm | handleMeditationSoundSelectorPress(): void | <br><br>`handleMeditationSoundSelectorPress(): void`<br><br>This handler now delegates sound selection based on the current sound origin to the file picker delegate. The delegate receives the sound origin, a result handler, and a cancel handler.<br><br>**Code Example:**<br><br>```typescript<br>public async handleMeditationSoundSelectorPress(): Promise<void> {<br>    await this.filePickerHelper.pickMeditationSound(this.localForm.meditationSound.origin, this.handleSoundPicked, this.handleFilePickerCancel);<br>}<br>```<br><br> |  |
| SessionTimerForm | handleMeditationRepeatTypeChange(value: 'forever' or 'count'): void | Bound to the repetition type RadioButton.Group. Updates the repeat type in draft Zustand state. If `'count'`, conditionally reveals repeat count input; otherwise hides it. All logic is local to form state and UI rendering. |  |
| SessionTimerForm | handleMeditationRepeatCountChange(value: number): void | Triggered by the stepper input for repeat count. Updates the meditationSound.repetitionCount in Zustand and validates (must be integer ‚â• 1 if repetitionType is `'count'`). Error state is updated for UI feedback. No persistence or side effects. |  |
| SessionTimerForm | handleMeditationVolumeChange(value: number): void | Called by the meditation volume slider. Updates meditationSound.volume in Zustand and validates (0‚Äì5). Validation errors update UI error displays as needed. |  |
| SessionTimerForm | handleAddSegmentPress(): void | Triggered by the "Add Segment" button. Checks current segment count in Zustand; if less than 4, appends a new segment object. If count reaches 4, disables the "Add Segment" button. Updates draft form state and triggers React re-render. No persistence occurs. |  |
| SessionTimerForm | handleSegmentDurationChange(idx: number, value: number): void | Bound to each segment duration input. Updates the corresponding segment's duration in Zustand and validates (must be integer ‚â• 1). Any error is tied to the specific segment and surfaced in the UI. All changes are local to draft state. |  |
| SessionTimerForm | handleRemoveSegmentPress(idx: number): void | Triggered by the remove icon in a segment box. Removes the segment at index `idx` from the segments array in Zustand, ensuring at least one segment remains. If count drops below 4, re-enables the "Add Segment" button. Updates draft form state and UI. |  |
| SessionTimerForm | handleDailyReminderToggle(value: boolean): void | Bound to the Daily Reminder Switch's `onValueChange`. Updates the dailyReminderEnabled property in draft Zustand state. If enabled, reveals the time picker; if disabled, clears reminderTime and hides the picker. All updates are local to draft state and UI; no persistence or notification scheduling occurs here. |  |
| SessionTimerForm | handleReminderTimeChange(value: string): void | Bound to the reminder time picker. Takes a `value` in the form `"HH:mm"`, validates the format and logical value (not in the past if relevant), and saves to Zustand. Any validation error is surfaced for UI feedback. No persistence or notification scheduling at this step. |  |
| SessionTimerForm | handleEnableDiaryToggle(value: boolean): void | Purpose:  Handles the toggling of the "Enable Diary Note" switch in the Session Timer form. <br>  Data Handling:  Receives a boolean indicating the current switch state (`value`). Updates Zustand‚Äôs `sessionForm` slice by calling `zustandStore.sessionForm.setEnableDiary(value)`, thereby updating the draft SessionTimer‚Äôs `enableDiaryNote` field. Triggers UI to show or hide any diary-related options reactively. No validation required as the value is simply a boolean; ensures immediate in-memory state update only. Does not commit to SQLite or persist until the form is explicitly saved. |  |
| SessionTimerForm | handleBackPress(): void | Purpose:  Handles the event when the top-left Back IconButton is pressed on the Session Timer form. <br>  Data Handling:  Calls `zustandStore.sessionForm.hasUnsavedChanges()` to check for unsaved modifications in the current draft. If there are unsaved changes, sets a local UI state variable to show a React Native Paper Dialog prompting the user to Save or Discard. If no changes, calls `navigation.goBack()` to navigate away. Responsible for gating navigation according to unsaved edit state, and fully manages dialog visibility and user responses. No data is written or committed in this method; only validation of edit state and navigation logic. |  |
| SessionTimerForm | handleCancelPress(): void | Purpose:  Handles the pressing of the "Cancel" button on the Session Timer form. <br>  Data Handling:  Calls `TimerStateStore.resetDraftState()` (or equivalent) to reset the in-progress Session Timer draft in Zustand to its initial or last persisted state. If unsaved changes exist, may display a warning dialog (if implemented). Does not persist any changes to SQLite or update global Zustand stores outside draft session. Calls `navigation.goBack()` to exit the form. No permanent data mutation or notification actions are performed. |  |
| SessionTimerForm | handleDeletePress(): void | Purpose:  Initiates the deletion flow for a Session Timer. <br>  Data Handling:  When invoked (by pressing the Top-Right Delete IconButton in Edit mode), sets a local UI state to display a deletion confirmation dialog (`Dialog.visible = true`). Does not modify any persistent or in-memory data structures or trigger side effects at this point. Responsibility is to manage UI state for the dialog only, deferring actual deletion logic until confirmation. |  |
| SessionTimerForm | handleDeleteConfirm(): Promise<void> | <br><br>`handleDeleteConfirm(): Promise<void>`<br><br>This method now orchestrates the deletion of a session timer, ensuring all reminders are cancelled and the timer is deleted atomically via the persistence helper delegate:<br><br>1. Calls `this.persistenceHelper.deleteAndCancelReminders` with the current timer ID, the store deletion method, and the notification manager.<br>2. On delegate success, closes the dialog and navigates away.<br>3. On error (from delegate), sets the error dialog for UI display.<br><br>All coordination of reminder cancellation, deletion sequence, and error propagation is handled within the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public async handleDeleteConfirm(): Promise<void> {<br>    this.setIsLoading(true);<br>    try {<br>        await this.persistenceHelper.deleteAndCancelReminders(<br>            this.localForm.id,<br>            this.deleteSessionTimer,<br>            this.notificationManager<br>        );<br>        this.setDeleteDialogVisible(false);<br>        this.navigation.goBack();<br>    } catch (err: any) {<br>        this.setErrorDialog(err.message or 'Failed to delete Session Timer.');<br>    } finally {<br>        this.setIsLoading(false);<br>    }<br>}<br>```<br><br> |  |
| SessionTimerForm | handleDeleteCancel(): void | Purpose:  Handles the user pressing Cancel in the Delete Confirmation Dialog. <br>  Data Handling:  Sets the local UI state to hide the confirmation dialog (`Dialog.visible = false`). Does not perform any data mutation, deletion, or navigation. Only manages dialog visibility in the UI layer. |  |
| SessionTimerForm | handleUnsavedChangesSave(): Promise<void> | Purpose:  Handles the Save action from the Unsaved Changes Dialog. <br>  Data Handling:  1. Calls `SessionTimerForm.validateSessionForm()` to validate all current form fields against the domain model validation rules (Static Report), including names, times, segment arrays, sound configs, etc. 2. If validation passes, calls `TimerStateStore.saveSessionTimer(formData): Promise<void>` to insert or update the Session Timer in SQLite (atomic transaction), including reminder settings if present. 3. On success, updates Zustand to reflect persisted data and calls `navigation.goBack()` to exit form. 4. If error occurs (validation or persistence), displays error dialog and does not exit or commit any changes. Responsibility includes data transformation from form UI to the full SessionTimer model, strict adherence to interfaces, and propagation of success or failure via UI state. |  |
| SessionTimerForm | handleUnsavedChangesDiscard(): void | Purpose:  Handles discarding unsaved form changes after user selection in the Unsaved Changes Dialog. <br>  Data Handling:  Calls `zustandStore.sessionForm.resetToInitial()` (or equivalent) to revert the draft Session Timer in Zustand to initial (blank or last saved) values. Then calls `navigation.goBack()` to close the editor. Does not persist changes or trigger notification actions. Resets only in-memory (transient) state. |  |
| SessionTimerForm | handleSavePress(): Promise<void> | <br><br>`handleSavePress(): Promise<void>`<br><br>This method now orchestrates transactional saving and notification coordination flows entirely through the persistence helper delegate:<br><br>1. Calls `this.persistenceHelper.saveAndSchedule` with the current form state, the store save method, and the notification manager.<br>2. On delegate success, navigates away.<br>3. On error (from delegate), sets the error dialog for UI display.<br><br>All field validation, transactional sequencing, and error/rollback logic is now handled within the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public async handleSavePress(): Promise<void> {<br>    this.setIsLoading(true);<br>    try {<br>        await this.persistenceHelper.saveAndSchedule(<br>            this.localForm,<br>            this.saveSessionTimer,<br>            this.notificationManager<br>        );<br>        this.navigation.goBack();<br>    } catch (err: any) {<br>        this.setErrorDialog(err.message or 'Failed to save Session Timer.');<br>    } finally {<br>        this.setIsLoading(false);<br>    }<br>}<br>```<br><br> |  |
| SessionTimerForm | handleSoundPicked(selection: { uri: string, name?: string, ... }): void | <br><br>`handleSoundPicked(selection: { uri: string, name?: string, ... }): void`<br><br>This method is now a pure handler for picker results; the delegate ensures that normalization and URI pattern are valid before this is called. This method updates Zustand draft state with the selected sound.<br><br>**Code Example:**<br><br>```typescript<br>public handleSoundPicked(selection: { uri: string, name?: string }): void {<br>    this.zustandStore.sessionForm.setSound(selection);<br>}<br>```<br><br> |  |
| SessionTimerForm | handleFilePicked(fileUri: string): void | <br><br>`handleFilePicked(fileUri: string): void`<br><br>This method is now a pure handler for file picker results; the delegate ensures that fileUri is a non-empty, valid string. This method updates Zustand draft state.<br><br>**Code Example:**<br><br>```typescript<br>public handleFilePicked(fileUri: string): void {<br>    this.zustandStore.sessionForm.setFile(fileUri);<br>}<br>```<br><br> |  |
| SessionTimerForm | handleSoundPickerCancel(): void | <br><br>`handleSoundPickerCancel(): void`<br><br>This method is now a pure no-op, always invoked by the delegate if the user cancels the sound picker. No state is changed.<br><br>**Code Example:**<br><br>```typescript<br>public handleSoundPickerCancel(): void {<br>    // No-op: required contract, intentionally empty.<br>}<br>```<br><br> |  |
| SessionTimerForm | handleFilePickerCancel(): void | <br><br>`handleFilePickerCancel(): void`<br><br>This method is now a pure no-op, always invoked by the delegate if the user cancels the file picker. No state is changed.<br><br>**Code Example:**<br><br>```typescript<br>public handleFilePickerCancel(): void {<br>    // No-op: required contract, intentionally empty.<br>}<br>```<br><br>--- |  |
| MainScreen | handleCalendar(): void | Purpose:  Handles the Calendar button press on the Main Screen. <br>  Data Handling:  Calls `navigation.navigate('CalendarView')` (React Navigation API) to switch to the Calendar View screen. No data is passed or transformed; navigation only. Any required state for CalendarView is retrieved from the relevant stores upon mounting that screen. |  |
| MainScreen | renderAdBanner(): React.ReactNode | <br><br>`renderAdBanner(): React.ReactNode`<br><br>This method no longer contains any logic or state for ad banner visibility or event binding. Instead, it returns the result of calling the `MainScreenAdBannerRenderer` delegate, passing `adsFreePurchased` and any event handlers as needed.<br><br>**Code Example:**<br><br>```typescript<br>public renderAdBanner(): React.ReactNode {<br>    return MainScreenAdBannerRenderer({ adsFreePurchased: this.settings.adsFreePurchased });<br>}<br>```<br><br> |  |
| MainScreen | handleSnackbarAction(event: 'dismiss' or 'retry'): void | **Purpose:** Handles user actions on the error Snackbar/Dialog on the Main Screen. <br> **Data Handling:** If `event` is `'dismiss'`, sets error visibility state to `false` in local state or Zustand, hiding the Snackbar/Dialog. If `event` is `'retry'`, re-invokes the original failed operation (typically by calling `MainScreen.loadSessionTimers()`). Does not mutate any global data structures directly except for error visibility and possible re-triggering of data load logic. Ensures the Snackbar/Dialog is fully dismissed or the error operation is retried as appropriate. |  |
| MainScreen | handleHardwareBackPress(): boolean | Purpose:  Handles the Android system hardware back button event on the Main Screen. <br>  Data Handling:  If the Main Screen is in focus, calls `BackHandler.exitApp()` to close the application and returns `true` to signal the event is handled. If not in focus, allows default React Navigation back stack behavior. No data transformations; acts as a gatekeeper for application-exit logic per Android platform. |  |
| MainScreen | loadSessionTimers(): Promise<void> | Purpose:  Loads all Session Timers from SQLite on Main Screen mount/refresh. <br>  Data Handling:  Executes a `SELECT` query via expo-sqlite to retrieve all SessionTimer records, transforms database rows into an array of `SessionTimer` domain model objects (as per Static Report, mapping DB fields and deserializing segments JSON). Updates Zustand TimerStateStore by calling `setSessionTimers(resultRows)` with the transformed data. If an error occurs, triggers error handler (updates error state, surfaces Snackbar/Dialog). If no timers are found, triggers empty state UI logic. Ensures all timers have unique IDs matching the domain model definition. Does not handle draft state. | **HOW to implement `loadSessionTimers()`**<br><br>- **Alignment**: Description matches the Problem Statement.<br>- **Step-by-step:**<br>  1. Initiate a database read using Expo SQLite:<br>     - Start a transaction: `db.transaction((tx) => { ... })`<br>     - Execute SQL: `tx.executeSql('SELECT * FROM SessionTimers', [], successCallback, errorCallback)`<br>  2. In `successCallback`:<br>     - For each row in the result set:<br>       - Map DB fields to the `SessionTimer` domain object.<br>       - If any fields like segments are stored as JSON strings, deserialize (`JSON.parse(row.segments)`).<br>     - Collect all objects into an array.<br>     - Enforce unique IDs: filter out duplicate `id` values (e.g., using a Set or a `.filter()` pass).<br>     - Call Zustand store action: `setSessionTimers(arrayOfSessionTimerObjects)`.<br>  3. If no timers found (result set is empty):<br>     - Ensure Zustand has an empty array, which will show the empty state in the UI.<br>  4. In `errorCallback`:<br>     - Set error state locally (e.g., `setErrorVisible(true)`), so a Snackbar/Dialog appears as per error handling logic.<br>  5. Does not update or touch draft/tentative session timer state.<br>- **Pseudocode:**<br>  ```typescript<br>  function loadSessionTimers(): Promise<void> {<br>    return new Promise((resolve, reject) => {<br>      db.transaction(tx => {<br>        tx.executeSql(<br>          'SELECT * FROM SessionTimers',<br>          [],<br>          (txObj, { rows }) => {<br>            const timers = [];<br>            const seenIds = new Set();<br>            for (let i = 0; i < rows.length; i++) {<br>              const row = rows.item(i);<br>              if (!seenIds.has(row.id)) {<br>                seenIds.add(row.id);<br>                timers.push({<br>                  ...row,<br>                  segments: JSON.parse(row.segments),<br>                  // Map any other fields needed<br>                });<br>              }<br>            }<br>            setSessionTimers(timers);<br>            resolve();<br>          },<br>          (txObj, error) => {<br>            setErrorVisible(true);<br>            reject(error);<br>            return true; // handled<br>          }<br>        );<br>      });<br>    });<br>  }<br>  ```<br>- **Edge Cases:**<br>  - Corrupted DB: handle parse errors gracefully (skip entry, show error).<br>  - Empty DB: triggers empty state UI.<br>  - Duplicate IDs: Only first occurrence is loaded.<br>- **Performance:**<br>  - O(n) for n timers, limited by SQLite read.<br>- **Side Effects:**<br>  - Updates Zustand, triggers UI re-render via subscription.<br><br>--- |
| MainScreen | handleSessionTimersUpdate(newTimers: SessionTimer[]): void | Purpose:  Reacts to changes in the Zustand SessionTimers store subscription. <br>  Data Handling:  1. Receives new timers list, ensures all have unique IDs (filters duplicates if necessary). 2. Compares previous and current list by length/content; if changed, resets FlatList scroll position to top using `flatListRef.current.scrollToOffset({ offset: 0 })`; otherwise, maintains current scroll. 3. Triggers UI re-render by updating component state. No persistence or notification logic handled here; all data mutations already applied in store prior to this handler. | **HOW to implement `handleSessionTimersUpdate(newTimers)`**<br><br>- **Alignment**: Fully aligned with requirements.<br>- **Step-by-step:**<br>  1. Receives `newTimers` array from Zustand subscription.<br>  2. Deduplicate:<br>     - Filter to ensure each object‚Äôs `id` is unique (`const timers = deduplicateById(newTimers)`).<br>  3. Compare previous timers array (held in local state or ref) to `timers`.<br>     - If length/content differs:<br>        - Reset scroll: `flatListRef.current.scrollToOffset({ offset: 0 })`<br>     - Else:<br>        - Leave scroll position unchanged.<br>  4. Update local state with latest array (if applicable) to trigger React re-render.<br>  5. No data persistence, no notification.<br>- **Pseudocode:**<br>  ```typescript<br>  function handleSessionTimersUpdate(newTimers: SessionTimer[]) {<br>    const uniqueTimers = deduplicateById(newTimers);<br>    if (<br>      prevTimers.length !== uniqueTimers.length or<br>      !arraysEqual(prevTimers, uniqueTimers)<br>    ) {<br>      flatListRef.current?.scrollToOffset({ offset: 0 });<br>    }<br>    setPrevTimers(uniqueTimers); // State for comparison<br>  }<br>  ```<br>- **Edge Cases:**<br>  - FlatList ref not set: check for null.<br>  - No timers: still reset scroll (renders empty state).<br>- **Invariant:** Only unique IDs in list.<br><br>--- |
| MainScreen | handleThemeOrBackgroundUpdate(newTheme: string, newBackgroundImage: string): void | Purpose:  Handles updates from the ThemeStore for theme or background changes. <br>  Data Handling:  Receives new theme and (optionally) new background image URI. Updates Zustand ThemeStore (`setTheme(newTheme)` or `setBackgroundImage(newBackgroundImage)`), causing React Native Paper‚Äôs `<Provider theme={theme}>` to update UI palette, and Expo Image background component to load/cached the new image. Handles image load errors (if any) as per handleImageError logic. Does not persist settings, only updates UI and state. |  |
| MainScreen | handleSettingsUpdate(newSettings: Settings): void | Purpose:  Handles updates from the SettingsStore (adsFreePurchased, theme, background, etc.). <br>  Data Handling:  Receives new `Settings` object (as per domain model), triggers re-render of the Main Screen. Contains conditional logic to show/hide UI elements (e.g., ad banner), change theme, or update background image. Reapplies Flexbox/Paper layout props to accommodate new settings. Does not persist settings directly‚Äîstore mutations already occurred. |  |
| MainScreen | handleFocus(): void | Purpose:  Handles the Main Screen receiving navigation focus. <br>  Data Handling:  When called (via React Navigation focus event), triggers refresh of Session Timers from Zustand TimerStateStore; if a forced refresh is required (such as after restore or data change), calls `MainScreen.loadSessionTimers()`. UI is updated automatically to reflect the current Zustand state. No direct data transformation, only triggers loading if necessary. |  |
| MainScreen | handleLoadingStateUpdate(loading: boolean): void | Purpose:  Responds to updates in loading state (background processes) from LoadingStore. <br>  Data Handling:  If `loading` is `true`, disables all interactive controls on the Main Screen by binding their `disabled` props and displays a `<ActivityIndicator />` spinner. If `loading` is `false`, re-enables controls and hides the spinner. Only updates UI and component state; does not mutate global store or persist data. |  |
| MainScreen | handleAppStateChange(nextAppState: 'active' or 'inactive' or 'background'): void | **Purpose:** Responds to app state transitions (background/foreground) as detected by the AppState API. <br> **Data Handling:** If transitioning to `'active'`, rehydrates Session Timers and theme/background settings from SQLite/AsyncStorage into Zustand using `setSessionTimers`, `setTheme`, etc. Compares FlatList content/length to previous state; if changed, resets scroll position to top; otherwise, restores previous scroll position (from state or transient slice). No direct persistence or notification logic. Ensures UI always represents up-to-date store state after system-level resume. | **HOW to implement `handleAppStateChange(nextAppState)`**<br><br>- **Alignment**: Matches Problem Statement.<br>- **Step-by-step:**<br>  1. When invoked with `nextAppState`:<br>     - If `nextAppState === 'active'`:<br>        - Reload Session Timers and theme/background from persistence (SQLite for timers, AsyncStorage/SQLite for theme/background):<br>          - Load timers (reuse `loadSessionTimers()`).<br>          - Load theme/background: read values and update Zustand ThemeStore (`setTheme`, `setBackgroundImage`).<br>        - Compare FlatList content/size to previous state (can use length or serialized form).<br>            - If changed: reset scroll to top: `flatListRef.current?.scrollToOffset({ offset: 0 })`<br>            - Else: restore previous scroll position from state/transient store: `flatListRef.current?.scrollToOffset({ offset: prevScrollY })`<br>     - Else (inactive/background): No action (just record/keep scroll state if needed).<br>  2. No persistence here‚Äîjust rehydration and UI update.<br>- **Pseudocode:**<br>  ```typescript<br>  function handleAppStateChange(nextAppState) {<br>    if (nextAppState === 'active') {<br>      loadSessionTimers();<br>      const theme = loadThemeFromStorage();<br>      setTheme(theme);<br>      const bg = loadBackgroundFromStorage();<br>      setBackgroundImage(bg);<br>      // Compare FlatList data<br>      if (listChanged()) {<br>        flatListRef.current?.scrollToOffset({ offset: 0 });<br>      } else {<br>        flatListRef.current?.scrollToOffset({ offset: prevScrollY });<br>      }<br>    }<br>  }<br>  ```<br>- **Edge Cases:**<br>  - FlatList ref not ready: check for existence.<br>  - Storage read fails: surface error as per error handling.<br>- **Side Effects:** UI re-renders, scroll position restored.<br><br>--- |
| MainScreen | handleLayout(event: { nativeEvent: { layout: { width: number; height: number; } } }): void | Purpose:  Handles responsive layout/orientation changes of the root container. <br>  Data Handling:  Receives the new layout dimensions from the `onLayout` event. Recalculates and reapplies layout styles/props for the FAB ("+"), Calendar button, and Ad banner to ensure no overlap or occlusion, adjusting Flexbox/paper styles as needed. Triggers UI re-render to apply new layout. No persistence or global state changes. |  |
| MainScreen | handleScroll(event: { nativeEvent: { contentOffset: { y: number } } }): void | Purpose:  Handles FlatList scroll events. <br>  Data Handling:  Captures current scroll position (`y`) from the scroll event object, stores this value in local component state or a transient Zustand slice for later restoration. On navigation back/app resume, if list content is unchanged, restores scroll using `flatListRef.current.scrollToOffset({ offset: y })`. Does not persist this value beyond session. |  |
| MainScreen | handleImageLoaded(): void | <br><br>`handleImageLoaded(): void`<br><br>This handler now delegates all image ready state logic to the `MainScreenBackgroundImageManager`. No local state is managed; the delegate manages `imageReady` and any transitions.<br><br>**Code Example:**<br><br>```typescript<br>public handleImageLoaded(): void {<br>    this.bgImageManager.handleImageLoaded();<br>}<br>```<br><br> |  |
| MainScreen | handleImageError(event: NativeSyntheticEvent<ImageErrorEventData>): void | <br><br>`handleImageError(event: NativeSyntheticEvent<ImageErrorEventData>): void`<br><br>This handler now fully delegates background source fallback and readiness state to the `MainScreenBackgroundImageManager`. No local state is mutated; fallback logic is encapsulated in the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public handleImageError(event: NativeSyntheticEvent<ImageErrorEventData>): void {<br>    this.bgImageManager.handleImageError(event);<br>}<br>```<br><br> |  |
| MainScreen | ensureAccessibilityProps(): void | <br><br>`ensureAccessibilityProps(): void`<br><br>This method no longer performs any iteration or inline application of accessibility props. Instead, it calls static methods from the `MainScreenAccessibilityHelper` for every interactive UI element, typically within the render JSX. The parent‚Äôs responsibility is to ensure the helper is used everywhere accessibility is required.<br><br>**Code Example in render JSX:**<br><br>```tsx<br><IconButton<br>  icon="calendar"<br>  onPress={this.handleCalendar}<br>  {...MainScreenAccessibilityHelper.getAccessibilityProps('Open Calendar')}<br>/><br>```<br><br>--- |  |
| MainScreen | handleCreateSessionTimer(event?: GestureResponderEvent): void | Purpose:  Handles the onPress event for the "+" Floating Action Button that initiates creation of a new Session Timer.<br> Data Handling: <br>- Triggered by a React Native onPress event (`GestureResponderEvent`), but the event object is not used.<br>- Calls `navigation.navigate('SessionTimerCreate')` via React Navigation to transition to the session timer creation screen.<br>- On navigation, ensures the `SessionTimerCreate` screen, on mount, calls `zustandStore.sessionForm.setBlank()` (or equivalent) to initialize a blank `SessionTimer` draft in Zustand state.<br>- No additional input validation is needed here; all draft state and field validation is handled in the target screen.<br>- Responsibility is to orchestrate navigation and proper state initialization for new timer creation.<br>- No return value. |  |
| MainScreen | handleEditSessionTimer(id: string): void | Purpose:  Handles the onPress event for the Edit button on a Session Timer.<br> Data Handling: <br>- Receives the ID (`string`) of the Session Timer to edit.<br>- Validates that the provided ID exists in the current Zustand (or SQLite) sessionTimers array.<br>- If invalid, triggers a Snackbar or Dialog error message using React Native Paper (`UIFeedback.showSnackbar(...)`) and aborts.<br>- If valid, calls `navigation.navigate('SessionTimerEdit', { id })` to route to the editing screen.<br>- On the target screen's mount, ensures that the session timer data is loaded from SQLite via repository (`ISessionTimerRepository.getById(id)`) and populated into Zustand's draft form state.<br>- Ensures that the form fields and state are properly populated and match the expected `SessionTimer` interface.<br>- No return value. |  |
| MainScreen | handlePlay(sessionTimerId: string): void | Purpose:  Handles the onPress event for the Play button on a Session Timer to start a meditation session.<br> Data Handling: <br>- Receives the Session Timer ID as input.<br>- Retrieves the session timer by ID from Zustand (`SessionTimersState.sessionTimers`) and validates completeness/validity per validation rules (name, segments, sounds, etc.).<br>- If invalid, displays a Snackbar/Dialog with error and aborts.<br>- Checks Zustand for any existing active session (`activeSession`).<br>- If an active session exists, opens a modal confirmation dialog (managed in local state) using React Native Paper Dialog.<br>- If the user confirms (or if no session is active), calls `navigation.navigate('MeditationSessionWindow', { sessionId })` to open the session window.<br>- Ensures the MeditationSessionWindow, on mount, deep-copies and locks the session blueprint and settings data for runtime use.<br>- No return value.<br>- Guarantees data integrity by only allowing valid and complete session timers to initiate sessions. |  |
| MainScreen | handleSettings(event?: GestureResponderEvent): void | Purpose:  Handles the onPress event for the Settings icon to open the Settings menu/drawer.<br> Data Handling: <br>- Optionally receives a React Native event, unused.<br>- Calls either `navigation.openDrawer()` (if using React Navigation Drawer) or sets local state variable (e.g., `isSettingsMenuOpen = true`) if using a custom drawer or modal.<br>- Ensures the settings UI is rendered and bound to Zustand's `SettingsState` for all configuration options.<br>- Properly manages open/close state transitions and UI focus.<br>- No validation or data transformation here; all settings change validation is performed within the Settings component.<br>- No return value. |  |
| MeditationSessionWindow | handleActiveSessionConfirm(): Promise<void> | Purpose:  Handles user confirmation to terminate the current active meditation session.<br> Data Handling: <br>- Stops all session timers (`clearInterval`/`clearTimeout`) by referencing stored interval IDs.<br>- Stops all ongoing sound playback by calling `expo-av`'s `SoundObject.stopAsync()` on each loaded sound.<br>- Clears the session state from Zustand (`set({ activeSession: null })`).<br>- Calls `navigation.goBack()` to close the MeditationSessionWindow.<br>- Ensures all JS/Native resources are released and no session is marked active.<br>- No data is persisted here except for clearing the in-memory state.<br>- Returns a `Promise<void>` as some stop/unload operations may be async.<br>- Guarantees that after this completes, the system allows a new session to be started. | **HOW to implement `handleActiveSessionConfirm()`**<br><br>- **Alignment**: Aligned with requirements.<br>- **Step-by-step:**<br>  1. Stop all running session timers:<br>     - For each stored timer/interval ID (in local state), call `clearInterval(timerId)` or `clearTimeout(timerId)`.<br>  2. Stop all sound playback:<br>     - For each `expo-av` `Audio.Sound` object kept in refs/local state, call `await sound.stopAsync()` (must be `await`ed if async).<br>  3. Clear session state from Zustand:<br>     - Call Zustand setter: `set({ activeSession: null })`.<br>  4. Close the MeditationSessionWindow:<br>     - Call `navigation.goBack()` (React Navigation).<br>  5. All resources must be released, all state cleaned up.<br>  6. No side effects beyond state/cleanup.<br>- **Pseudocode:**<br>  ```typescript<br>  async function handleActiveSessionConfirm() {<br>    sessionTimerIds.forEach(timerId => clearInterval(timerId));<br>    await Promise.all(soundObjects.map(sound => sound.stopAsync()));<br>    setActiveSession(null); // Zustand<br>    navigation.goBack();<br>  }<br>  ```<br>- **Edge Cases:**<br>  - If timers or sounds are already stopped, calls are idempotent.<br>  - `navigation.goBack()` may throw if not in stack‚Äîcatch/log if needed (per error handling).<br>- **Performance:** All cleanup must complete before navigation.<br>- **Side Effects:** Running session will be fully torn down.<br><br>--- |
| MeditationSessionWindow | loadAndLockSessionBlueprint(): void | Purpose:  Loads and deep-copies the precise session blueprint/config for the meditation session at focus/mount.<br> Data Handling: <br>- Reads session timer (segments, sounds, settings) from Zustand at focus/mount.<br>- Validates that all required fields are present and valid per the `SessionTimer` interface.<br>- Makes a deep copy (via `JSON.parse(JSON.stringify(...)` or similar) of the session configuration and stores it in component-local state.<br>- No further edits to Zustand or SQLite after this point will affect the running session's runtime config.<br>- The locked config is used for all timer, audio, and UI logic during the session.<br>- No parameters or return value.<br>- Ensures isolation and immutability of session configuration during an active session. | **HOW to implement `loadAndLockSessionBlueprint()`**<br><br>- **Alignment:** Directly matches requirements and passive invariants.<br>- **Step-by-step:**<br>  1. On screen focus/mount, read current session timer ID (from navigation param or Zustand).<br>  2. Retrieve session timer from Zustand store (`sessionTimers` array) by ID.<br>  3. Validate all required fields are present and valid (name, segments, times, sounds, settings).<br>     - If invalid, do not proceed; surface error to UI.<br>  4. Deep copy the entire session timer object, including segments (e.g., `JSON.parse(JSON.stringify(obj))`).<br>  5. Store this deep copy in component-local state/hook, e.g., `const [lockedConfig, setLockedConfig] = useState(copy)`.<br>  6. All further session logic reads config from this locked copy; ignores further Zustand/SQLite changes.<br>- **Pseudocode:**<br>  ```typescript<br>  function loadAndLockSessionBlueprint() {<br>    const sessionTimer = getSessionTimerFromStore(sessionId);<br>    if (!validateSessionTimer(sessionTimer)) {<br>      setError('Session timer invalid');<br>      return;<br>    }<br>    const lockedConfig = JSON.parse(JSON.stringify(sessionTimer));<br>    setLockedConfig(lockedConfig);<br>  }<br>  ```<br>- **Edge Cases:**<br>  - If session timer missing or invalid: Show error, do not start session.<br>- **Invariant:** `lockedConfig` does not change for lifetime of session.<br><br>--- |
| MeditationSessionWindow | handleStartSession(event?: GestureResponderEvent): Promise<void> | <br><br>`handleStartSession(event?: GestureResponderEvent): Promise<void>`<br><br>This method now solely orchestrates the start of session by delegating timer startup, sound playback, and OS integration to the respective delegates:<br><br>1. Instantiates or resets the timer manager and audio orchestrator with the locked session config and error callback.<br>2. Calls `this.timerManager.startTimers()` to begin all session timers.<br>3. Calls `this.audioOrchestrator.playMeditationSound()` and, if needed, `this.audioOrchestrator.playSegmentationSound()` to start sound playback.<br>4. Calls `this.osIntegrationManager.activateKeepAwakeIfNeeded(lockedSettings.keepScreenOn)` and `this.osIntegrationManager.activateDndIfNeeded(lockedSettings.dndEnabled)` for OS effects.<br>5. Any errors are surfaced via the error callback wired to the orchestrator.<br><br>**Code Example:**<br><br>```typescript<br>public async handleStartSession(event?: GestureResponderEvent): Promise<void> {<br>    this.timerManager = new MeditationSessionTimerManager(this.sessionConfig, this.lockedSettings, this.handleSegmentEnd);<br>    this.audioOrchestrator = new SessionAudioOrchestrator(this.sessionConfig, (msg) => this.setPlaybackErrorDialog({ message: msg }));<br>    this.timerManager.startTimers();<br>    await this.audioOrchestrator.playMeditationSound();<br>    await this.osIntegrationManager.activateKeepAwakeIfNeeded(this.lockedSettings.keepScreenOn);<br>    await this.osIntegrationManager.activateDndIfNeeded(this.lockedSettings.dndEnabled);<br>}<br>```<br><br> |  |
| MeditationSessionWindow | handlePauseSession(event?: GestureResponderEvent): Promise<void> | <br><br>`handlePauseSession(event?: GestureResponderEvent): Promise<void>`<br><br>This method now delegates all pause logic:<br><br>1. Calls `this.timerManager.pauseTimers()` to halt all timers.<br>2. Calls `this.audioOrchestrator.pauseMeditationSound()` and `this.audioOrchestrator.pauseSegmentationSound()` to pause all sounds.<br>3. Calls `this.osIntegrationManager.deactivateKeepAwakeIfNeeded(lockedSettings.keepScreenOn)` and `this.osIntegrationManager.deactivateDndIfNeeded(lockedSettings.dndEnabled)` if needed.<br><br>**Code Example:**<br><br>```typescript<br>public async handlePauseSession(event?: GestureResponderEvent): Promise<void> {<br>    this.timerManager.pauseTimers();<br>    await this.audioOrchestrator.pauseMeditationSound();<br>    await this.audioOrchestrator.pauseSegmentationSound();<br>    await this.osIntegrationManager.deactivateKeepAwakeIfNeeded(this.lockedSettings.keepScreenOn);<br>    await this.osIntegrationManager.deactivateDndIfNeeded(this.lockedSettings.dndEnabled);<br>}<br>```<br><br> |  |
| MeditationSessionWindow | handleContinueSession(event?: GestureResponderEvent): Promise<void> | <br><br>`handleContinueSession(event?: GestureResponderEvent): Promise<void>`<br><br>This method now delegates all resume/unpause logic:<br><br>1. Calls `this.timerManager.resumeTimers()`.<br>2. Calls `this.audioOrchestrator.resumeMeditationSound()` and `this.audioOrchestrator.resumeSegmentationSound()`.<br>3. Calls `this.osIntegrationManager.activateKeepAwakeIfNeeded(lockedSettings.keepScreenOn)` and `this.osIntegrationManager.activateDndIfNeeded(lockedSettings.dndEnabled)`.<br><br>**Code Example:**<br><br>```typescript<br>public async handleContinueSession(event?: GestureResponderEvent): Promise<void> {<br>    this.timerManager.resumeTimers();<br>    await this.audioOrchestrator.resumeMeditationSound();<br>    await this.audioOrchestrator.resumeSegmentationSound();<br>    await this.osIntegrationManager.activateKeepAwakeIfNeeded(this.lockedSettings.keepScreenOn);<br>    await this.osIntegrationManager.activateDndIfNeeded(this.lockedSettings.dndEnabled);<br>}<br>```<br><br> |  |
| MeditationSessionWindow | handleAppStateChange(nextAppState: AppStateStatus): Promise<void> | Purpose:  Handles app state changes (background/foreground) to pause/resume session.<br> Data Handling: <br>- Receives the next app state (`'active'`, `'inactive'`, `'background'`, `'blur'`, etc.) as per React Native AppState API.<br>- If transitioning to `'inactive'`, `'background'`, or `'blur'` and session is active, pauses the session:<br>‚ÄÉ- Updates Zustand/component state to `'paused'`.<br>‚ÄÉ- Clears all running timers.<br>‚ÄÉ- Pauses all audio with `pauseAsync()`.<br>- If returning to `'active'`, ensures session remains `'paused'`; all timers/audio remain stopped and UI reflects paused state.<br>- Returns `Promise<void>` due to async audio operations.<br>- No data persistence; only runtime state changes. | **HOW to implement `handleAppStateChange(nextAppState)`**<br><br>- **Alignment:** Matches requirements.<br>- **Step-by-step:**<br>  1. Receives `nextAppState` (`'active'`, `'inactive'`, `'background'`, `'blur'`, etc.).<br>  2. If `nextAppState` is `'inactive'` or `'background'` or `'blur'` and session is active:<br>     - Update Zustand/component state to `'paused'` (e.g., `setSessionState('paused')`).<br>     - Stop all running timers (`clearInterval` on all timer IDs).<br>     - Pause all audio: for each `Audio.Sound` object, call `await sound.pauseAsync()`.<br>  3. If `nextAppState` is `'active'`:<br>     - Ensure session state remains `'paused'` (do not resume timers/audio).<br>     - UI should render "Continue" state.<br>  4. No data persistence in this method.<br>- **Pseudocode:**<br>  ```typescript<br>  async function handleAppStateChange(nextAppState) {<br>    if (['inactive', 'background', 'blur'].includes(nextAppState)) {<br>      setSessionState('paused');<br>      timerIds.forEach(id => clearInterval(id));<br>      await Promise.all(soundObjects.map(sound => sound.pauseAsync()));<br>    } else if (nextAppState === 'active') {<br>      setSessionState('paused');<br>      // UI will show paused, no timers/audio resumed<br>    }<br>  }<br>  ```<br>- **Edge Cases:**<br>  - Multiple pauses: repeated calls are safe.<br>  - Some audio/timers may already be paused/stopped.<br><br>--- |
| MeditationSessionWindow | handleRoundTimerTick(): void | <br><br>`handleRoundTimerTick(): void`<br><br>This method no longer performs any timer or tick logic directly; all such logic is encapsulated in the timer manager delegate. The parent method simply ensures the delegate is active and, if needed, queries it for UI updates.<br><br>**Code Example:**<br><br>```typescript<br>// No direct method; round timer ticks are managed by this.timerManager internally.<br>```<br><br> |  |
| MeditationSessionWindow | handleDigitalElapsedTick(): void | <br><br>`handleDigitalElapsedTick(): void`<br><br>This method no longer performs any digital timer logic directly; all such logic is encapsulated in the timer manager delegate. The parent method simply ensures the delegate is active and, if needed, queries it for UI updates.<br><br>**Code Example:**<br><br>```typescript<br>// No direct method; digital timer ticks are managed by this.timerManager internally.<br>```<br><br> |  |
| MeditationSessionWindow | handleSegmentEnd(): Promise<void> | <br><br>`handleSegmentEnd(): Promise<void>`<br><br>This method delegates all logic for advancing segments, updating timer state, and playing segmentation sound to the relevant delegates:<br><br>1. Calls `this.timerManager.onSegmentEnd()` (or similar method inside the timer manager).<br>2. Calls `this.audioOrchestrator.playSegmentationSound()` to play the transition sound.<br>3. Any updates to UI or state are performed as a result of delegate-initiated events or status.<br><br>**Code Example:**<br><br>```typescript<br>public async handleSegmentEnd(): Promise<void> {<br>    this.timerManager.onSegmentEnd();<br>    await this.audioOrchestrator.playSegmentationSound();<br>}<br>```<br><br> |  |
| MeditationSessionWindow | handlePlaybackStatusUpdate(status: AVPlaybackStatus): Promise<void> | <br><br>`handlePlaybackStatusUpdate(status: AVPlaybackStatus): Promise<void>`<br><br>This method no longer handles playback status events directly. Instead, whenever expo-av triggers a playback status update, the parent immediately forwards it to the orchestrator, specifying the sound type.<br><br>**Code Example:**<br><br>```typescript<br>public async handlePlaybackStatusUpdate(status: AVPlaybackStatus, type: 'meditation' or 'segmentation'): Promise<void> {<br>    await this.audioOrchestrator.handlePlaybackStatusUpdate(status, type);<br>}<br>```<br><br> |  |
| MeditationSessionWindow | handlePlaybackError(status: AVPlaybackStatus): Promise<void> | <br><br>`handlePlaybackError(status: AVPlaybackStatus): Promise<void>`<br><br>This method no longer manages playback error detection or dialog logic directly. The orchestrator is initialized with an error callback that sets the appropriate UI state (error dialog, disable sound, etc.) as required.<br><br>**Code Example:**<br><br>```typescript<br>// No direct method; playback errors are surfaced via the orchestrator‚Äôs error callback.<br>```<br><br> |  |
| MeditationSessionWindow | handleBackPress(event?: GestureResponderEvent): void | Purpose:  Handles UI Back button ("<-") presses in MeditationSessionWindow.<br> Data Handling: <br>- Optionally receives a UI event (unused).<br>- Sets component-local state to open a confirmation dialog (React Native Paper Dialog) asking if the user wants to terminate the session.<br>- No state/timer/audio changes performed until the user confirms.<br>- Actual termination or cancel actions dispatched to handler methods (`handleSessionTerminateConfirm`/`handleSessionTerminateCancel`).<br>- No return value; UI state only. |  |
| MeditationSessionWindow | handleBeforeRemove(event: NavigationEvent): void | Purpose:  Handles system/hardware back (beforeRemove event) for session confirmation.<br> Data Handling: <br>- Receives a React Navigation event (`NavigationEvent`), which must have `event.preventDefault()` called to block default navigation.<br>- Sets a local state variable to open a session termination confirmation dialog.<br>- No session state/timer/audio cleanup occurs here; all handled by dialog confirmation handlers.<br>- No return value; UI state only.<br>- Ensures that explicit user confirmation is required before tearing down a running session via system back. |  |
| MeditationSessionWindow | handleSessionTerminateConfirm(): Promise<void> | Purpose:  Handles the confirm action in the session termination dialog.<br> Data Handling: <br>- Updates component and Zustand session state to `'terminated'`.<br>- Stops all running timers via `clearInterval` (both segment and digital elapsed).<br>- Stops audio playback using `stopAsync()` on all loaded expo-av sound objects.<br>- Calls `deactivateKeepAwake()` if keepScreenOn was enabled, and `deactivateDnd()` if DND mode was set.<br>- Logs the completed session by inserting a new MeditationLog into SQLite via `IMeditationLogRepository.save(...)` (with current timestamp and total duration).<br>- Updates Zustand MeditationLogsState via `addMeditationLog(logObj)`.<br>- Calls `navigation.goBack()` to close the session window.<br>- Returns `Promise<void>` due to async DB and audio cleanup.<br>- All side effects and state updates are performed in this method. | **HOW to implement `handleSessionTerminateConfirm()`**<br><br>- **Alignment:** Matches requirements precisely.<br>- **Step-by-step:**<br>  1. Update component and Zustand session state to `'terminated'`.<br>     - e.g., `setSessionState('terminated')`, `set({ activeSession: null })`<br>  2. Stop all timers (segment and elapsed): `clearInterval(timerId)` for all known interval IDs.<br>  3. Stop all audio playback:<br>     - For each `Audio.Sound` object (`expo-av`), call `await sound.stopAsync()`.<br>  4. Call `deactivateKeepAwake()` if `keepScreenOn` active (from expo-keep-awake).<br>  5. Call `deactivateDnd()` if `dndEnabled` is true (from react-native-do-not-disturb).<br>  6. Log the session:<br>     - Compute session `timestamp` and `duration` (from session local state).<br>     - Insert into SQLite `MeditationsLog` table:<br>         ```typescript<br>         db.transaction(tx => {<br>           tx.executeSql(<br>             'INSERT INTO MeditationsLog (timestamp, duration) VALUES (?, ?)',<br>             [timestamp, duration]<br>           );<br>         });<br>         ```<br>     - Update Zustand `MeditationsLogsState` (e.g., `addMeditationLog({ timestamp, duration })`)<br>  7. Close the MeditationSessionWindow (`navigation.goBack()`).<br>  8. All steps are to be performed regardless of prior errors; state must be fully cleaned up.<br>- **Pseudocode:**<br>  ```typescript<br>  async function handleSessionTerminateConfirm() {<br>    setSessionState('terminated');<br>    setActiveSession(null); // Zustand<br>    timerIds.forEach(id => clearInterval(id));<br>    await Promise.all(soundObjects.map(s => s.stopAsync()));<br>    if (lockedSettings.keepScreenOn) await deactivateKeepAwake();<br>    if (lockedSettings.dndEnabled) await deactivateDnd();<br>    const timestamp = getStartTime();<br>    const duration = getElapsed();<br>    db.transaction(tx => {<br>      tx.executeSql(<br>        'INSERT INTO MeditationsLog (timestamp, duration) VALUES (?, ?)',<br>        [timestamp, duration]<br>      );<br>    });<br>    addMeditationLog({ timestamp, duration }); // Zustand update<br>    navigation.goBack();<br>  }<br>  ```<br>- **Edge Cases:**<br>  - Log insertion fails: may surface error elsewhere, but session still cleaned up.<br>  - Some timers/audio may be already stopped; safe to call `stopAsync` multiple times.<br>- **Side Effects:** Cleans up all state, logs session.<br><br>--- |
| MeditationSessionWindow | handleSessionTerminateCancel(): void | Purpose:  Handles cancel action in the session termination confirmation dialog.<br> Data Handling: <br>- Updates component-local state to close the confirmation dialog (`setShowTerminateDialog(false)`).<br>- No changes are made to timers, audio, or Zustand state.<br>- Session continues in its prior state (active or paused).<br>- UI state only; no return value. |  |
| MeditationSessionWindow | handleSessionWindowCleanup(): Promise<void> | <br><br>`handleSessionWindowCleanup(): Promise<void>`<br><br>This method now delegates cleanup responsibilities as follows:<br><br>1. Calls `this.timerManager.cleanup()` to stop/clear all timers.<br>2. Calls `this.audioOrchestrator.stopAndUnloadMeditationSound()` and `this.audioOrchestrator.stopAndUnloadSegmentationSound()` to ensure all audio resources are released.<br>3. Calls `this.osIntegrationManager.deactivateKeepAwakeIfNeeded(lockedSettings.keepScreenOn)` and `this.osIntegrationManager.deactivateDndIfNeeded(lockedSettings.dndEnabled)` to restore OS state.<br>4. Persists any required session state if necessary (e.g., for recovery), but timer/audio resource management is fully delegated.<br><br>**Code Example:**<br><br>```typescript<br>public async handleSessionWindowCleanup(): Promise<void> {<br>    this.timerManager.cleanup();<br>    await this.audioOrchestrator.stopAndUnloadMeditationSound();<br>    await this.audioOrchestrator.stopAndUnloadSegmentationSound();<br>    await this.osIntegrationManager.deactivateKeepAwakeIfNeeded(this.lockedSettings.keepScreenOn);<br>    await this.osIntegrationManager.deactivateDndIfNeeded(this.lockedSettings.dndEnabled);<br>}<br>```<br><br>--- |  |
| DiaryEntryEditor | handleSaveOrBack(event?: GestureResponderEvent): Promise<void> | Purpose:  Handles the onPress event for the Top-Left Arrow IconButton ("Back"/"Save") in DiaryEntryEditor.<br> Data Handling: <br>- Optionally receives a UI event (unused).<br>- Validates content (non-empty, minLength 1) and timestamp (valid ISO8601, unique) per `DiaryEntry` constraints.<br>- If invalid, updates local error state, disables Save/Arrow, and displays inline error.<br>- If valid, calls the Zustand store action (`saveDiaryEntry(entry: DiaryEntry)`) which persists via `IDiaryEntryRepository.save(entry)` to SQLite.<br>- On successful save, calls `navigation.goBack()` to leave the editor.<br>- No further state or UI updates required; store subscriptions drive downstream UI.<br>- Returns `Promise<void>` as DB ops may be async. |  |
| DiaryEntryEditor | handleChangeContent(value: string): void | <br><br>`handleChangeContent(value: string): void`<br><br>This method now delegates content validation and undo/redo stack management to the respective delegates:<br><br>1. Calls `this.undoRedoManager.pushChange(value)` to update undo/redo history and current content.<br>2. Retrieves the new content from the manager and triggers UI update.<br>3. Calls `this.validationManager.validateAll(...)` to validate the new content, timestamp, and uniqueness.<br>4. Sets error messages and disables Save if invalid.<br><br>**Code Example:**<br><br>```typescript<br>public handleChangeContent(value: string): void {<br>    this.undoRedoManager.pushChange(value);<br>    const content = this.undoRedoManager.currentContent;<br>    this.setContent(content);<br>    const error = this.validationManager.validateAll(<br>        content,<br>        this.timestamp,<br>        this.diaryEntries,<br>        this.meditationLogs,<br>        this.isEditMode,<br>        this.minContentLength<br>    );<br>    this.setErrorMsg(error);<br>    this.setSaveDisabled(!!error);<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleDiaryEntryEditorMount(): void | <br><br>`handleDiaryEntryEditorMount(): void`<br><br>This method now uses the delegate to verify timestamp and initialize validation:<br><br>1. Checks that timestamp is valid using `this.validationManager.isValidISO8601(timestamp)`.<br>2. Sets error message and disables Save if invalid, and navigates away.<br>3. If valid, determines edit mode and content, and validates using `this.validationManager.validateAll(...)`.<br>4. Sets initial error message and Save disabled state via the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public handleDiaryEntryEditorMount(): void {<br>    if (!this.validationManager.isValidISO8601(this.timestamp)) {<br>        this.setErrorMsg('Invalid or missing timestamp.');<br>        this.setSaveDisabled(true);<br>        setTimeout(() => this.navigation.goBack(), 500);<br>        return;<br>    }<br>    const error = this.validationManager.validateAll(<br>        this.content,<br>        this.timestamp,<br>        this.diaryEntries,<br>        this.meditationLogs,<br>        this.isEditMode,<br>        this.minContentLength<br>    );<br>    this.setErrorMsg(error);<br>    this.setSaveDisabled(!!error);<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleEditorBack(event: NavigationEvent): void | Purpose:  Handles system/hardware back navigation events in DiaryEntryEditor.<br> Data Handling: <br>- Receives a navigation event, calls `event.preventDefault()` if needed to block default navigation.<br>- Resets all local editor state (content, undo/redo stacks) to initial values.<br>- If editing a new, unsaved note, discards all local changes.<br>- Calls `navigation.goBack()` to exit the DiaryEntryEditor screen.<br>- No updates made to Zustand or SQLite.<br>- Ensures no draft/undo state is leaked.<br>- No return value. |  |
| DiaryEntryEditor | handleEditorUnmount(): void | Purpose:  Cleans up ephemeral editor state on unmount/navigation away.<br> Data Handling: <br>- Clears local undo/redo stacks and any transient state for the editor session.<br>- React/JS garbage collection handles memory reclamation.<br>- No further action or data persistence.<br>- No parameters or return value. |  |
| DiaryEntryEditor | handleInvalidTimestamp(): void | <br><br>`handleInvalidTimestamp(): void`<br><br>This method now leverages the delegate to determine error messaging and Save disablement:<br><br>1. Calls `this.validationManager.validateAll(...)` with the current content and timestamp.<br>2. Sets error message and disables Save.<br>3. Navigates away.<br><br>**Code Example:**<br><br>```typescript<br>public handleInvalidTimestamp(): void {<br>    const error = this.validationManager.validateAll(<br>        this.content,<br>        this.timestamp,<br>        this.diaryEntries,<br>        this.meditationLogs,<br>        this.isEditMode,<br>        this.minContentLength<br>    );<br>    this.setErrorMsg(error);<br>    this.setSaveDisabled(!!error);<br>    this.navigation.goBack();<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleSave(event?: GestureResponderEvent): Promise<void> | <br><br>`handleSave(event?: GestureResponderEvent): Promise<void>`<br><br>This method now fully delegates validation to the manager before Save:<br><br>1. Calls `this.validationManager.validateAll(...)` with all current field values.<br>2. If invalid, sets error message and disables Save.<br>3. If valid, calls `this.saveDiaryEntry({ timestamp, content })` to persist, then navigates away.<br><br>**Code Example:**<br><br>```typescript<br>public async handleSave(event?: GestureResponderEvent): Promise<void> {<br>    const err = this.validationManager.validateAll(<br>        this.content,<br>        this.timestamp,<br>        this.diaryEntries,<br>        this.meditationLogs,<br>        this.isEditMode,<br>        this.minContentLength<br>    );<br>    if (err) {<br>        this.setErrorMsg(err);<br>        this.setSaveDisabled(true);<br>        return;<br>    }<br>    await this.saveDiaryEntry({ timestamp: this.timestamp, content: this.content.trim() });<br>    this.navigation.goBack();<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleCancel(): void | This method is bound as the onPress handler for the Cancel button in DiaryEntryEditor. It performs a full reset of the editor's local state, including discarding any unsaved diary content and clearing the undo/redo stacks that are managed in React component state. If the diary entry was new and unsaved, no persistence action is taken. After resetting, it calls `navigation.goBack()` (React Navigation) to close the editor screen. No calls to Zustand or SQLite are made. The data handling responsibility is to ensure that no in-memory edits, drafts, or undo/redo history leak beyond the current editor instance, and that the persistent state (store/SQLite) remains unchanged. |  |
| DiaryEntryEditor | handleUndo(): void | <br><br>`handleUndo(): void`<br><br>This method now uses the undo/redo delegate to pop previous content and update UI:<br><br>1. Calls `this.undoRedoManager.undo()`, updates content with result if not null.<br>2. Validates new content via delegate.<br>3. Updates error message and Save disabled state.<br><br>**Code Example:**<br><br>```typescript<br>public handleUndo(): void {<br>    const prev = this.undoRedoManager.undo();<br>    if (prev !== null) {<br>        this.setContent(prev);<br>        const error = this.validationManager.validateAll(<br>            prev,<br>            this.timestamp,<br>            this.diaryEntries,<br>            this.meditationLogs,<br>            this.isEditMode,<br>            this.minContentLength<br>        );<br>        this.setErrorMsg(error);<br>        this.setSaveDisabled(!!error);<br>    }<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleRedo(): void | <br><br>`handleRedo(): void`<br><br>This method now uses the undo/redo delegate to pop next content and update UI:<br><br>1. Calls `this.undoRedoManager.redo()`, updates content with result if not null.<br>2. Validates new content via delegate.<br>3. Updates error message and Save disabled state.<br><br>**Code Example:**<br><br>```typescript<br>public handleRedo(): void {<br>    const next = this.undoRedoManager.redo();<br>    if (next !== null) {<br>        this.setContent(next);<br>        const error = this.validationManager.validateAll(<br>            next,<br>            this.timestamp,<br>            this.diaryEntries,<br>            this.meditationLogs,<br>            this.isEditMode,<br>            this.minContentLength<br>        );<br>        this.setErrorMsg(error);<br>        this.setSaveDisabled(!!error);<br>    }<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleDelete(): void | <br><br>`handleDelete(): void`<br><br>This method now sets the delete dialog visible using local state, and all dialog rendering and handler wiring are fully delegated to the dialog manager component.<br><br>**Code Example:**<br><br>```typescript<br>public handleDelete(): void {<br>    this.setDeleteDialogVisible(true);<br>    // Dialog rendering is handled by <DiaryEntryDeleteDialogManager ... /><br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleConfirmDelete(): Promise<void> | <br><br>`handleConfirmDelete(): Promise<void>`<br><br>This method now calls the store delete action, closes the dialog, and navigates away. All dialog state and rendering are delegated.<br><br>**Code Example:**<br><br>```typescript<br>public async handleConfirmDelete(): Promise<void> {<br>    await this.deleteDiaryEntry(this.entryId);<br>    this.setDeleteDialogVisible(false);<br>    this.navigation.goBack();<br>}<br>```<br><br> |  |
| DiaryEntryEditor | handleCancelDelete(): void | <br><br>`handleCancelDelete(): void`<br><br>This method now just updates local dialog state to close the confirmation dialog; all rendering and prop passing are handled by the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public handleCancelDelete(): void {<br>    this.setDeleteDialogVisible(false);<br>}<br>```<br><br>--- |  |
| CalendarView | handleDayPress(date: { dateString: string }): void | Registered as the onDayPress handler for the `react-native-calendars` Calendar component. Receives a date object (with `dateString: string`, ISO8601 date). Executes SQL SELECT queries (expo-sqlite) to fetch all MeditationLog and DiaryEntry records for that date. Updates Zustand store slices for `meditationLogs` and `diaryEntries` by calling their store actions with the fetched results (arrays of MeditationLog and DiaryEntry), ensuring each conforms to their static types and validation constraints (timestamps must be ISO8601, durations integers, content strings). Reactively re-renders the CalendarView via Zustand subscriptions. Data transformation responsibility: adapt raw SQLite query results to correct in-memory TS interfaces, validate before store update, and ensure no duplicate/invalid entries are introduced. | - **Is the Method description unequivocally aligned with the problem statement?**<br>  - Yes, the method covers the required logic for selecting a day and updating state/UI according to all requirements.<br><br>- **HOW to implement:**<br><br>1. **Trigger**: This method is bound to the `onDayPress` event of `react-native-calendars`. Receives a date object with at least a `dateString` property (ISO8601).<br><br>2. **Step-by-step Implementation:**<br>   1. **Extract** the date string: `const selectedDate = date.dateString;`<br>   2. **Fetch Meditation Logs:**  <br>      - Use `expo-sqlite`'s `db.transaction` or `db.executeSql` to execute:<br>        ```sql<br>        SELECT * FROM MeditationsLog WHERE date(timestamp, 'localtime') = date(?, 'localtime')<br>        ```<br>        - Params: `[selectedDate]`<br>      - Validate that each result row conforms to the MeditationLog TS type (timestamp is ISO8601, duration is integer, etc.)<br>   3. **Fetch Diary Entries:**<br>      - Use `db.executeSql`:<br>        ```sql<br>        SELECT * FROM DiaryEntries WHERE date(timestamp, 'localtime') = date(?, 'localtime')<br>        ```<br>        - Params: `[selectedDate]`<br>      - Validate that each result row conforms to DiaryEntry type (timestamp ISO8601, content string, etc.)<br>   4. **Transform Results:**<br>      - For each returned record, map SQLite rows to in-memory JS objects matching their interface.<br>      - Only include valid/unique entries. Filter out any that are invalid per model (e.g., duplicate timestamps, invalid ISO8601).<br>   5. **Update Zustand Store:**<br>      - Call the meditationLogs store action, e.g.:  <br>        `meditationLogsStore.setLogs(fetchedMeditationLogs)`<br>      - Call the diaryEntries store action, e.g.:  <br>        `diaryEntriesStore.setEntries(fetchedDiaryEntries)`<br>   6. **UI Update:**<br>      - React/React Native and Zustand together will trigger UI rerender of CalendarView and any dependent components.<br><br>3. **Edge cases & error handling:**<br>   - If SQLite errors, handle with error dialog/snackbar (handled in another error handler).<br>   - If no entries are found, still clear/store empty arrays in Zustand for that date.<br>   - Never introduce duplicates: enforce uniqueness by PK on timestamp.<br>   - All date/time comparisons must be locale-agnostic and use ISO8601 dates.<br><br>4. **Performance:**<br>   - Queries should be efficient (indexed by timestamp).<br>   - All UI updates are reactive; no manual refresh needed.<br>   - Data transformation and validation must be O(n) for n results.<br><br>5. **Pseudocode Example:**<br>   ```typescript<br>   function handleDayPress(date) {<br>       const selectedDate = date.dateString;<br>       db.transaction(tx => {<br>           // MeditationsLog fetch<br>           tx.executeSql(<br>               'SELECT * FROM MeditationsLog WHERE date(timestamp, "localtime") = date(?, "localtime")',<br>               [selectedDate],<br>               (_, { rows }) => {<br>                   const logs = rows._array.filter(validMeditationLogEntry);<br>                   meditationLogsStore.setLogs(logs);<br>               }<br>           );<br>           // DiaryEntries fetch<br>           tx.executeSql(<br>               'SELECT * FROM DiaryEntries WHERE date(timestamp, "localtime") = date(?, "localtime")',<br>               [selectedDate],<br>               (_, { rows }) => {<br>                   const entries = rows._array.filter(validDiaryEntry);<br>                   diaryEntriesStore.setEntries(entries);<br>               }<br>           );<br>       });<br>       // No return; UI updates via Zustand/React subscription<br>   }<br>   ```<br>6. **Invariant:**  <br>   - Store always reflects current selected date entries; no duplicates, only valid entries per models.<br><br>--- |
| CalendarView | handleMeditationEntryPress(entryId: string): void | Bound as the onPress handler for meditation log entry cards. Receives an entry ID (timestamp or PK). Sets local state variables (e.g., `modalOpen`, `selectedEntryId`) to open a detail modal/dialog. The modal displays data for the selected entry (read from Zustand slice, which must already contain the entry, validated as MeditationLog). Ensures only one modal open at a time by controlling modal state‚Äîno data mutation or store update occurs here. Data responsibility: only manages ephemeral UI state, never alters persistent or in-memory store. |  |
| CalendarView | handleDiaryEntryPress(entryId: string): void | Bound as the onPress handler for diary entry cards. Receives a diary entry identifier (timestamp or PK). Calls `navigation.navigate('DiaryEntryEditor', { entryId })` to open the DiaryEntryEditor for that entry. DiaryEntryEditor loads the entry from Zustand (validated as DiaryEntry). This handler is responsible only for initiating navigation; no local or persistent state is changed in CalendarView. Must guarantee that the parameter passed matches the DiaryEntry PK in the data model. |  |
| CalendarView | handleEditDuration(): void | Bound as the onPress handler for "Edit Duration" within the meditation details modal/dialog. Updates local React state (e.g., `setEditMode(true)`) indicating the duration field should be editable. Renders a TextInput or similar for user input of the new duration. Does not persist or mutate any data at this stage. Ephemeral UI state only. The data handling responsibility is to control conditional rendering and ensure any transition to edit mode is local and not leaked to store/persistence. |  |
| CalendarView | handleEditDurationSave(): Promise<void> | Bound to the Save button after duration edit. Validates the input duration (must be integer, min 1, per MeditationLog validation). If invalid, sets local error state and disables saving. If valid, executes a SQL UPDATE via expo-sqlite to update the MeditationLog for the entry‚Äôs timestamp. Also updates the meditationLogs slice in Zustand (`updateMeditationLogDuration(entryId, newDuration)`). Closes the modal/dialog, ensuring CalendarView and StatisticsPage (both reactively subscribed) update. Data handling: ensure type and value correctness for duration, handle error propagation if SQL/store update fails, guarantee no partial writes (all-or-nothing). | - **Is the Method description unequivocally aligned with the problem statement?**<br>  - Yes, but HOW to perform validation, persistence, and state update must be explicit.<br><br>- **HOW to implement:**<br><br>1. **Trigger:**  <br>   - Called by the Save button in the meditation details modal after editing duration.<br><br>2. **Step-by-step Implementation:**<br>   1. **Get user input:**  <br>      - Read the new duration value from local state/input (e.g., `newDuration` as string or number).<br>   2. **Validate input:**  <br>      - Check: `Number.isInteger(newDuration)`  <br>      - Check: `newDuration >= 1`  <br>      - If invalid:  <br>        - Set local error state (e.g., `setEditError("Duration must be a positive integer.")`)<br>        - Disable Save button (`setSaveDisabled(true)`)<br>        - Exit function<br>   3. **Update SQLite:**<br>      - Use expo-sqlite `db.executeSql`:<br>        ```sql<br>        UPDATE MeditationsLog SET duration = ? WHERE timestamp = ?<br>        ```<br>        - Params: `[newDuration, entryId]`<br>      - On error:  <br>        - Call error handler (show dialog/snackbar, rollback as per requirements).<br>   4. **Update Zustand Store:**<br>      - Call meditationLogs store action, e.g.:<br>        ```typescript<br>        meditationLogsStore.updateDuration(entryId, newDuration)<br>        ```<br>      - This will update the meditationLogs array in Zustand, triggering all subscribed UI (CalendarView, StatisticsPage, etc.) to re-render.<br>   5. **Close Modal:**<br>      - Set modal open state to false (`setModalOpen(false)`), reset edit mode, clear local error state.<br>   6. **No partial writes:**<br>      - Only close modal if both SQLite update and Zustand update succeed.<br>      - If any failure (SQLite or store), display error and do not close modal.<br><br>3. **Edge Cases:**<br>   - If the dialog/modal is closed before save, discard changes.<br>   - If SQLite or Zustand update fails, ensure UI does not reflect inconsistent state.<br><br>4. **Performance:**<br>   - Duration update is O(1) in DB and in-memory.<br>   - UI update is handled via Zustand/React.<br><br>5. **Pseudocode Example:**<br>   ```typescript<br>   async function handleEditDurationSave() {<br>       const newDuration = parseInt(durationInputValue, 10);<br>       if (!Number.isInteger(newDuration) or newDuration < 1) {<br>           setEditError("Duration must be a positive integer.");<br>           setSaveDisabled(true);<br>           return;<br>       }<br>       try {<br>           await db.executeSql(<br>               'UPDATE MeditationsLog SET duration = ? WHERE timestamp = ?',<br>               [newDuration, selectedEntryId]<br>           );<br>           meditationLogsStore.updateDuration(selectedEntryId, newDuration);<br>           setModalOpen(false);<br>           setEditMode(false);<br>           setEditError(null);<br>       } catch (err) {<br>           handleSqlTransactionError(err); // surface error and rollback as required<br>       }<br>   }<br>   ```<br><br>6. **Invariant:**  <br>   - Store/DB always match; modal closed only on success; UI always shows latest duration.<br><br>--- |
| CalendarView | handleEditDurationCancel(): void | Bound as the Cancel button handler in duration edit mode. Updates local state to exit edit mode and close the modal/dialog, discarding any uncommitted changes. No persistent or in-memory store mutation. Data handling is limited to transient UI state. |  |
| CalendarView | handleDiaryButtonPress(): void | Bound as the onPress handler for "Add/Edit Diary" in the meditation modal/dialog. Checks the Zustand `diaryEntries` slice for an entry with the same timestamp as the selected meditation (validates timestamp uniqueness per DiaryEntry constraints). If found, loads the existing entry; otherwise, creates a new DiaryEntry object (not persisted) with the meditation's timestamp. Calls `navigation.navigate('DiaryEntryEditor', { entryId or timestamp })`. Enforces uniqueness in both UI and data layers (SQLite PK and store validation). Handles data transformation from MeditationLog timestamp to DiaryEntry PK, ensuring ISO8601 compliance. | - **Is the Method description unequivocally aligned with the problem statement?**<br>  - Yes, but HOW must be precise about uniqueness checking, entry creation, and navigation.<br><br>- **HOW to implement:**<br><br>1. **Trigger:**  <br>   - Called when user presses "Add/Edit Diary" in the modal for a meditation entry.<br><br>2. **Step-by-step Implementation:**<br>   1. **Determine meditation timestamp:**  <br>      - Get timestamp for selected meditation entry (from modal state, e.g., `selectedMeditation.timestamp`).<br>   2. **Check for existing DiaryEntry:**  <br>      - Consult Zustand diaryEntries slice:<br>        ```typescript<br>        const existing = diaryEntriesStore.entries.find(<br>            entry => entry.timestamp === selectedMeditation.timestamp<br>        );<br>        ```<br>   3. **Handle uniqueness:**<br>      - If `existing` is found:<br>        - Block UI from creating a new diary entry (disable Add button if already attached, or show "Edit Diary" instead)<br>        - On "Edit Diary", navigate to editor with entryId/timestamp:<br>          ```typescript<br>          navigation.navigate('DiaryEntryEditor', { timestamp: selectedMeditation.timestamp });<br>          ```<br>      - If no `existing`:<br>        - Prepare a new DiaryEntry object (not persisted yet), with:<br>          - `timestamp`: selectedMeditation.timestamp (must be ISO8601)<br>          - `content`: ""<br>        - Navigate to DiaryEntryEditor with this timestamp:<br>          ```typescript<br>          navigation.navigate('DiaryEntryEditor', { timestamp: selectedMeditation.timestamp });<br>          ```<br>         - Editor will initialize in "create" mode.<br>   4. **UI Enforcement:**<br>      - Disable Add button in UI if a diary entry with this timestamp exists.<br>      - Editor and SQLite must refuse to save a duplicate diary entry with same timestamp (PK enforced).<br>   5. **Data Handling:**<br>      - All data passed to DiaryEntryEditor must match DiaryEntry interface and use ISO8601 timestamp.<br><br>3. **Edge Cases:**<br>   - If timestamp is invalid (not ISO8601), show error and block navigation.<br>   - If user tries to force duplicate (should not be possible via UI), editor/store must block save.<br><br>4. **Performance:**<br>   - In-memory lookup in diaryEntries is O(n) (n = diary entries for day), but dataset is small.<br><br>5. **Pseudocode Example:**<br>   ```typescript<br>   function handleDiaryButtonPress() {<br>       const ts = selectedMeditation.timestamp;<br>       const existing = diaryEntriesStore.entries.find(entry => entry.timestamp === ts);<br>       if (existing) {<br>           // Already exists: edit existing<br>           navigation.navigate('DiaryEntryEditor', { timestamp: ts });<br>       } else {<br>           // No diary entry: create new, pass timestamp as param<br>           navigation.navigate('DiaryEntryEditor', { timestamp: ts });<br>       }<br>   }<br>   ```<br>6. **Invariant:**<br>   - No two diary entries may exist with same timestamp as a meditation (enforced at UI and DB).<br><br>--- |
| CalendarView | handleDiaryViewPress(): void | Bound as the onPress handler for the Diary View button. Calls `navigation.navigate('DiaryView')` to transition to the DiaryView screen. No data mutation or state update occurs here; only navigation is triggered. No data transformation is required. |  |
| CalendarView | handleBackPress(): void | Bound as the onPress handler for the Back button. Calls `navigation.navigate('MainScreen')`. Optionally captures current scroll position and selected date in local React state or ref for UI restoration. No mutation of Zustand or SQLite; purely navigation and ephemeral UI. Data handling: if state is captured, ensure it is serializable and restorable on return. |  |
| CalendarView | handleSqlTransactionError(error: Error): void | Bound as the error handler for SQLite transaction failures. Receives an Error object (from expo-sqlite transaction). Displays an error via React Native Paper Snackbar/Dialog, using the error‚Äôs message. Rolls back affected Zustand store slices (`meditationLogs`, `diaryEntries`) to their last consistent state‚Äîeither from memory cache or by requerying from SQLite. Triggers UI refresh as Zustand updates. Data handling: guarantee no partial/inconsistent state in store or UI; all affected slices must revert to last-known-good, using only validated entries per static models. | - **Is the Method description unequivocally aligned with the problem statement?**<br>  - Yes; the method must show error UI and roll back store slices in case of SQLite error.<br><br>- **HOW to implement:**<br><br>1. **Trigger:**  <br>   - Called as the error callback for any SQLite transaction (expo-sqlite), e.g. in:<br>     ```typescript<br>     db.transaction(tx => { ... }, error => handleSqlTransactionError(error));<br>     ```<br><br>2. **Step-by-step Implementation:**<br>   1. **Display Error:**  <br>      - Show Snackbar/Dialog using React Native Paper, with error.message:<br>        ```typescript<br>        setSnackbarMsg(error.message);<br>        setSnackbarVisible(true);<br>        ```<br>   2. **Rollback Store Slices:**  <br>      - For all affected data (e.g., meditationLogs, diaryEntries), re-read latest records from SQLite.<br>        - For affected entity/table:<br>          1. Execute SELECT to fetch all valid, persisted records.<br>          2. Validate records (conform to static TS models).<br>          3. Update Zustand store slices with these re-fetched, valid records.<br>            ```typescript<br>            meditationLogsStore.setLogs(fetchedLogs);<br>            diaryEntriesStore.setEntries(fetchedEntries);<br>            ```<br>      - Do not rely on in-memory data; always use persisted SQLite values to guarantee consistency.<br>   3. **UI Refresh:**  <br>      - Zustand/React will re-render CalendarView and all dependent components based on updated store slices.<br>   4. **No partial state:**  <br>      - Ensure that if multiple slices are affected, all are reverted to last SQLite-committed state.<br>   5. **Timing:**  <br>      - Rollback and error display must be synchronous or blocking: no further UI actions should proceed until rollback completes.<br><br>3. **Edge Cases:**<br>   - If rollback SELECT fails, surface separate error and prompt user to relaunch app.<br>   - No optimistic UI‚Äîonly confirm data changes after SQLite transaction success.<br><br>4. **Pseudocode Example:**<br>   ```typescript<br>   function handleSqlTransactionError(error) {<br>       setSnackbarMsg(error.message);<br>       setSnackbarVisible(true);<br>       // Rollback logs<br>       db.executeSql('SELECT * FROM MeditationsLog', [], (_, { rows }) => {<br>           const logs = rows._array.filter(validMeditationLogEntry);<br>           meditationLogsStore.setLogs(logs);<br>       });<br>       // Rollback diary entries<br>       db.executeSql('SELECT * FROM DiaryEntries', [], (_, { rows }) => {<br>           const entries = rows._array.filter(validDiaryEntry);<br>           diaryEntriesStore.setEntries(entries);<br>       });<br>   }<br>   ```<br>5. **Invariant:**  <br>   - Zustand always matches SQLite; error UI is shown to user and not dismissed until user acknowledges.<br><br>--- |
| CalendarView | handleOpenDiary(meditationTimestamp: string): void | Bound as the onPress handler for the diary icon/button for a meditation entry. Calls `navigation.navigate('DiaryEntryEditor', { timestamp: meditationTimestamp })`. DiaryEntryEditor loads or creates an entry with that timestamp. No local state changes in CalendarView. Data handling: ensures timestamp is ISO8601 and unique, matches DiaryEntry PK. |  |
| DiaryView | handleEditDiaryEntry(timestamp: string): void | Bound as the onPress handler for the edit button on a diary entry. Calls `navigation.navigate('DiaryEntryEditor', { timestamp })`. DiaryEntryEditor loads the entry from Zustand/expo-sqlite, validated per DiaryEntry constraints. Only navigation is performed here; no state mutation in DiaryView. Data responsibility: ensure timestamp passed matches DiaryEntry PK, is ISO8601. |  |
| DiaryView | handleAddDiaryEntry(): void | Bound as the onPress handler for the add button. Calls `navigation.navigate('DiaryEntryEditor', { timestamp: now })`, where `now` is the current ISO8601 timestamp. DiaryEntryEditor initializes with blank content and the passed timestamp, disabling Save/Arrow until valid. Only navigation occurs; no mutation in DiaryView. Data handling: ensures timestamp is valid and unique. |  |
| DiaryView | handleExportDiary(): Promise<void> | <br><br>`handleExportDiary(): Promise<void>`<br><br>This method now only retrieves and sorts diary entries, then delegates YAML serialization:<br><br>1. Calls `DiaryExportYAMLSerializer.serialize(diaryEntries)` to obtain the export YAML string.<br>2. Passes the YAML to the sharing API.<br>3. Handles any errors by surfacing them through UI.<br><br>All mapping, sorting, and YAML schema logic is now owned solely by the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public async handleExportDiary(): Promise<void> {<br>    const sortedEntries = [...this.diaryEntries].sort((a, b) => a.timestamp.localeCompare(b.timestamp));<br>    const yamlStr = DiaryExportYAMLSerializer.serialize(sortedEntries);<br>    await Share.open({ title: 'Export Diary Entries', message: yamlStr });<br>}<br>```<br><br>--- |  |
| StatisticsPage | handlePeriodChange(period: string): void | Called by user interaction (e.g., RadioButton.Group onValueChange or ButtonGroup onPress) with time period selector. Receives a period string (e.g., "1M", "3M", ...). Updates the selected period in local state (or via `setSelectedPeriod`). Calls `aggregateStatistics(period)` to recalculate summary statistics, chart data, legend, and Share button state. Passes recalculated data to react-native-chart-kit for chart rendering. Data handling: must validate period string (matches allowed values), ensure chart aggregation logic matches selected period, and that summary/chart data types match expected chart-kit and export interfaces. |  |
| StatisticsPage | handleSharePress(): Promise<void> | <br><br>`handleSharePress(): Promise<void>`<br><br>This method now delegates all statistics YAML serialization to the helper:<br><br>1. Calls `StatisticsYAMLExportHelper.serializeToYAML(summary, byPeriod)`.<br>2. Opens the sharing dialog with the generated YAML.<br>3. Handles any errors as needed.<br><br>**Code Example:**<br><br>```typescript<br>public async handleSharePress(): Promise<void> {<br>    const yamlStr = StatisticsYAMLExportHelper.serializeToYAML(this.summary, this.byPeriod);<br>    await openShareDialog(yamlStr);<br>}<br>```<br><br> |  |
| StatisticsPage | openShareDialog(yamlData: string): Promise<void> | Calls `Share.open({ message: yamlData })` from react-native-share to open system share dialog for YAML export. Only accepts pre-validated, correctly formatted YAML. Returns a Promise that resolves upon dialog close. Data handling: ensures that only one share is in progress at a time; disables further actions until resolved. Handles any library or share errors by propagating to error UI or resetting state. |  |
| StatisticsPage | handleMeditationsLogUpdate(): void | <br><br>`handleMeditationsLogUpdate(): void`<br><br>This method now delegates all aggregation logic to the aggregator:<br><br>1. Calls `StatisticsAggregator.aggregateStatistics(meditationLogs, selectedPeriod, locale)`.<br>2. Updates local/UI state with the returned `summary`, `byPeriod`, and `chartData`.<br><br>**Code Example:**<br><br>```typescript<br>public handleMeditationsLogUpdate(): void {<br>    try {<br>        this.setChartError(null);<br>        const { summary, byPeriod, chartData } = StatisticsAggregator.aggregateStatistics(<br>            this.meditationLogs,<br>            this.selectedPeriod,<br>            this.locale<br>        );<br>        this.setSummary(summary);<br>        this.setByPeriod(byPeriod);<br>        this.setChartData(chartData);<br>    } catch (error: any) {<br>        this.setChartError('Statistics calculation error.');<br>    }<br>}<br>```<br><br> |  |
| StatisticsPage | handleChartError(error: Error): void | <br><br>`handleChartError(error: Error): void`<br><br>This method now simply calls the chart error manager delegate to map error objects to user-facing messages:<br><br>**Code Example:**<br><br>```typescript<br>public handleChartError(error: Error): void {<br>    const errorMsg = StatisticsChartErrorManager.getChartErrorMessage(error);<br>    this.setChartError(errorMsg);<br>}<br>```<br><br>--- |  |
| StatisticsPage | handleShareSheetClosed(): void | Called in `.then` or `.finally` handler when react-native-share dialog closes. Resets local or Zustand `isSharing` flag to false, re-enables Share button, and clears any temporary sharing state (spinners, error messages). Ensures that no further share attempts can be triggered during share, and that UI recovers promptly after dialog closes. Data handling: strict control of sharing state, no leaks across component or store. |  |
| SettingsStore | handleSettingsChange(changedSettings: Partial<Settings>): void | <br><br>`handleSettingsChange(changedSettings: Partial<Settings>): void`<br><br>This method now merges the partial settings, validates, and persists using the delegate:<br><br>1. Merges `changedSettings` into current settings.<br>2. Calls `this.persistenceDelegate.validateSettings(nextSettings)` to validate.<br>3. Updates Zustand‚Äôs in-memory state.<br>4. Calls `this.persistenceDelegate.saveSettings(nextSettings)` to persist.<br><br>All validation and persistence logic is handled by the delegate.<br><br>**Code Example:**<br><br>```typescript<br>public handleSettingsChange(changedSettings: Partial<Settings>): void {<br>    const prev = this.get().settings;<br>    const next: Settings = { ...prev, ...changedSettings };<br>    this.persistenceDelegate.validateSettings(next);<br>    this.set({ settings: next });<br>    this.persistenceDelegate.saveSettings(next);<br>}<br>```<br><br> |  |
| SettingsStore | setDndEnabled(value: boolean): void | <br><br>`setDndEnabled(value: boolean): void`<br><br>This method now updates state and calls the delegate to persist:<br><br>**Code Example:**<br><br>```typescript<br>public setDndEnabled(value: boolean): void {<br>    this.set(state => ({ settings: { ...state.settings, dndEnabled: value } }));<br>    this.persistenceDelegate.saveField('dndEnabled', value);<br>}<br>```<br><br> |  |
| SettingsStore | setKeepScreenOn(value: boolean): void | <br><br>`setKeepScreenOn(value: boolean): void`<br><br>**Code Example:**<br><br>```typescript<br>public setKeepScreenOn(value: boolean): void {<br>    this.set(state => ({ settings: { ...state.settings, keepScreenOn: value } }));<br>    this.persistenceDelegate.saveField('keepScreenOn', value);<br>}<br>```<br><br> |  |
| SettingsStore | setCountUp(value: boolean): void | <br><br>`setCountUp(value: boolean): void`<br><br>**Code Example:**<br><br>```typescript<br>public setCountUp(value: boolean): void {<br>    this.set(state => ({ settings: { ...state.settings, countUp: value } }));<br>    this.persistenceDelegate.saveField('countUp', value);<br>}<br>```<br><br> |  |
| SettingsStore | setBackupEnabled(value: boolean): void | <br><br>`setBackupEnabled(value: boolean): void`<br><br>**Code Example:**<br><br>```typescript<br>public setBackupEnabled(value: boolean): void {<br>    this.set(state => ({ settings: { ...state.settings, backupEnabled: value } }));<br>    this.persistenceDelegate.saveField('backupEnabled', value);<br>}<br>```<br><br> |  |
| SettingsStore | setAdsFreePurchased(purchased: boolean): Promise<void> | <br><br>`setAdsFreePurchased(purchased: boolean): Promise<void>`<br><br>This method now updates state and persists via the delegate:<br><br>**Code Example:**<br><br>```typescript<br>public async setAdsFreePurchased(purchased: boolean): Promise<void> {<br>    this.set(state => ({ settings: { ...state.settings, adsFreePurchased: purchased } }));<br>    await this.persistenceDelegate.saveField('adsFreePurchased', purchased);<br>}<br>```<br><br> |  |
| SettingsStore | setBackgroundImage(imageRef: string): Promise<void> | <br><br>`setBackgroundImage(imageRef: string): Promise<void>`<br><br>**Code Example:**<br><br>```typescript<br>public async setBackgroundImage(imageRef: string): Promise<void> {<br>    this.set(state => ({ settings: { ...state.settings, sessionBackgroundImage: imageRef } }));<br>    await this.persistenceDelegate.saveField('sessionBackgroundImage', imageRef);<br>}<br>```<br><br> |  |
| SettingsStore | setHydratedSettings(settings: Settings): void | <br><br>`setHydratedSettings(settings: Settings): void`<br><br>**Code Example:**<br><br>```typescript<br>public setHydratedSettings(settings: Settings): void {<br>    this.persistenceDelegate.validateSettings(settings);<br>    this.set({ settings: { ...settings } });<br>}<br>```<br><br> |  |
| SettingsStore | setDefaults(): void | <br><br>`setDefaults(): void`<br><br>**Code Example:**<br><br>```typescript<br>public async setDefaults(): Promise<void> {<br>    const defaults = await this.persistenceDelegate.setDefaults();<br>    this.set({ settings: { ...defaults } });<br>}<br>```<br><br> |  |
| SettingsStore | revertToPersistedSettings(): Promise<void> | <br><br>`revertToPersistedSettings(): Promise<void>`<br><br>**Code Example:**<br><br>```typescript<br>public async revertToPersistedSettings(): Promise<void> {<br>    const restored = await this.persistenceDelegate.revertToPersistedSettings();<br>    this.set({ settings: { ...restored } });<br>}<br>```<br><br>---<br><br>End of report.<br>```` |  |
| SettingsMenu | handleThemeSelect(color: string): void | Receives the theme color selected by user (palette ID or color string). Validates color input, dispatches `setTheme(color)` action to the Zustand store, and persists the new theme value to AsyncStorage or SecureStore. Propagates the updated theme to the React Native Paper Provider for live UI update. No return value; handles side effects as described. |  |
| SettingsMenu | launchImagePicker(): Promise<void> | <br><br>`launchImagePicker(): Promise<void>`<br><br>**Refactored Contract:**  <br>This method initiates the device's image picker dialog, deferring all picker logic and callback handling to the `SettingsBackgroundImagePicker` delegate.<br><br>- The parent no longer interacts with `expo-image-picker` APIs or handles picker results directly.<br>- All picker launching and result delivery is managed by the delegate.<br>- The parent supplies its own method to handle the result (e.g., its own `onImagePicked`), which will be called by the delegate.<br><br>**Implementation:**<br><br>```ts<br>public async launchImagePicker(): Promise<void> {<br>    // Assumes this.backgroundImagePicker is always initialized.<br>    await this.backgroundImagePicker.launchImagePicker(this.onImagePicked.bind(this));<br>}<br>```<br><br> |  |
| SettingsMenu | onImagePicked(result: { cancelled: boolean, uri?: string }): Promise<void> | <br><br>`onImagePicked(result: { cancelled: boolean, uri?: string }): Promise<void>`<br><br>**Refactored Contract:**  <br>This method handles the result from the image picker dialog, delegating all validation, image persistence, and dialog closure logic to `SettingsBackgroundImagePicker`.<br><br>- The parent does not validate URIs or update background images directly.<br>- The parent delegates to the image picker handler, supplying both a callback to set the background image and a callback to close the dialog.<br><br>**Implementation:**<br><br>```ts<br>public async onImagePicked(result: { cancelled: boolean, uri?: string }): Promise<void> {<br>    await this.backgroundImagePicker.handleImagePicked(<br>        result,<br>        this.setBackgroundImage.bind(this), // parent method to persist the image<br>        this.dialogManager.closeImageDialog.bind(this.dialogManager)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | handleExportDiary(): Promise<void> | <br><br>`handleExportDiary(): Promise<void>`<br><br>**Refactored Contract:**  <br>This method is responsible for exporting all persisted diary entries, serializing them, and invoking the system share dialog. All diary export and sharing logic is now offloaded to `SettingsSharingExportHandler`.<br><br>- The parent no longer serializes diary entries or manages share dialogs or feedback.<br>- The delegate is passed all diary entries and a callback for error dialogs.<br><br>**Implementation:**<br><br>```ts<br>public async handleExportDiary(): Promise<void> {<br>    await this.sharingExportHandler.exportDiary(<br>        this.diaryEntries,<br>        this.dialogManager.setErrorDialog.bind(this.dialogManager)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | handleBuiltInImageSelect(imageRef: string): void | <br><br>`handleBuiltInImageSelect(imageRef: string): void`<br><br>**Refactored Contract:**  <br>This method handles built-in background image selection. All logic for validation and updating is now delegated to `SettingsBackgroundImagePicker`.<br><br>- The parent does not validate the reference or persist images itself.<br>- The delegate is provided with the reference, a setter callback, and a dialog close method.<br><br>**Implementation:**<br><br>```ts<br>public async handleBuiltInImageSelect(imageRef: string): Promise<void> {<br>    await this.backgroundImagePicker.handleBuiltInImageSelect(<br>        imageRef,<br>        this.setBackgroundImage.bind(this),<br>        this.dialogManager.closeImageDialog.bind(this.dialogManager)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | handleToggleDND(value: boolean): Promise<void> | Receives the intended DND enabled/disabled state. Calls `react-native-do-not-disturb` API to request/check permission. If granted, dispatches `SettingsStore.setDndEnabled(value)` and persists to storage. If denied, triggers a UI error message (Snackbar/Dialog) and disables the toggle. Handles async permission/result logic and state update/rollback as needed. |  |
| SettingsMenu | handleToggleKeepScreenOn(value: boolean): void | Receives the new state for keeping screen on. Dispatches `SettingsStore.setKeepScreenOn(value)` and persists it. UI toggle state and effect on MeditationSessionWindow component are handled by store reactivity; this method only updates state and persistence. |  |
| SettingsMenu | handleToggleCountUp(value: boolean): void | Receives intended value for the CountUp flag. Dispatches `SettingsStore.setCountUp(value)` and persists. MeditationSessionWindow reads this at session start. Ensures only boolean values, with immediate store and persistence update. |  |
| SettingsMenu | handleToggleBackupEnabled(value: boolean): Promise<void> | Receives intended backup enabled state, dispatches `SettingsStore.setBackupEnabled(value)` and persists. If enabling, registers a daily backup job using `expo-background-fetch` and `expo-task-manager`; if disabling, unregisters. Handles async registration/unregistration and UI update via Zustand. |  |
| SettingsMenu | handleToggleAdsFree(value: boolean): Promise<void> | Receives the intended ads-free state (generally `true` after a purchase). Updates Zustand store via `SettingsStore.setAdsFreePurchased(value)` and persists to SQLite. All AdBanner components are automatically updated due to store reactivity. If purchase flow needed, triggers `handleRemoveAds`. |  |
| SettingsMenu | handleNavigateToDiarySharing(): void | Triggers React Navigation to transition to the Diary Sharing screen (e.g., `navigation.navigate('DiarySharing')`). No parameters, no business logic, no return value. |  |
| SettingsMenu | handleRestoreBackup(): Promise<void> | <br><br>`handleRestoreBackup(): Promise<void>`<br><br>**Refactored Contract:**  <br>This method initiates the restore process via file picker. All dialog interaction and callback handling are delegated to `SettingsRestoreBackupHandler`.<br><br>- The parent does not launch file pickers or parse results directly.<br>- The delegate is given callbacks for when a restore file is selected and for error dialogs.<br><br>**Implementation:**<br><br>```ts<br>public async handleRestoreBackup(): Promise<void> {<br>    await this.restoreBackupHandler.initiateRestoreViaFilePicker(<br>        (fileUri) => this.dialogManager.openRestoreDialog({ filePath: fileUri, timestamp: new Date().toISOString() }),<br>        this.dialogManager.setErrorDialog.bind(this.dialogManager)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | onFilePicked(result: { cancelled: boolean, uri?: string }): Promise<void> | <br><br>`onFilePicked(result: { cancelled: boolean, uri?: string }): Promise<void>`<br><br>**Refactored Contract:**  <br>All logic for handling the picked file and invoking restore is now handled by the delegate. The parent routes file URIs to the delegate and provides error dialog callbacks.<br><br>- Any logic about direct file restore or dialog management is offloaded.<br><br>**Implementation:**<br><br>```ts<br>public async onFilePicked(result: { cancelled: boolean, uri?: string }): Promise<void> {<br>    if (!result.cancelled && result.uri) {<br>        await this.restoreBackupHandler.confirmRestore(<br>            { filePath: result.uri, timestamp: new Date().toISOString() },<br>            () => {<br>                this.dialogManager.setSnackbar('Database restored from backup.');<br>                this.dialogManager.closeRestoreDialog();<br>            },<br>            this.dialogManager.setErrorDialog.bind(this.dialogManager)<br>        );<br>    }<br>}<br>```<br><br> |  |
| SettingsMenu | handleCloseDrawer(): void | Signals the Drawer component (RN Paper or Navigation) to close. No business logic, no parameters or return value. UI state is updated by the Drawer system. |  |
| SettingsMenu | onPermissionResult(status: 'granted' or 'denied' or 'blocked' or 'unavailable'): void | Receives the result of a permission API (DND, storage, etc.). If not 'granted', triggers a UI error message (Snackbar/Dialog) and disables or greys out relevant UI controls via component state. If 'granted', proceeds with any pending action. Handles result branching and UI state only. |  |
| SettingsMenu | handleZustandSettingsUpdate(): void | Internal method or effect; triggered automatically whenever the Zustand settings store is updated. No parameters or return value. Causes the component to re-render and UI to reflect new store values. No other logic. |  |
| SettingsMenu | handleRestoreBackupPress(backupMeta: BackupMeta): void | <br><br>`handleRestoreBackupPress(backupMeta: BackupMeta): void`<br><br>**Refactored Contract:**  <br>This method handles the user-initiated action to restore from a backup listed in metadata. It now delegates dialog and confirmation management to `SettingsDialogManager`.<br><br>- The parent no longer manages dialog state directly.<br>- Only the dialog manager is called.<br><br>**Implementation:**<br><br>```ts<br>public handleRestoreBackupPress(backupMeta: BackupMeta): void {<br>    this.dialogManager.openRestoreDialog(backupMeta);<br>}<br>```<br><br> |  |
| SettingsMenu | handleConfirmRestore(backupMeta: BackupMeta): Promise<void> | <br><br>`handleConfirmRestore(backupMeta: BackupMeta): Promise<void>`<br><br>**Refactored Contract:**  <br>This method confirms the restore action for a selected backup. All file validation, restore, and feedback logic are now delegated to `SettingsRestoreBackupHandler`.<br><br>- Parent only delegates, passing success and error callbacks for UI updates.<br><br>**Implementation:**<br><br>```ts<br>public async handleConfirmRestore(): Promise<void> {<br>    if (!this.dialogManager.pendingRestoreMeta) return;<br>    await this.restoreBackupHandler.confirmRestore(<br>        this.dialogManager.pendingRestoreMeta,<br>        () => {<br>            this.dialogManager.setSnackbar('Database restored from backup.');<br>            this.dialogManager.closeRestoreDialog();<br>        },<br>        this.dialogManager.setErrorDialog.bind(this.dialogManager)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | handleRemoveAds(): Promise<void> | <br><br>`handleRemoveAds(): Promise<void>`<br><br>**Refactored Contract:**  <br>Initiates the in-app purchase flow to remove ads. All purchase state, listener management, and outcome handling is fully offloaded to `SettingsMonetizationHandler`.<br><br>- The parent simply invokes the delegate, passing its own success/failure handlers.<br><br>**Implementation:**<br><br>```ts<br>public async handleRemoveAds(): Promise<void> {<br>    await this.monetizationHandler.startRemoveAdsPurchase(<br>        this.handlePurchaseSuccess.bind(this),<br>        this.handlePurchaseFailure.bind(this)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | handlePurchaseSuccess(result: any): Promise<void> | <br><br>`handlePurchaseSuccess(result: any): Promise<void>`<br><br>**Refactored Contract:**  <br>Handles successful ad removal purchase. Only updates persisted store and surfaces feedback. All in-app purchase mechanics are handled by the delegate.<br><br>**Implementation:**<br><br>```ts<br>public async handlePurchaseSuccess(_result: any): Promise<void> {<br>    await this.setAdsFreePurchased(true);<br>    this.monetizationHandler.isPurchasing = false;<br>    this.dialogManager.setSnackbar('Ads removed successfully!');<br>}<br>```<br><br> |  |
| SettingsMenu | handlePurchaseFailure(result: any): void | <br><br>`handlePurchaseFailure(result: any): void`<br><br>**Refactored Contract:**  <br>Handles failure/cancellation of ad removal purchase. Only UI dialog/snackbar is managed here. All error detection and state management is handled by the delegate.<br><br>**Implementation:**<br><br>```ts<br>public handlePurchaseFailure(msg: string): void {<br>    this.dialogManager.setErrorDialog(msg or 'Purchase failed or cancelled.');<br>    this.monetizationHandler.isPurchasing = false;<br>}<br>```<br><br> |  |
| SettingsMenu | restorePurchase(): Promise<void> | <br><br>`restorePurchase(): Promise<void>`<br><br>**Refactored Contract:**  <br>Initiates restoration of ad-removal purchase. All state, listener, and async result handling are delegated to `SettingsMonetizationHandler`. The parent only passes callbacks.<br><br>**Implementation:**<br><br>```ts<br>public async restorePurchase(): Promise<void> {<br>    await this.monetizationHandler.startRestorePurchase(<br>        this.handleRestoreSuccess.bind(this),<br>        this.handleRestoreFailure.bind(this)<br>    );<br>}<br>```<br><br> |  |
| SettingsMenu | handleRestoreSuccess(result: any): Promise<void> | <br><br>`handleRestoreSuccess(result: any): Promise<void>`<br><br>**Refactored Contract:**  <br>Handles successful restoration. Only persists state and surfaces feedback. All purchase flow is handled by delegate.<br><br>**Implementation:**<br><br>```ts<br>public async handleRestoreSuccess(_result: any): Promise<void> {<br>    await this.setAdsFreePurchased(true);<br>    this.monetizationHandler.isRestoringPurchase = false;<br>    this.dialogManager.setSnackbar('Restored purchase successfully!');<br>}<br>```<br><br> |  |
| SettingsMenu | handleRestoreFailure(result: any): void | <br><br>`handleRestoreFailure(result: any): void`<br><br>**Refactored Contract:**  <br>Handles restore failure/cancelled. Only dialog/snackbar feedback. All error detection is handled in delegate.<br><br>**Implementation:**<br><br>```ts<br>public handleRestoreFailure(msg: string): void {<br>    this.dialogManager.setErrorDialog(msg or 'Restore failed or cancelled.');<br>    this.monetizationHandler.isRestoringPurchase = false;<br>}<br>```<br><br> |  |
| SettingsMenu | handleBuyMeACoffee(): void | On press, either calls `Linking.openURL(donationUrl)` to open an external donation page or invokes `react-native-share` with a pre-filled message. No input, no return. Handles only side effects; UI feedback managed by Paper Button. |  |
| SettingsMenu | handleShareApp(): Promise<void> | <br><br>`handleShareApp(): Promise<void>`<br><br>**Refactored Contract:**  <br>Handles app sharing via system share dialog. All share dialog invocation and state are handled by `SettingsSharingExportHandler`.<br><br>**Implementation:**<br><br>```ts<br>public async handleShareApp(): Promise<void> {<br>    await this.sharingExportHandler.shareApp(this.dialogManager.setErrorDialog.bind(this.dialogManager));<br>}<br>```<br><br> |  |
| SettingsMenu | handleRateUs(): Promise<void> | <br><br>`handleRateUs(): Promise<void>`<br><br>**Refactored Contract:**  <br>Opens the app's Play Store page for rating. All navigation and error handling are delegated to `SettingsSharingExportHandler`.<br><br>**Implementation:**<br><br>```ts<br>public async handleRateUs(): Promise<void> {<br>    await this.sharingExportHandler.rateUs(this.dialogManager.setErrorDialog.bind(this.dialogManager));<br>}<br>```<br><br>--- |  |
| SettingsMenu | handleViewStatistics(): void | Bound to the onPress handler for the "View Statistics" list item. When triggered, uses React Navigation to navigate to the "StatisticsPage" screen. On navigation, ensures that the default period selector state is set (e.g., "1M"), and the page subscribes to the Meditations Log slice in Zustand. Aggregation logic in the StatisticsPage (not this handler) will prepare summary/chart data. No data transformation is performed in this method; its responsibility is limited to navigation. |  |
| NotificationManager | scheduleOrUpdateReminder(timerId: string, reminderData: NotificationRecord): Promise<void> | <br><br>`scheduleOrUpdateReminder(timerId: string, reminderData: NotificationRecord): Promise<void>`<br><br>**Refactored Contract:**<br><br>Schedules or updates a local reminder for a session timer by delegating to:<br><br>- `NotificationSQLiteHelper` for DB persistence (insert/update notification record)<br>- `NotificationTimeTriggerGenerator` for trigger object computation<br><br>All DB queries, inserts, updates, and time trigger calculations are performed by delegates.<br><br>**Implementation:**<br><br>```ts<br>public async scheduleOrUpdateReminder(timerId: string, reminderData: NotificationRecord): Promise<void> {<br>    await this.sqliteHelper.upsertNotificationRecord(NOTIFICATIONS_TABLE, reminderData);<br><br>    const { triggerDate, triggerObject } = this.triggerGenerator.computeNextTrigger(<br>        new Date(),<br>        reminderData.time,<br>        reminderData.frequency<br>    );<br><br>    const notificationId = await Notifications.scheduleNotificationAsync({<br>        content: { /* ... */ },<br>        trigger: triggerObject<br>    });<br><br>    await this.sqliteHelper.updateNotificationId(NOTIFICATIONS_TABLE, timerId, notificationId);<br>}<br>```<br><br> |  |
| NotificationManager | cancelReminder(timerId: string): Promise<void> | <br><br>`cancelReminder(timerId: string): Promise<void>`<br><br>**Refactored Contract:**<br><br>Cancels a scheduled notification by:<br><br>- Querying for reminders with `NotificationSQLiteHelper`<br>- Cancelling notifications via Expo Notifications<br>- Removing DB records using the delegate<br><br>No inline SQL, all operations use delegate helpers.<br><br>**Implementation:**<br><br>```ts<br>public async cancelReminder(timerId: string): Promise<void> {<br>    const reminders = await this.sqliteHelper.queryRemindersByTimerId(NOTIFICATIONS_TABLE, timerId);<br>    for (const reminder of reminders) {<br>        await Notifications.cancelScheduledNotificationAsync(reminder.id);<br>        await this.sqliteHelper.deleteNotificationById(NOTIFICATIONS_TABLE, reminder.id);<br>    }<br>}<br>```<br><br> |  |
| NotificationManager | cancelAllRemindersForTimer(timerId: string): Promise<void> | <br><br>`cancelAllRemindersForTimer(timerId: string): Promise<void>`<br><br>**Refactored Contract:**<br><br>Cancels all notifications for a timer using:<br><br>- Delegate to find all relevant reminders<br>- Cancels scheduled notifications<br>- Delegate to delete all records for timer<br><br>**Implementation:**<br><br>```ts<br>public async cancelAllRemindersForTimer(timerId: string): Promise<void> {<br>    const reminders = await this.sqliteHelper.queryRemindersByTimerId(NOTIFICATIONS_TABLE, timerId);<br>    for (const reminder of reminders) {<br>        await Notifications.cancelScheduledNotificationAsync(reminder.id);<br>    }<br>    await this.sqliteHelper.deleteNotificationsByTimerId(NOTIFICATIONS_TABLE, timerId);<br>}<br>```<br><br> |  |
| NotificationManager | loadAllRemindersFromDB(): Promise<void> | <br><br>`loadAllRemindersFromDB(): Promise<void>`<br><br>**Refactored Contract:**<br><br>Loads all enabled reminders using the delegate, passing parsed domain objects to Zustand state.<br><br>**Implementation:**<br><br>```ts<br>public async loadAllRemindersFromDB(): Promise<void> {<br>    const reminders = await this.sqliteHelper.queryEnabledReminders(NOTIFICATIONS_TABLE);<br>    this.notificationsSlice.setReminders(reminders);<br>}<br>```<br><br> |  |
| NotificationManager | syncScheduledNotifications(): Promise<void> | <br><br>`syncScheduledNotifications(): Promise<void>`<br><br>**Refactored Contract:**<br><br>Loads enabled reminders via delegate, compares to system state, and schedules missing as necessary.<br><br>**Implementation:**<br><br>```ts<br>public async syncScheduledNotifications(): Promise<void> {<br>    const dbReminders = await this.sqliteHelper.queryEnabledReminders(NOTIFICATIONS_TABLE);<br>    const scheduled = await Notifications.getAllScheduledNotificationsAsync();<br>    // ...logic to compare and reschedule missing, using delegate helpers for schedule<br>}<br>```<br><br> |  |
| NotificationManager | scheduleReminder(timerId: string, reminderData: NotificationRecord): Promise<void> | <br><br>`scheduleReminder(timerId: string, reminderData: NotificationRecord): Promise<void>`<br><br>**Refactored Contract:**<br><br>Schedules a notification by computing trigger and persisting using delegates.<br><br>**Implementation:**<br><br>```ts<br>public async scheduleReminder(timerId: string, reminderData: NotificationRecord): Promise<void> {<br>    const { triggerDate, triggerObject } = this.triggerGenerator.computeNextTrigger(<br>        new Date(),<br>        reminderData.time,<br>        reminderData.frequency<br>    );<br>    const notificationId = await Notifications.scheduleNotificationAsync({<br>        content: { /* ... */ },<br>        trigger: triggerObject<br>    });<br>    if (reminderData.id !== notificationId) {<br>        await this.sqliteHelper.updateNotificationId(NOTIFICATIONS_TABLE, timerId, notificationId);<br>    }<br>    await this.onNotificationScheduled(notificationId, reminderData);<br>}<br>```<br><br> |  |
| NotificationManager | handleNotificationResponse(response: Notifications.NotificationResponse): Promise<void> | Handles notification interaction events (fired by `Notifications.addNotificationResponseReceivedListener`). Receives a response object as defined by expo-notifications, parses the Session Timer Id from its payload/data property. Validates the extracted timerId, then uses React Navigation (via NavigationLayer) to navigate to the relevant Session Timer screen. Calls `TimerStateStore.loadSessionTimer(timerId)` to ensure corresponding data is loaded in the destination screen. Handles any navigation or loading errors. |  |
| NotificationManager | onNotificationScheduled(notificationId: string, data: NotificationRecord): Promise<void> | <br><br>`onNotificationScheduled(notificationId: string, data: NotificationRecord): Promise<void>`<br><br>**Refactored Contract:**<br><br>Persists notification info via delegate.<br><br>**Implementation:**<br><br>```ts<br>public async onNotificationScheduled(notificationId: string, data: NotificationRecord): Promise<void> {<br>    await this.sqliteHelper.upsertNotificationRecord(NOTIFICATIONS_TABLE, { ...data, id: notificationId });<br>}<br>```<br><br> |  |
| NotificationManager | onNotificationCancel(notificationId: string): Promise<void> | <br><br>`onNotificationCancel(notificationId: string): Promise<void>`<br><br>**Refactored Contract:**<br><br>Removes notification record via delegate.<br><br>**Implementation:**<br><br>```ts<br>public async onNotificationCancel(notificationId: string): Promise<void> {<br>    await this.sqliteHelper.deleteNotificationById(NOTIFICATIONS_TABLE, notificationId);<br>}<br>```<br><br> |  |
| NotificationManager | onNotificationScheduleFailure(error: Error): Promise<void> | <br><br>`onNotificationScheduleFailure(error: Error): Promise<void>`<br><br>**Refactored Contract:**<br><br>Handles error rollback by calling the delegate, which rehydrates from DB and rethrows the error.<br><br>**Implementation:**<br><br>```ts<br>public async onNotificationScheduleFailure(error: Error): Promise<void> {<br>    await this.errorHandler.handleError(<br>        NOTIFICATIONS_TABLE,<br>        this.loadAllRemindersFromDB.bind(this),<br>        error<br>    );<br>}<br>```<br><br>--- |  |
| BackupJobHandler | restoreDatabaseFromFile(fileUri: string): Promise<void> | <br><br>`restoreDatabaseFromFile(fileUri: string): Promise<void>`<br><br>**Refactored Contract:**<br><br>All backup file validation and atomic copy logic is delegated to `BackupFileIOManager`. Concurrency is controlled by `BackupConcurrencyFlagManager`. Entity hydration after restore is handled by `BackupJobHydrationManager`. Meta update is delegated.<br><br>**Implementation:**<br><br>```ts<br>public async restoreDatabaseFromFile(fileUri: string): Promise<void> {<br>    if (!(await this.concurrencyFlagManager.handleConcurrentBackupOrRestoreAttempt())) return;<br>    try {<br>        await this.fileIO.validateBackupFile(fileUri);<br>        await this.fileIO.copyFileToDestination(fileUri, SQLITE_DB_PATH);<br>        await this.hydrationManager.reloadEntitiesFromRestoredDB();<br>        await this.fileIO.saveBackupMetadata(<br>            await this.fileIO.listBackupFilesWithMeta(BACKUP_DIR),<br>            BACKUP_META_KEY<br>        );<br>        await SecureStore.setItemAsync(LAST_BACKUP_TIMESTAMP_KEY, new Date().toISOString());<br>        this.concurrencyFlagManager.resetConcurrencyFlag();<br>    } catch (err) {<br>        this.concurrencyFlagManager.resetConcurrencyFlag();<br>        this.handleBackupOrRestoreError(err);<br>    }<br>}<br>```<br><br> |  |
| BackupJobHandler | registerBackupJob(): Promise<void> | Registers (or re-registers) the daily backup job via expo-background-fetch and expo-task-manager. Ensures only one job is registered at a time. Validates that `backupEnabled` is true before proceeding. Handles any errors from the registration API and updates system state or UI as needed for feedback. |  |
| BackupJobHandler | unregisterBackupJob(): Promise<void> | Unregisters any scheduled backup job using expo-background-fetch/task-manager APIs. Ensures all job handles/tokens are correctly released/removed. Handles any errors thrown by the platform APIs and updates the system/UI state if required. |  |
| BackupJobHandler | handleDatabaseRestore(): Promise<void> | Called after a successful atomic restore of the database file. Calls `NotificationManager.loadAllRemindersFromDB()` to repopulate notification state from the restored DB, then for each enabled reminder not currently scheduled, calls `NotificationManager.scheduleReminder(timerId, reminderData)`. Reloads all entities (session timers, logs, diaries, settings) into Zustand using "hydrate" actions, ensuring UI is refreshed. Handles errors gracefully, rolling back restoration if needed or surfacing errors to the user. |  |
| BackupJobHandler | handleConcurrentBackupOrRestoreAttempt(): Promise<boolean> | <br><br>`handleConcurrentBackupOrRestoreAttempt(): Promise<boolean>`<br><br>**Refactored Contract:**<br><br>Concurrency check and flag setting are fully delegated to `BackupConcurrencyFlagManager`.<br><br>**Implementation:**<br><br>```ts<br>public async handleConcurrentBackupOrRestoreAttempt(): Promise<boolean> {<br>    return await this.concurrencyFlagManager.handleConcurrentBackupOrRestoreAttempt(<br>        this.uiFeedback // (optional UI feedback handler)<br>    );<br>}<br>```<br><br> |  |
| BackupJobHandler | checkBackupEligibility(): Promise<boolean> | <br><br>`checkBackupEligibility(): Promise<boolean>`<br><br>**Refactored Contract:**<br><br>All eligibility logic is delegated to `BackupEligibilityChecker`.<br><br>**Implementation:**<br><br>```ts<br>public async checkBackupEligibility(): Promise<boolean> {<br>    return await this.eligibilityChecker.checkBackupEligibility();<br>}<br>```<br><br> |  |
| BackupJobHandler | executeBackup(): Promise<void> | <br><br>`executeBackup(): Promise<void>`<br><br>**Refactored Contract:**<br><br>All file I/O (directory, filename, copy), meta update, and retention are delegated to `BackupFileIOManager`. Concurrency is managed by `BackupConcurrencyFlagManager`.<br><br>**Implementation:**<br><br>```ts<br>public async executeBackup(): Promise<void> {<br>    if (!(await this.concurrencyFlagManager.handleConcurrentBackupOrRestoreAttempt())) return;<br>    try {<br>        await this.fileIO.ensureDirectoryExists(BACKUP_DIR);<br>        const now = new Date();<br>        const destFile = BACKUP_DIR + this.fileIO.generateBackupFilename(now);<br>        await this.fileIO.copyFileToDestination(SQLITE_DB_PATH, destFile);<br>        await SecureStore.setItemAsync(LAST_BACKUP_TIMESTAMP_KEY, now.toISOString());<br>        await this.fileIO.pruneOldBackups(BACKUP_DIR, MAX_BACKUPS);<br>        await this.fileIO.saveBackupMetadata(<br>            await this.fileIO.listBackupFilesWithMeta(BACKUP_DIR),<br>            BACKUP_META_KEY<br>        );<br>        this.concurrencyFlagManager.resetConcurrencyFlag();<br>    } catch (err) {<br>        this.concurrencyFlagManager.resetConcurrencyFlag();<br>        await this.handleBackupFailure(err);<br>    }<br>}<br>```<br><br> |  |
| BackupJobHandler | cleanupOldBackups(): Promise<void> | <br><br>`cleanupOldBackups(): Promise<void>`<br><br>**Refactored Contract:**<br><br>All retention and file deletion logic is delegated to `BackupFileIOManager`.<br><br>**Implementation:**<br><br>```ts<br>public async cleanupOldBackups(): Promise<void> {<br>    await this.fileIO.pruneOldBackups(BACKUP_DIR, MAX_BACKUPS);<br>}<br>```<br><br> |  |
| BackupJobHandler | updateBackupMetadata(): Promise<void> | <br><br>`updateBackupMetadata(): Promise<void>`<br><br>**Refactored Contract:**<br><br>Lists valid backup files and stores backup meta, fully delegated.<br><br>**Implementation:**<br><br>```ts<br>public async updateBackupMetadata(): Promise<void> {<br>    const backupMeta = await this.fileIO.listBackupFilesWithMeta(BACKUP_DIR);<br>    await this.fileIO.saveBackupMetadata(backupMeta, BACKUP_META_KEY);<br>}<br>```<br><br> |  |
| BackupJobHandler | handleBackupFailure(error: Error): Promise<void> | Called if any error occurs during the backup process. Catches exceptions, returns `BackgroundFetch.Result.Failed` to the Expo background-fetch/task-manager system, triggering system retry per policy. Ensures that backup metadata or app state is not modified on failure. Does not update UI; side effects are system-only. |  |
| BackupJobHandler | executeRestore(selectedBackupFile: { uri: string }): Promise<void> | <br><br>`executeRestore(selectedBackupFile: { uri: string }): Promise<void>`<br><br>**Refactored Contract:**<br><br>Delegates file validation and atomic copy to `BackupFileIOManager`. Handles hydration and concurrency as before.<br><br>**Implementation:**<br><br>```ts<br>public async executeRestore(selectedBackupFile: { uri: string }): Promise<void> {<br>    if (!(await this.concurrencyFlagManager.handleConcurrentBackupOrRestoreAttempt())) return;<br>    try {<br>        await this.fileIO.validateBackupFile(selectedBackupFile.uri);<br>        await this.fileIO.copyFileToDestination(selectedBackupFile.uri, SQLITE_DB_PATH);<br>        await this.hydrationManager.reloadEntitiesFromRestoredDB();<br>        await this.updateBackupMetadata();<br>        this.concurrencyFlagManager.resetConcurrencyFlag();<br>    } catch (err) {<br>        this.concurrencyFlagManager.resetConcurrencyFlag();<br>        this.handleBackupOrRestoreError(err);<br>    }<br>}<br>```<br><br> |  |
| BackupJobHandler | reloadEntitiesFromRestoredDB(): Promise<void> | <br><br>`reloadEntitiesFromRestoredDB(): Promise<void>`<br><br>**Refactored Contract:**<br><br>All hydration logic is delegated to `BackupJobHydrationManager`.<br><br>**Implementation:**<br><br>```ts<br>public async reloadEntitiesFromRestoredDB(): Promise<void> {<br>    await this.hydrationManager.reloadEntitiesFromRestoredDB();<br>}<br>```<br><br>End of report.<br>```` |  |
| BackupJobHandler | handleBackupOrRestoreError(error: Error): Promise<void> | Catches error objects thrown during backup or restore operations. Generates a descriptive user-facing message, and invokes a UI-side function (e.g., Snackbar or Dialog) to notify the user. Explicitly ensures that no state or metadata is changed unless the operation was completed atomically. No further side effects are performed upon error. |  |
| BackupJobHandler | handleScheduledBackup(): Promise<BackgroundFetch.Result> | The handler registered with Expo's background-fetch/task-manager for daily scheduled backups. Loads the `backupEnabled` flag from SettingsStore/SQLite; if false, returns `BackgroundFetch.Result.NoData`. If enabled, performs backup by copying the SQLite DB to secure app storage with a timestamped filename, updates backup metadata in SecureStore, and prunes old backups (to keep last 5). Returns `BackgroundFetch.Result.NewData` on success. Handles errors by invoking handleBackupFailure (which returns `Result.Failed`). No UI is updated in this phase. |  |
| AdBanner | renderConditionalAdBanner(): React.ReactNode | Called on each render of the AdBanner component. Uses Zustand's selector (e.g., `useStore(state => state.adsFreePurchased)`). If `adsFreePurchased` is true, returns `null` or an empty placeholder `<View>`; if false, renders the `<AdBannerComponent />` (e.g., AdMob or expo-ads-adapter). Ensures correct preservation of layout. Handles reactivity so banner visibility updates automatically when store value changes. |  |
| AdBanner | handleAdError(error: Error): void | Passed as the `onAdFailedToLoad` prop to the AdBanner component. On ad load failure, updates local UI state so the render function returns a fixed-height empty `<View>` to preserve layout and prevent UI jump. No further action (no retries or logging). Error can be logged for debugging if desired, but not shown to the user. |  |

# File Definitions:
| File Name | Components That Must Be Implemented Within The File | Static Definitions That Must Be Implemented Within The File |
| --------- | --------------------------------------------------- | ----------------------------------------------------------- |
| /src/models/domain.ts |  | SoundOrigin, SegmentationSoundConfig, MeditationSoundConfig, SessionSegment, SessionTimer, MeditationLog, DiaryEntry, NotificationRecord, Settings, BackupMeta, StatsSummary, StatsByPeriod |
| /src/validation/validationRules.ts |  | SessionTimerValidation, MeditationLogValidation, DiaryEntryValidation, NotificationRecordValidation, SettingsValidation |
| /src/store/types.ts |  | SessionTimersState, MeditationLogsState, DiaryEntriesState, NotificationsState, SettingsState, BackupMetaState |
| /src/repositories/interfaces.ts |  | ISessionTimerRepository, IMeditationLogRepository, IDiaryEntryRepository, INotificationRepository, ISettingsRepository |
| /src/contracts/serviceInterfaces.ts |  | INotificationManager, IBackupJobHandler, IAppBootManager, ITimerStateStore, ISettingsStore, IDiaryStore, ILogStateStore, IApplicationRuntimeBootstrapper |
| /src/config/configTemplate.yaml |  | YAML Configuration Template |
| /src/serialization/serializationFormats.md |  | Diary Entry YAML Export, Statistics YAML Export |
| /src/validation/SessionTimerValidator.ts | SessionTimerValidator | SessionTimerValidation |
| /src/validation/DiaryEntryValidationManager.ts | DiaryEntryValidationManager | DiaryEntryValidation |
| /src/delegates/CalendarDateTimeFormatter.ts | CalendarDateTimeFormatter |  |
| /src/delegates/TimerStateStoreFormErrorHelper.ts | TimerStateStoreFormErrorHelper |  |
| /src/delegates/UndoRedoStackManager.ts | UndoRedoStackManager |  |
| /src/delegates/SessionTimerDraftManager.ts | SessionTimerDraftManager |  |
| /src/repositories/SessionTimerRepoAdapter.ts | SessionTimerRepoAdapter | ISessionTimerRepository |
| /src/delegates/SessionTimerReminderCoordinator.ts | SessionTimerReminderCoordinator | INotificationManager |
| /src/delegates/SessionTimerFormPersistenceHelper.ts | SessionTimerFormPersistenceHelper |  |
| /src/delegates/SessionTimerFormFilePickerHelper.ts | SessionTimerFormFilePickerHelper |  |
| /src/layouts/SessionTimerFormLayout.tsx | SessionTimerFormLayout |  |
| /src/delegates/MainScreenAccessibilityHelper.ts | MainScreenAccessibilityHelper |  |
| /src/delegates/MainScreenTimerListRenderer.tsx | MainScreenTimerListRenderer |  |
| /src/delegates/MainScreenBackgroundImageManager.ts | MainScreenBackgroundImageManager |  |
| /src/delegates/SessionAudioOrchestrator.ts | SessionAudioOrchestrator |  |
| /src/delegates/MeditationSessionTimerManager.ts | MeditationSessionTimerManager |  |
| /src/delegates/SessionOSIntegrationManager.ts | SessionOSIntegrationManager |  |
| /src/layouts/SessionWindowTopBar.tsx | SessionWindowTopBar |  |
| /src/layouts/SessionCentralAnimation.tsx | SessionCentralAnimation |  |
| /src/layouts/DiaryEntryEditorButtonRow.tsx | DiaryEntryEditorButtonRow |  |
| /src/delegates/DiaryEntryDeleteDialogManager.tsx | DiaryEntryDeleteDialogManager |  |
| /src/layouts/CalendarDayEntryListRenderer.tsx | CalendarDayEntryListRenderer |  |
| /src/serialization/DiaryExportYAMLSerializer.ts | DiaryExportYAMLSerializer |  |
| /src/aggregation/StatisticsAggregator.ts | StatisticsAggregator | StatsSummary, StatsByPeriod |
| /src/serialization/StatisticsYAMLExportHelper.ts | StatisticsYAMLExportHelper |  |
| /src/validation/StatisticsChartErrorManager.ts | StatisticsChartErrorManager |  |
| /src/layouts/StatisticsPagePeriodSelector.tsx | StatisticsPagePeriodSelector |  |
| /src/layouts/StatisticsByMonthDetailList.tsx | StatisticsByMonthDetailList |  |
| /src/persistence/SettingsPersistenceDelegate.ts | SettingsPersistenceDelegate | SettingsValidation, ISettingsRepository |
| /src/delegates/SettingsDialogManager.ts | SettingsDialogManager |  |
| /src/delegates/SettingsBackupMetadataManager.ts | SettingsBackupMetadataManager |  |
| /src/delegates/SettingsMonetizationHandler.ts | SettingsMonetizationHandler |  |
| /src/delegates/SettingsSharingExportHandler.ts | SettingsSharingExportHandler |  |
| /src/delegates/SettingsPermissionsHandler.ts | SettingsPermissionsHandler |  |
| /src/delegates/SettingsBackgroundImagePicker.ts | SettingsBackgroundImagePicker |  |
| /src/persistence/NotificationSQLiteHelper.ts | NotificationSQLiteHelper | INotificationRepository |
| /src/delegates/NotificationTimeTriggerGenerator.ts | NotificationTimeTriggerGenerator |  |
| /src/delegates/NotificationScheduleErrorHandler.ts | NotificationScheduleErrorHandler |  |
| /src/persistence/BackupFileIOManager.ts | BackupFileIOManager | BackupMeta |
| /src/delegates/BackupConcurrencyFlagManager.ts | BackupConcurrencyFlagManager |  |
| /src/store/SettingsStore.ts | SettingsStore |  |
| /src/store/LogStateStore.ts | LogStateStore |  |
| /src/store/DiaryStore.ts | DiaryStore |  |
| /src/store/TimerStateStore.ts | TimerStateStore |  |
| /src/navigation/NavigationLayer.ts | NavigationLayer |  |
| /src/views/MeditationSessionWindow.tsx | MeditationSessionWindow |  |
| /src/views/DiaryEntryEditor.tsx | DiaryEntryEditor |  |
| /src/views/CalendarView.tsx | CalendarView |  |
| /src/views/DiaryView.tsx | DiaryView |  |
| /src/views/StatisticsPage.tsx | StatisticsPage |  |
| /src/delegates/BackupEligibilityChecker.ts | BackupEligibilityChecker |  |
| /src/delegates/BackupJobHydrationManager.ts | BackupJobHydrationManager |  |
| /src/components/AdBanner.tsx | AdBanner |  |
| /src/services/NotificationManager.ts | NotificationManager |  |
| /src/services/BackupJobHandler.ts | BackupJobHandler |  |
| /src/bootstrap/ApplicationRuntimeBootstrapper.ts | ApplicationRuntimeBootstrapper |  |
| /src/bootstrap/AppBootManager.ts | AppBootManager |  |
| /src/views/SessionTimerForm.tsx | SessionTimerForm |  |
| /src/delegates/MainScreenAdBannerRenderer.tsx | MainScreenAdBannerRenderer |  |
| /src/delegates/SettingsRestoreBackupHandler.ts | SettingsRestoreBackupHandler |  |
| /src/views/MainScreen.tsx | MainScreen |  |
| /src/views/SettingsMenu.tsx | SettingsMenu |  |

# Static Report:
##### **Core Data Structures & Domain Models
```typescript
// ---- Session Timer Domain Model ----
type SoundOrigin = 'system' | 'user_file';

export interface SegmentationSoundConfig {
  uri: string; // URI for system ringtone or user audio file
  repetition: number; // integer, 1-3
  volume: number; // integer, 0-5
}

export interface MeditationSoundConfig {
  uri: string; // URI for system ringtone or user audio file
  origin: SoundOrigin; // 'system' or 'user_file'
  repetitionType: 'forever' | 'count';
  repetitionCount?: number; // integer >=1 if repetitionType == 'count'
  volume: number; // integer, 0-5
}

export interface SessionSegment {
  index: number; // 0-based
  duration: number; // seconds, integer >= 1
}

export interface SessionTimer {
  id: string; // PK, UUID or SQLite TEXT PRIMARY KEY
  name: string;
  preparationTime: number; // seconds, integer >= 0
  segmentationSound: SegmentationSoundConfig;
  meditationSound: MeditationSoundConfig;
  segments: SessionSegment[]; // length 1‚Äì4, at least 1 required
  dailyReminderEnabled: boolean;
  reminderTime?: string; // "HH:mm" 24h format, present if dailyReminderEnabled
  enableDiaryNote: boolean;
}

// ---- Meditation Log ----
export interface MeditationLog {
  timestamp: string; // PK, ISO8601, when meditation started
  duration: number; // seconds, integer >= 1
}

// ---- Diary Entry ----
export interface DiaryEntry {
  timestamp: string; // PK, ISO8601, unique
  content: string;
}

// ---- Notification Record ----
export interface NotificationRecord {
  id: string; // PK, expo-notifications ID
  frequency: string; // "daily" | "every_n_days" | "every_n_hours"
  time: string; // "HH:mm" or ISO8601
  sessionTimerId: string; // FK to SessionTimer.id
  enabled: boolean;
}

// ---- Settings ----
export interface Settings {
  theme: string; // color/theme name or palette id
  adsFreePurchased: boolean;
  dndEnabled: boolean;
  backupEnabled: boolean;
  keepScreenOn: boolean;
  countUp: boolean;
  sessionBackgroundImage: string; // URI or built-in image ref
}

// ---- Backup Metadata ----
export interface BackupMeta {
  filePath: string;
  timestamp: string; // ISO8601
}

// ---- Statistics (for export) ----
export interface StatsSummary {
  total_sessions: number;
  total_time_minutes: number;
  average_session_duration_minutes: number;
}

export interface StatsByPeriod {
  period: string; // e.g., "2025-05", "2025", "2025-Q1"
  total_sessions: number;
  total_minutes: number;
}
```


##### **State Store Interface
```typescript
// Zustand slice types for each domain

// ---- SessionTimers Slice ----
export interface SessionTimersState {
  sessionTimers: SessionTimer[];
  draftSessionTimer: SessionTimer | null;
  setSessionTimers(timers: SessionTimer[]): void;
  setDraftSessionTimer(timer: SessionTimer): void;
  resetDraftSessionTimer(): void;
  saveSessionTimer(timer: SessionTimer): Promise<void>;
  deleteSessionTimer(timerId: string): Promise<void>;
  loadSessionTimer(timerId: string): Promise<SessionTimer | null>;
}

// ---- MeditationLogs Slice ----
export interface MeditationLogsState {
  meditationLogs: MeditationLog[];
  addMeditationLog(log: MeditationLog): void;
  updateMeditationLogDuration(timestamp: string, duration: number): void;
  hydrateFromDB(): void;
}

// ---- DiaryEntries Slice ----
export interface DiaryEntriesState {
  diaryEntries: DiaryEntry[];
  saveDiaryEntry(entry: DiaryEntry): void;
  deleteDiaryEntry(timestamp: string): void;
  hydrateFromDB(): void;
}

// ---- Notifications Slice ----
export interface NotificationsState {
  notificationRecords: NotificationRecord[];
  setNotificationRecords(records: NotificationRecord[]): void;
}

// ---- Settings Slice ----
export interface SettingsState {
  settings: Settings;
  setSettings(settings: Settings): void;
  setTheme(theme: string): void;
  setAdsFreePurchased(purchased: boolean): Promise<void>;
  setDndEnabled(enabled: boolean): void;
  setBackupEnabled(enabled: boolean): void;
  setKeepScreenOn(enabled: boolean): void;
  setCountUp(enabled: boolean): void;
  setBackgroundImage(imageRef: string): Promise<void>;
  setHydratedSettings(settings: Settings): void;
  setDefaults(): void;
  revertToPersistedSettings(): Promise<void>;
}

// ---- BackupMeta Slice ----
export interface BackupMetaState {
  backups: BackupMeta[];
  setBackups(backups: BackupMeta[]): void;
}
```


##### **Persistence & Data Access Interfaces
#### SQLite Table Schemas (DDL)
```sql
-- SessionTimers
CREATE TABLE IF NOT EXISTS SessionTimers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    preparationTime INTEGER NOT NULL,
    segmentationSound TEXT NOT NULL,        -- JSON (SegmentationSoundConfig)
    meditationSound TEXT NOT NULL,          -- JSON (MeditationSoundConfig)
    segments TEXT NOT NULL,                 -- JSON (SessionSegment[])
    dailyReminderEnabled INTEGER NOT NULL,
    reminderTime TEXT,                      -- nullable, "HH:mm"
    enableDiaryNote INTEGER NOT NULL
);

-- MeditationLogs
CREATE TABLE IF NOT EXISTS MeditationLogs (
    timestamp TEXT PRIMARY KEY, -- ISO8601
    duration INTEGER NOT NULL
);

-- DiaryEntries
CREATE TABLE IF NOT EXISTS DiaryEntries (
    timestamp TEXT PRIMARY KEY, -- ISO8601
    content TEXT NOT NULL
);

-- Notifications
CREATE TABLE IF NOT EXISTS Notifications (
    id TEXT PRIMARY KEY, -- expo-notifications ID
    frequency TEXT NOT NULL,
    time TEXT NOT NULL,
    sessionTimerId TEXT NOT NULL,
    enabled INTEGER NOT NULL
);

-- Settings (single row, id=1)
CREATE TABLE IF NOT EXISTS Settings (
    id INTEGER PRIMARY KEY CHECK (id=1),
    theme TEXT NOT NULL,
    adsFreePurchased INTEGER NOT NULL,
    dndEnabled INTEGER NOT NULL,
    backupEnabled INTEGER NOT NULL,
    keepScreenOn INTEGER NOT NULL,
    countUp INTEGER NOT NULL,
    sessionBackgroundImage TEXT
);
```

#### Data Access Layer Interfaces

```typescript
export interface ISessionTimerRepository {
  getAll(): Promise<SessionTimer[]>;
  getById(id: string): Promise<SessionTimer | null>;
  save(timer: SessionTimer): Promise<void>;
  delete(id: string): Promise<void>;
}

export interface IMeditationLogRepository {
  getAll(): Promise<MeditationLog[]>;
  getByTimestamp(timestamp: string): Promise<MeditationLog | null>;
  save(log: MeditationLog): Promise<void>;
  updateDuration(timestamp: string, duration: number): Promise<void>;
}

export interface IDiaryEntryRepository {
  getAll(): Promise<DiaryEntry[]>;
  getByTimestamp(timestamp: string): Promise<DiaryEntry | null>;
  save(entry: DiaryEntry): Promise<void>;
  delete(timestamp: string): Promise<void>;
}

export interface INotificationRepository {
  getAll(): Promise<NotificationRecord[]>;
  save(record: NotificationRecord): Promise<void>;
  delete(id: string): Promise<void>;
}

export interface ISettingsRepository {
  get(): Promise<Settings>;
  save(settings: Settings): Promise<void>;
}
```


##### **Service & Component Communication Interfaces
```typescript
// ---- NotificationManager ----
export interface INotificationManager {
  scheduleOrUpdateReminder(timerId: string, reminderData: NotificationRecord): Promise<void>;
  cancelReminder(timerId: string): Promise<void>;
  cancelAllRemindersForTimer(timerId: string): Promise<void>;
  loadAllRemindersFromDB(): Promise<void>;
  syncScheduledNotifications(): Promise<void>;
  handleNotificationResponse(response: any): Promise<void>;
}

// ---- BackupJobHandler ----
export interface IBackupJobHandler {
  restoreDatabaseFromFile(fileUri: string): Promise<void>;
  registerBackupJob(): Promise<void>;
  unregisterBackupJob(): Promise<void>;
  handleDatabaseRestore(): Promise<void>;
  executeBackup(): Promise<void>;
  cleanupOldBackups(): Promise<void>;
  updateBackupMetadata(): Promise<void>;
  handleScheduledBackup(): Promise<void>;
}

// ---- Inter-Component Calls ----
// See above interfaces. No direct sharing of concrete classes; only API contracts as documented.
// Communication is via explicit method calls, React Navigation (navigation.navigate()), and Zustand subscriptions (see event interfaces).

// ---- Event Bindings (React/Expo/Native Integration) ----
// - Expo-notifications: Notification tap ‚Üí NotificationManager.handleNotificationResponse
// - Expo-background-fetch/task-manager: Scheduled background backup ‚Üí BackupJobHandler.handleScheduledBackup
// - React Navigation: NavigationLayer.navigateToSessionTimer/DiaryEntryEditor/etc.
// - Zustand subscriptions: All slices automatically notify React components via selector hooks; no manual event bus.
```


##### **Configuration Management & Dependency Injection Contracts
```yaml
# Configuration File Template (for reference only; not part of runtime, but loaded from SQLite and SecureStore/AsyncStorage)
theme: "default"
adsFreePurchased: false
dndEnabled: false
backupEnabled: false
keepScreenOn: false
countUp: false
sessionBackgroundImage: ""
backupFolder: "backups/"
sqliteDbFile: "SQLite/app.db"
locale: "system"
```

- All configuration is loaded by AppBootManager from SQLite Settings table (for settings), SecureStore (for backup metadata), and AsyncStorage (for session background image as needed).
- No runtime environment configs are used beyond device-local storage.
- Dependency injection is handled at runtime using explicit imports and synchronous initialization in the ApplicationRuntimeBootstrapper (see Architectural Plan).


##### **Mandatory Dependency Injection Contracts
```typescript
// Example Dependency Injection Contracts

// AppBootManager
interface IAppBootManager {
  checkAndRestoreSessionState(): Promise<void>;
  hydrateSettingsStore(): Promise<void>;
  handleCorruptSettingsData(): void;
  handleAppStartOrResume(state: any): Promise<void>;
  unregisterBackupJob(): Promise<void>;
  registerBackupJob(): Promise<void>;
}
// Imported by: SettingsMenu, NotificationManager, ApplicationRuntimeBootstrapper

// TimerStateStore
interface ITimerStateStore {
  // see ::StateStoreInterface for all methods
}
// Imported by: SessionTimerForm, MainScreen, NotificationManager, AppBootManager

// SettingsStore
interface ISettingsStore {
  // see ::StateStoreInterface for all methods
}
// Imported by: SettingsMenu, MainScreen, AppBootManager, AdBanner, MeditationSessionWindow, NotificationManager

// DiaryStore
interface IDiaryStore {
  // see ::StateStoreInterface for all methods
}
// Imported by: DiaryEntryEditor, DiaryView, CalendarView, AppBootManager

// LogStateStore
interface ILogStateStore {
  // see ::StateStoreInterface for all methods
}
// Imported by: MeditationSessionWindow, CalendarView, StatisticsPage, AppBootManager

// NotificationManager
interface INotificationManager { /* see ::CommunicationInterfaces */ }
// Imported by: TimerStateStore, AppBootManager, SessionTimerForm

// BackupJobHandler
interface IBackupJobHandler { /* see ::CommunicationInterfaces */ }
// Imported by: SettingsMenu, AppBootManager

// ApplicationRuntimeBootstrapper
interface IApplicationRuntimeBootstrapper {
  initializeGlobalDependencies(): void;
}
// Imported by: App.tsx root entrypoint

// See Architectural Plan for the precise list of which classes import/use which interfaces.
```


##### **Validation & Constraint Definitions
```typescript
// ---- SessionTimer Validation ----
const SessionTimerValidation = {
  name: { required: true, minLength: 1 },
  preparationTime: { required: true, type: "integer", min: 0 },
  segmentationSound: {
    uri: { required: true, pattern: /^.+$/ },
    repetition: { required: true, type: "integer", min: 1, max: 3 },
    volume: { required: true, type: "integer", min: 0, max: 5 }
  },
  meditationSound: {
    uri: { required: true, pattern: /^.+$/ },
    origin: { required: true, enum: ["system", "user_file"] },
    repetitionType: { required: true, enum: ["forever", "count"] },
    repetitionCount: {
      required: false,
      type: "integer",
      min: 1,
      custom: "required if repetitionType == 'count'"
    },
    volume: { required: true, type: "integer", min: 0, max: 5 }
  },
  segments: {
    required: true,
    type: "array",
    minItems: 1,
    maxItems: 4,
    items: {
      index: { type: "integer", min: 0 },
      duration: { type: "integer", min: 1 }
    }
  },
  dailyReminderEnabled: { required: true, type: "boolean" },
  reminderTime: { required: false, pattern: /^([01]\d|2[0-3]):([0-5]\d)$/ },
  enableDiaryNote: { required: true, type: "boolean" }
};

// ---- MeditationLog Validation ----
const MeditationLogValidation = {
  timestamp: { required: true, format: "ISO8601", unique: true },
  duration: { required: true, type: "integer", min: 1 }
};

// ---- DiaryEntry Validation ----
const DiaryEntryValidation = {
  timestamp: { required: true, format: "ISO8601", unique: true },
  content: { required: true, minLength: 1 }
};

// ---- NotificationRecord Validation ----
const NotificationRecordValidation = {
  id: { required: true },
  frequency: { required: true, enum: ["daily", "every_n_days", "every_n_hours"] },
  time: { required: true, pattern: /^([01]\d|2[0-3]):([0-5]\d)$/ },
  sessionTimerId: { required: true },
  enabled: { required: true }
};

// ---- Settings Validation ----
const SettingsValidation = {
  theme: { required: true },
  adsFreePurchased: { required: true, type: "boolean" },
  dndEnabled: { required: true, type: "boolean" },
  backupEnabled: { required: true, type: "boolean" },
  keepScreenOn: { required: true, type: "boolean" },
  countUp: { required: true, type: "boolean" },
  sessionBackgroundImage: { required: true }
};
```

- Validation is enforced at form/entry points and before writing to SQLite.
- Duplicate DiaryEntry timestamps overwrite previous entry.
- Only one DiaryEntry per MeditationLog timestamp (1:1 enforced).
- All time/date fields must be ISO8601 formatted and validated on input.


##### **Lifecycle Contracts
- **SessionTimer**: Permanent state in SQLite. Draft/in-progress state only local (Zustand), discarded if not saved.
- **MeditationLog**: Permanent state in SQLite. Edits to duration overwrite value.
- **DiaryEntry**: Permanent state in SQLite. In-memory/draft/undo/redo only local (React state), discarded on editor close/unmount.
- **Settings**: Permanent, single-row state in SQLite/AsyncStorage/SecureStore. Hydrated on app boot.
- **BackupMeta**: Permanent state in SecureStore as JSON array. Old backups deleted after max 5 retained.
- **NotificationRecord**: Permanent state in SQLite, always synchronized with expo-notifications system schedule.
- **All stores**: Hydrated on app boot/restore, hydrated after backup is restored, and always reloaded if database changes.


##### **Event & Messaging Interfaces
- **Zustand Store Events**: All slices emit automatic change events on mutation. React components subscribe via useStore hooks/selectors; React triggers re-renders. No custom event bus.
- **Expo-notifications**: Notification taps trigger NotificationManager.handleNotificationResponse(response), which navigates using NavigationLayer.
- **Expo-background-fetch/task-manager**: Handles scheduled background jobs (backup) via BackupJobHandler.handleScheduledBackup().
- **React Navigation**: Navigation events (focus, beforeRemove, etc.) are bound as per component definitions. All navigation is explicit and only via NavigationLayer and React Navigation API.
- **No additional custom or external message bus/event system is used.**


##### **SerializationFormats
#### Diary Entry YAML Export

```yaml
diary_entries:
- timestamp: "2025-06-10T07:30:00"
  content: >
    Had a really deep session today. Breathing felt effortless.
    Noticed more space between thoughts.
- timestamp: "2025-06-11T08:15:00"
  content: >
    Mind was scattered. Couldn't settle. Felt restless.
```

#### Statistics YAML Export

```yaml
summary:
  total_sessions: 86
  total_time_minutes: 2850
  average_session_duration_minutes: 33.1
by_month:
- month: "2025-05"
  total_sessions: 40
  total_minutes: 1280
- month: "2025-06"
  total_sessions: 12
  total_minutes: 420
```

- All exports must conform exactly to these schemas; only persisted, valid entries (no in-memory/draft/invalid entries allowed).
- YAML produced via JS-YAML or equivalent, with no extra formatting or speculative fields.


##### **Error Handling & Fault Tolerance
- **Validation Errors**: On invalid user input, block save and display inline error via UI (HelperText, Dialog, Snackbar).
- **Persistence Errors**: On SQLite or file-system error, set error state, display error, and do not apply partial writes. Roll back to last known good state by reloading from storage.
- **Notification Scheduling Errors**: On schedule/cancel failure, roll back in-memory/UI state by rehydrating from DB; display error dialog.
- **Backup/Restore Errors**: On error, do not modify state or meta; display error via Snackbar/Dialog.
- **No logging or analytics implemented.**
- **No speculative or inferred recovery. Only error-handling paths explicitly listed above are present.**
- **No global error bus; errors are surfaced only via component-local state and UI feedback.**


##### **Concurrency & Synchronization Handling
- All writes to persistent storage (SQLite, SecureStore) are atomic and transactional.
- Backup/restore operations are protected by an `isBackupInProgress` flag in Zustand; only one backup/restore may run at a time.
- Any attempt to start a second backup/restore is rejected and a UI error is shown.
- No other concurrency or multi-user synchronization logic; no shared or distributed state.
- No thread-safety or locking beyond these atomic operations.


##### **Multi-User Environments & Authentication
Not applicable. No multi-user, authentication, or role-based access control. All data is local to the device and user.

End of report.
